<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>构建零知识证明系统</title>
    <link href="/2024/03/24/ZK/"/>
    <url>/2024/03/24/ZK/</url>
    
    <content type="html"><![CDATA[<h2 id="构建零知识证明系统之前-问题转换"><a href="#构建零知识证明系统之前-问题转换" class="headerlink" title="构建零知识证明系统之前 - 问题转换"></a>构建零知识证明系统之前 - 问题转换</h2><blockquote><p>需要将函数f转换成特定的格式  匹诺曹协议 cf. Pinocchio: Nearly Practical Verifiable Computation</p><p><img src="/images/ZK/image-20240319135619297.png" alt="image-20240319135619297"></p></blockquote><h3 id="Plonk-中的问题转换"><a href="#Plonk-中的问题转换" class="headerlink" title="Plonk 中的问题转换"></a>Plonk 中的问题转换</h3><blockquote><p><img src="/images/ZK/image-20240319140550670.png" alt="image-20240319140550670"></p></blockquote><h2 id="问题转化解释"><a href="#问题转化解释" class="headerlink" title="问题转化解释"></a>问题转化解释</h2><p>在零知识证明系统的应用中，需要首先计算问题转换成特定的形式，在ZK-snark中是转换成多项式，或者R1CS的向量形式，二次算术程序”（QAP）（cf. <a href="https://vitalik.eth.limo/general/2016/12/10/qap.html）">https://vitalik.eth.limo/general/2016/12/10/qap.html）</a></p><p>对外发布证明时，有三种简洁的技术可以将这些知识进行抽象：默克尔树（FRI），常规椭圆曲线，椭圆曲线和配对（KZG承诺）</p><p>Readers who have been <a href="https://vitalik.eth.limo/general/2019/09/22/plonk.html">following</a> the <a href="https://vitalik.eth.limo/general/2017/02/01/zk_snarks.html">ZK-SNARK</a> space <a href="https://vitalik.eth.limo/general/2017/11/09/starks_part_1.html">closely</a> should by now be familiar with the high level of how ZK-SNARKs work. ZK-SNARKs are based on checking equations where the elements going into the equations are mathematical abstractions like <a href="https://vitalik.eth.limo/general/2021/01/26/snarks.html">polynomials</a> (or in <a href="https://vitalik.eth.limo/general/2016/12/10/qap.html">rank-1 constraint systems</a> matrices and vectors) that can hold a lot of data. There are three major families of cryptographic technologies that allow us to represent these abstractions succinctly: Merkle trees (for <a href="https://vitalik.eth.limo/general/2017/11/09/starks_part_1.html">FRI</a>), regular elliptic curves (for <a href="https://twitter.com/VitalikButerin/status/1371844878968176647">inner product arguments (IPAs)</a>), and elliptic curves with pairings and trusted setups (for <a href="https://dankradfeist.de/ethereum/2020/06/16/kate-polynomial-commitments.html">KZG commitments</a>). <strong>These three technologies lead to the three types of proofs: FRI leads to STARKs, KZG commitments lead to “regular” SNARKs, and IPA-based schemes lead to bulletproofs. These three technologies have very distinct tradeoffs:</strong></p><blockquote><ul><li>多项式承诺的三种最突出的类型是 FRI、Kate 和Bulletproofs。</li><li>凯特在概念上是最简单的，但依赖于椭圆曲线配对的真正复杂的“黑匣子”。</li><li>FRI 很酷，因为它只依赖于哈希值；它的工作原理是连续将多项式简化为越来越低阶的多项式，并使用 Merkle 分支进行随机样本检查，以证明每一步的等价性。</li><li>为了防止单个数字的大小爆炸，我们不是<em>对整数进行算术和多项式，而是**在有限域上</em>进行所有操作（通常是对某个素数取模的整数<code>p</code>）</li><li>多项式承诺自然而然地有助于隐私保护，因为证明已经比多项式小得多，因此多项式承诺无论如何都无法揭示多项式中的一点点信息。但我们可以在我们承诺的多项式中添加一些随机性，以将揭示的信息从“一点点”减少到“零”。</li></ul></blockquote><h2 id="区块链的ZK就是要解决计算完整性"><a href="#区块链的ZK就是要解决计算完整性" class="headerlink" title="区块链的ZK就是要解决计算完整性"></a>区块链的ZK就是要解决计算完整性</h2><p>作为解决CI（计算完整性）的方法。ZK就是一个成熟的解决隐私问题的证明系统。ZK目前有两个主流方案，zk-snark和zk-stark，简单说一下两个方法的步骤：</p><p><strong>zksnark：</strong>先将原是复杂计算的代码扁平化，转换成只有加法和乘法的两种形式的代码，或者称为电路门，然后将它转换成rank-1约束系统（即R1CS），在转换成QAP，使用<strong>拉格朗日插值法，</strong>目的是为了同时检查所有约束条件，检查通过即完成一次完整的stark。优点是安全可靠，检查一次多项式等价于检查了所有的电路门，但正是这个原因，也是stark的缺点，计算所有的逻辑门说明复杂度会很高，计算量也会非常大（一般都会超过100万个电路门）。</p><p><strong>zkstark ：</strong>将CI语言转换成代数语言，一般包括执行追踪和一组多项式约束，参考在超市消费的小票，执行追踪就是将每一行和前后相邻的那一行相关。多项式约束可以进行局部检查，即<strong>低度测试，而且有容错冗余，</strong>之前用RS编码进行举例：<em>比如要发送2345，实际根据编码本发送的值是two thvee four fiva，比要证明的值长，并且有错误，但是也可以推出原始数据2345。</em>FRI协议就是stark自己的检查正确性的协议。简单总结一下优点是生成简短并且能快速验证的证明。这么看下来stark缺点几乎是没有，不过在一些以太坊支持者来看，可能缺点就是不能兼容evm。</p><h2 id="ZK-snark-核心四个步骤"><a href="#ZK-snark-核心四个步骤" class="headerlink" title="ZK-snark 核心四个步骤"></a>ZK-snark 核心四个步骤</h2><p>As a very short summary, zkSNARKs as currently implemented, have 4 main ingredients (don’t worry, we will explain all the terms in later sections):</p><h4 id="A-Encoding-as-a-polynomial-problem"><a href="#A-Encoding-as-a-polynomial-problem" class="headerlink" title="A) Encoding as a polynomial problem"></a><strong>A) Encoding as a polynomial problem</strong></h4><p>The program that is to be checked is compiled into a quadratic equation of polynomials: t(x) h(x) = w(x) v(x), where the equality holds if and only if the program is computed correctly. The prover wants to convince the verifier that this equality holds.</p><p>2013 年，Gennaro、Gentry、Parno 和 Raykova 的<a href="https://eprint.iacr.org/2012/215.pdf">另一项突破性工作定义了一种非常有用的计算到多项式的转换，称为</a><em>二次算术规划</em>(QAP)。QAP 已成为现代 zk-SNARK 结构的基础</p><h4 id="B-Succinctness-by-random-sampling"><a href="#B-Succinctness-by-random-sampling" class="headerlink" title="B) Succinctness by random sampling"></a><strong>B) Succinctness by random sampling</strong></h4><p>The verifier chooses a secret evaluation point s to reduce the problem from multiplying polynomials and verifying polynomial function equality to simple multiplication and equality check on numbers: t(s)h(s) = w(s)v(s)</p><p>This reduces both the proof size and the verification time tremendously.</p><h4 id="C-Homomorphic-encoding-encryption"><a href="#C-Homomorphic-encoding-encryption" class="headerlink" title="C) Homomorphic encoding / encryption"></a><strong>C) Homomorphic encoding / encryption</strong></h4><p>An encoding/encryption function E is used that has some homomorphic properties (but is not fully homomorphic, something that is not yet practical). This allows the prover to compute E(t(s)), E(h(s)), E(w(s)), E(v(s)) without knowing s, she only knows E(s) and some other helpful encrypted values.</p><h4 id="D-Zero-Knowledge"><a href="#D-Zero-Knowledge" class="headerlink" title="D) Zero Knowledge"></a><strong>D) Zero Knowledge</strong></h4><p>The prover permutes the values E(t(s)), E(h(s)), E(w(s)), E(v(s)) by multiplying with a number so that the verifier can still check their correct <em>structure</em> without knowing the actual encoded values.</p><p>The very rough idea is that checking t(s)h(s) = w(s)v(s) is identical to checking t(s)h(s) k = w(s)v(s) k for a random secret number k (which is not zero), with the difference that if you are sent only the numbers (t(s)h(s) k) and (w(s)v(s) k), it is impossible to derive t(s)h(s) or w(s)v(s).</p><p>This was the hand-waving part so that you can understand the essence of zkSNARKs, and now we get into the details.</p><h2 id="Types-of-Zero-Knowledge-Proofs"><a href="#Types-of-Zero-Knowledge-Proofs" class="headerlink" title="Types of Zero-Knowledge Proofs"></a><strong>Types of Zero-Knowledge Proofs</strong></h2><p>There are various implementations of ZKPs, with each having its own trade-offs of proof size, prover time, verification time, and more. They include:</p><h4 id="zk-SNARKs"><a href="#zk-SNARKs" class="headerlink" title="zk-SNARKs"></a><strong>zk-SNARKs</strong></h4><p>SNARKs, which stands for “succinct non-interactive argument of knowledge”, are small in size and easy to verify. They generate a cryptographic proof using elliptical curves, which is more gas-efficient than the hashing function method used by STARKS.</p><h4 id="zk-STARKs"><a href="#zk-STARKs" class="headerlink" title="zk-STARKs"></a><strong>zk-STARKs</strong></h4><p>STARK stands for “scalable transparent argument of knowledge”. STARK-based proofs require minimal interaction between the prover and the verifier, making them much faster than SNARKs.</p><h4 id="PLONK"><a href="#PLONK" class="headerlink" title="PLONK"></a><strong>PLONK</strong></h4><p>Standing for “permutations over Lagrange-bases for oecumenical noninteractive arguments of knowledge,” PLONKs use a universal trusted setup that can be used with any program and can include a large number of participants.</p><h4 id="Bulletproofs"><a href="#Bulletproofs" class="headerlink" title="Bulletproofs"></a><strong>Bulletproofs</strong></h4><p>Bulletproofs are short non-interactive zero-knowledge proofs that require no trusted setup. They are designed to enable private transactions for cryptocurrencies.</p><h2 id="ZKP-应用的三个例子"><a href="#ZKP-应用的三个例子" class="headerlink" title="ZKP 应用的三个例子"></a>ZKP 应用的三个例子</h2><p>Dark Mode <img src="https://vitalik.eth.limo/images/starks-part-1-files/starks_pic1.png" alt="img">Toggle</p><p><img src="/images/ZK/image-20240318135437527.png" alt="image-20240318135437527"></p><p><a href="https://vitalik.eth.limo/general/2017/11/09/starks_part_1.html">https://vitalik.eth.limo/general/2017/11/09/starks_part_1.html</a></p><p><a href="https://vitalik.eth.limo/general/2017/11/22/starks_part_2.html">https://vitalik.eth.limo/general/2017/11/22/starks_part_2.html</a></p><p><img src="/images/ZK/image-20240319200958879.png" alt="image-20240319200958879"></p><p><img src="/images/ZK/image-20240319203612784.png" alt="image-20240319203612784"></p><p><img src="/images/ZK/image-20240319204626993.png" alt="image-20240319204626993"></p><p>第一步，包括多项式编码 + 证明方法</p><p><img src="/images/ZK/image-20240319204210916.png" alt="image-20240319204210916"></p><p><img src="/images/ZK/image-20240319204414546.png" alt="image-20240319204414546"></p><h2 id="ZK-stark"><a href="#ZK-stark" class="headerlink" title="ZK-stark"></a>ZK-stark</h2><blockquote><p>核心是验证，商多项式存在，即满足所有约束，则验证方只需要验证多项式，即一定拥有正确的保密数据使得转换正确</p><p><img src="/images/ZK/image-20240320195323896.png" alt="image-20240320195323896"></p></blockquote><h2 id="区块链ZK现状"><a href="#区块链ZK现状" class="headerlink" title="区块链ZK现状"></a>区块链ZK现状</h2><blockquote><p>The most popular non-interactive ZKP are: SNARK, STARK and Bulletproof. SNARK (Succinct Non-Interactive Arguments of Knowledge) [16] is a non-interactive ZKP that is succinct proofs are very short and easy to verify. This protocol requires a trusted setup ceremony between two parties to verify transaction validity (proving key kp to produce proof π and verification key kv to verify the proof π). It uses elliptic curve pairings cryptography [17]. STARK (Scalable Transparent ARgument of Knowledge)[18] does not require trusted setup and uses simpler cryptographic algorithms (based on hashing and information theory). It uses the FRI[19] prover protocol with strictly linear arithmetic complexity and strictly logarithmic verifier arithmetic complexity. On the other side, proof size for SNARKs is much smaller than STARKs. Bulletproof [20] is protocol without trusted setup and with very short proof. It improves STARKs by transforming interval proofs into vector inner product computation, which greatly reduces the complexity. However, verifying a bulletproof is more time consuming than verifying a SNARK proof.</p><p>最流行的非交互式 ZKP 是：SNARK、STARK 和 Bulletproof。 SNARK（简洁的非交互式知识论证）[16]是一种非交互式的 ZKP，简洁的证明非常简短且易于验证。该协议需要两方之间进行可信设置仪式来验证交易有效性（证明密钥 kp 来产生证明 π，验证密钥 kv 来验证证明 π）。它使用椭圆曲线配对密码学[17]。 STARK（可扩展透明知识论证）[18] 不需要可信设置，并使用更简单的加密算法（基于哈希和信息论）。它使用FRI[19]证明者协议，具有严格线性算术复杂度和严格对数验证者算术复杂度。另一方面，SNARK 的证明大小比 STARK 小得多。 Bulletproof [20] 是一种没有可信设置且证明非常简短的协议。它通过将区间证明转化为向量内积计算来改进STARKs，大大降低了复杂度。然而，验证防弹证明比验证 SNARK 证明更耗时。</p><p>Examples of first generation algorithms are Pinocchio[21] and Groth16[22]. Groth16 is an efficient zk-Snark scheme which requires a trusted setup, an elliptic curve pairing and relies on strong assumptions. Growth [23] also proposed an algorithm scheme with a universal structured reference string (SRS) that allows a single setup (G3). Pinocchio is a pairing based proof system that uses Quadratic Arithmetic Program[24] for encoding computation and provides rapid proof verification. PlonK[25] (Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge) is zkSnark that the trusted setup should be initialized (as universal SRS) ones for all circuits (G2). Plonk protocol uses a batched version of the Kate polynomial commitment scheme (KZG) [26] similar to that used in [27]. Sonic[27] and Marlin[28] are zkSnarks where SRS is universal and updatable. In addition, SRS has linear size and arguments have constant size</p><p>第一代算法的例子有 Pinocchio[21] 和 Groth16[22]。 Groth16 是一种高效的 zk-Snark 方案，需要可信设置、椭圆曲线配对并依赖于强有力的假设。 Growth [23] 还提出了一种具有通用结构化参考字符串（SRS）的算法方案，允许单个设置（G3）。 Pinocchio 是一个基于配对的证明系统，它使用二次算术程序[24]进行编码计算并提供快速的证明验证。 PlonK[25] (Permutations over Lagrange-bases for Oecumenical Noninteractive argument of Knowledge) 是 zkSnark，即所有电路 (G2) 的可信设置都应该初始化（作为通用 SRS）。 Plonk 协议使用 Kate 多项式承诺方案 (KZG) [26] 的批处理版本，类似于 [27] 中使用的方案。 Sonic[27] 和 Marlin[28] 是 zkSnarks，其中 SRS 是通用且可更新的。此外，SRS 具有线性大小，参数具有恒定大小</p><p>The most popular algorithms from generation G3 are Bulletproofs[20], STARKs[18], Spartan[29] and RedShift[30]. Bulletproofs have linear verifier times, but rather short proofs[31]. RedShift has large proofs (up to 1 MB for millions of gates).</p><p>G3 代最流行的算法是 Bulletproofs[20]、STARKs[18]、Spartan[29] 和 RedShift[30]。 Bulletproofs 具有线性验证时间，但证明很短[31]。 RedShift 拥有大量证明（数百万个门可达 1 MB）。</p></blockquote><p><img src="/images/ZK/image-20240321132249015.png" alt="image-20240321132249015"></p><p><img src="/images/ZK/image-20240321132921351.png" alt="image-20240321132921351"></p><p>标准的 SNARK 设计模式一般分为三步</p><ol><li>将一个计算问题用高级程序设计语言表达：比如计算某一消息的Hash，或者加解密算法之类的，可以用C/CPP，JAVA，Python等语言将这类计算问题描述出来</li><li>将上述程序转换为等价的概率可检查模型：比如将其转化为电路可满足问题，或者转化为R1CS约束系统，这一步也成为SNARK的前端</li><li>利用证明系统对上述概率可检查模型进行证明：这一步也称为SNARK的后端，目前常用的证明系统为多项式IOP，以前的方案如Groth16也有采用线性PCP的证明系统</li></ol><p>由于 SNARK 的前端相对较为固定，因此对 SNARK 的研究主要集中在对后端的研究，具体可细分为后端的计算效率，证明大小，通信量，安全性等多个方向</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>(转载)突破区块链不可能三角（三）——POS与POW-DAG</title>
    <link href="/2024/01/16/DAG-IOTA/"/>
    <url>/2024/01/16/DAG-IOTA/</url>
    
    <content type="html"><![CDATA[<p>转载自： <a href="https://www.mytokencap.com/news/84118.html">https://www.mytokencap.com/news/84118.html</a></p><p><strong>突破区块链不可能三角（三）——POS与POW-DAG</strong></p><p>在上篇中，我们主要讨论了POW为什么不可扩展，以及如何实现可扩展的POW。我们再来把逻辑捋一捋——</p><p>1，POW是个公平的基于算力的随机产生方法，然而，它的有效性是建立在时间的基础上的，也就是说，在计算成功挖出区块的概率时，不仅仅要考虑你的算力在总算力的比例m，还要考虑你有效挖矿的时间t。换句话说，虽然我们总说如果恶意节点不拥有超过50%的算力时没法攻击比特币，然而，这里并没有考虑到时间t。也就是说，这里的50%是建立在诚实节点都在 <strong>有效挖矿</strong> 的基础上的。</p><p>2，那么，什么是有效挖矿呢？在比特币的POW里，只有在最长链上挖矿才叫有效挖矿。如果而每当一个合法区块挖出的时候，实际上拥有合法区块的链就成了最长链。而这个时候，哪怕你由于没来的及收到新区块而在原来的区块上多挖了一秒钟，你其实都在 <strong>无效挖矿</strong> 。但是对于比特币POW而言，从一开始就没有想过要避免无效挖矿的情况。它做的事情就是让无效挖矿损失的算力相比于所需要的总算力可以忽略，于是我们仍旧有接近50%的安全性。</p><p>3，那么，在什么时候这些浪费的算力不可忽略了呢？有两种情况，a）当浪费的算力增加的时候；b）当目标算力降低的时候。当增大区块的时候，由于区块所需同步的时间变长，于是从一个矿工发布有效区块开始，其他还没有来得及完成同步的矿工无效挖矿的时间也变长，于是，更多的算力被浪费了。而减小区块间隔，也就是相当于降低目标难度。两者都会使浪费的算力在总算力中所占的比重增加，导致POW算法的安全性下降。</p><p>3.5，这里我们需要注意的是——并不是只有当分叉的时候才代表了算力被浪费，也就是说说，即便不考虑分叉，随着输出的增加，安全性也会下降。但实际上对于安全性更严重的伤害是分叉，因为分叉会导致一定比例的算力会被浪费在孤块上。无论是何者，我们都看到了同一个结论——算力被浪费的比例随着区块大小B（大约）增加而增加，随着区块间隔s（大约）增加而减少，而B/s却恰恰是比特币的输出。于是，比特币POW的缺陷是——</p><p><strong>比特币的安全性和输出成反比，随着输出不断增大，比特币POW的安全性无限趋近于0。</strong></p><p>4，于是，想要获得更高的输出，我们需要改进比特币的POW算法，使得矿工能够更加有效的挖矿，即，去掉POW对于有效挖矿的限制。那么，如何能够更加有效地挖矿呢？在POW中，只有在最长链上挖矿才是有效挖矿，即， <strong>只有先同步最新的区块，即，同步所有交易，才能进行有效挖矿，而等到挖矿出了新区快，才能开始对于新区块的同步，也就是说这两个的关系是互相依赖的。</strong></p><p><img src="https://cdn.mytoken.org/8e9cd27ab5b4a810dc77e4c384e3c760" alt="img"></p><p>5，因此，想要改进比特币POW，我们要去掉POW的安全性对于同步交易的依赖，也就是说，必须把交易的传输和POW脱钩。再换个说法，就是绝对不应该对矿工的挖矿有同步整个账本的限制。</p><p>以上，就是扩展比特币POW的推理过程。应该说，里面的每一环都是必要的——也就是说，任何用POW做共识的算法，都需要考虑这些问题，也都会受到一样的限制。</p><p>然后，我们讨论了两种将传输和POW并行的思路——</p><p>1，领袖选择：用挖矿决定出块者而不是内容，即交易。这样的话，有效挖矿就不对同步所有交易做要求了，而只是“所有节点能够同步当前正确的出块者”，而这点是容易做到的。然而，它的缺陷是，对于恶意出块者的作恶行为没有约束力。因为如果我们仍旧依照“发现恶意交易就不接受并且分叉”的逻辑来执行的话，就相当于又使POW依赖于交易的同步了。因此，我们只有两个选择——a）通过一些方法来惩罚恶意出块者；b）保证出块者不作恶。前者就是Bitcoin-NG所采用的方法——如果前面有出块者作恶，那么后面的出块者可以通过某些特殊的交易拿走之前出块者的所有奖励。而后者则不能只选取一个出块者，而是需要选取很多出块者，即某个委员会。例如，我们选取前20个区块的区块发布者（即前二十个成功算出目标哈希值的矿工）。然后委员会内部通过BFT算法决定一个区块。这里需要考虑的问题是，首先委员会不能有超过1/3的恶意节点（因为要做BFT），而这点只能通过概率保证，例如，当整个网络中恶意算力不超过1/4的时候，我们可以通过大数定理保证选出20个矿工他们其中恶意的矿工数量超过1/3的可能性非常小，然而，我们却没法说如果我们只选4个矿工，那么一定最多有一个矿工是恶意的。因此，最终这个委员会的大小决定了系统的容错性，委员会越大，容错性越高，但由于要做BFT，因此延迟会更大。</p><p>2，将非最长链上的算力也纳入有效算力。这点，我们介绍了GHOST。在GHOST之中，最长链共识被改成了最重子树共识，而矿工不限定只指向前一个区块，而可以指向其他看到的深度为1的孤块，即下图这种结构：</p><p><img src="https://cdn.mytoken.org/95b549a9c138893eaeee5c873acf3b1a" alt="img"> 这里我们比较的是“子树”的“重度”，也就是区块的数量，代表了算力。根据这个规则，最下端攻击者的子树并不如上面的子树重，而4B的子树是最重的子树。</p><p>从有效挖矿的角度讲，GHOST的意义是：即便矿工没有及时完成对于最新块的同步，并且导致你在别人之后才挖出了区块，你的算力也不会浪费，同时，也不容易导致后续分叉，造成算力的浪费。</p><p>然而，GHOST仍旧不是最优的做法，因为如果同步所需要的时间超过了一个区块间隔，你挖出的区块仍旧可能无法被纳入最重链，于是算力仍旧被浪费了。因此，如果从之前安全性和输出的角度考虑画一条曲线的话，GHOST在输出不高的情况下安全性和比特币POW一样，然后，随着输出提高，然后，在很小的一个区间内，比特币的安全性下降但是GHOST的安全性不变。也就是说，GHOST能够将输出提升到这个区间。再之后，随着输出继续增加，GHOST和比特币POW的曲线是没有什么区别的，最终都会变成0。</p><p>然而，我们可以把GHOST的思路推广开来——例如，我们可以允许节点接受深度为2的孤块，继而是深度为3的孤块……最终，让所有挖出的区块都不会浪费，都能贡献给系统的安全性。从结果上来看，我们将会无限扩大GHOST那个安全性不随输出变化的区间，最终得到一个安全性不依赖于输出的算法。而从实现方法上看，其实这样的系统，就是一个DAG。</p><p>之所以我又花了这么大的篇幅又唠叨了一边比特币可扩展性的问题，是因为POS和POW-DAG的可扩展性以及他们采用的方法在很大程度上就是前文中可扩展比特币POW算法的自然演化版，我们先从POS说起。</p><h2 id="权益证明POS"><a href="#权益证明POS" class="headerlink" title="权益证明POS"></a>权益证明POS</h2><p>在前文中我们也看到了，可扩展POW的算法基本上都是3-4年前甚至更早的了。原因很简单——在学术界，大多数人都转向了POS。在这里，我们先略过许可与非许可之争以及POW和POS之争，所以我先不去详述POS和POW的优劣（这个我可能最近会单开一篇谈一谈）。但是事实就是，在学术界的非许可链的共识算法这个问题上，大部分更新的算法都选择了POS。</p><p>POS，权益证明，顾名思义，就是相对于POW的“算力越高，挖出快的概率越大”的方法，改成“钱越多，挖出块的概率越大”。然而，相对于一说POW我们就会想到比特币POW不同，POS并不是仅仅指某一种算法，而是这一类用权益作为权重进行出块者选取的方法。</p><p>在这里，我就跳过早期peercoin和NXT的POS，也跳过DPOS以及以太坊Casper，我们只从输出的角度简单地叙述几个比较典型并且有比较严谨的学术论文的，基于随机数的POS：Snow White，Ouroboros，Algorand和Dfinity。</p><p>无论是从可扩展性角度还是实现角度，这几个算法都可以说是可扩展POW的领袖选择思路在POS中的对应。其中，Snow White和Ouroboros相当于Bitcoin-NG的POS对应，而Algorand和Dfinity则是Hybrid Consensus和Byzcoin的对应。</p><p>但是，这里有一个必须要先解释一下的问题——这几个算法的随机数是怎么产生的。</p><p><img src="https://cdn.mytoken.org/51d4d5bc9ae41a37b17c98be4cdeaf88" alt="img"></p><p>恩……果然这一篇解释不完，所以在这篇里，我们姑且认为有这样一个神（随机预言机，Random Oracle）可以每隔一个时间t就提出一个真·随机数，然后，我们可以通过这个随机数和当前账本上每个人拥有的钱数，进行一个带权重的抽签来决定每一轮的出块者……</p><p>细心地朋友已经察觉出问题了——</p><p>我们在比特币中费那么大力气挖矿不就是为了实现这个么？你现在用一个“神”就把我们打发了？</p><p>然而，事实就是这么回事。在我看来，之所以后来学术界纷纷转向POS，实际上就是看到了这个问题：“这个问题不就是我们研究了很久的随机数的东西么，我们完全可以通过密码学解决，为啥要用又费电又费时的POW？”</p><p>于是，实际上上面的每个POS算法，都在某种假设下，从某种程度上实现了这个“神”的功能，因此，我在这里就直接用“神”替代了，而先略过实现的细节。</p><p>有了这个“神”之后，我们实际上就不再有之前的烦恼了，也就是，需要并行共识和传输的烦恼，因为我们可以把几乎所有的带宽*时间用于传输和验证而不担心影响系统的安全性。换言之，我们可以采用最简单的级联结构而把区块设置得尽可能大——例如，10分钟内能够同步多大的区块，就设多大，而不用担心共识的时间不够导致系统安全性下降的问题。</p><p><img src="https://cdn.mytoken.org/5318bb97d5a8a493a4aa40e173a58cc1" alt="img"></p><p>于是，既然我们能够把所有的带宽*时间都用于消息传输了，这些POS的算法和可扩展POW应该是接近的。</p><p>这其中，Snow White和Ouroboros类似Bitcoin-NG，只有一个领袖负责出块。而Algorand和Dfinity则类似Byzcoin和Hybrid Consensus，采用一个负责出块的委员会。两者相较，以输出而论，两者各有千秋。前者在一个更诚实和节点更活跃的网络中表现更好，因为在理想状态，这就是一个大家轮流出块的系统，然而，它在节点不活跃或者恶意的情况下容易出现空时段或者分叉的情况导致带宽的浪费，以及相对而言更高的确认时间。后者由于采用委员会，所以这种情况只有在整个委员会不活跃或者恶意的情况下才会出现，因此出现概率会随着委员会人数的提高而降低。然而，委员会之间的通信，通常采用传统BFT或者可扩展的BFT，所需的时间和消息复杂度会带来更高的延迟，乃至相比于将消息广播到全网而言不可忽略（如果人数太多的话）的通信复杂度。这两者的适用场景会有区别，个人认为，对公链而言，由于所处网络环境的复杂性，后者的输出和延迟更加稳定。</p><h2 id="POW-DAG"><a href="#POW-DAG" class="headerlink" title="POW+DAG"></a><strong>POW+DAG</strong></h2><p>正如前文所说，DAG是GHOST想法的延伸——但是，GHOST和DAG之前还有一个中间步骤：</p><p>在GHOST中，叔块是只计算算力但不考虑里面包含的数据的。于是，如果我们将GHOST的想法继续扩展，我们最终得到的结果是，无论我们如何增加区块大小（或者缩小区块间隔），算力都不会被浪费，于是，我们可以获得比比特币POW更高的输出。然而，这个结果只是保证了算力不被浪费，但是用于传播非主链上的区块的带宽还是被浪费了。举个例子，如果我们将区块大小增加到100MB，于是网络中平均在每个时间段都存在3个合法区块。在比特币POW中，这种情况会导致算力分散和安全性下降。但如果采用了GHOST的模式，这种情况不会发生，但是我们最终需要每10分钟传输300MB的区块，而最终被保留的只有100MB的交易，剩下的部分都被浪费了，这显然不是我们想要的。</p><p>于是，如果我们选择也保留这两个区块，我们才得到了理想的DAG——</p><p>每个矿工只需要1，打包交易；2，尽量同步新区块并且连上；3，挖矿，在挖到之后就把区块发布出去。然后，最终的结果是，无论是你打包的交易，还是你挖矿的算力，最终都会成为共识的一部分。（这里有个坑，我们一会再说）</p><p>我们可以从两个角度来理解DAG：</p><p>第一个角度，从结构上来说，它不再是一条链，而是一个图，但更确切地说，它是一条带子，例如下图：</p><p><img src="https://cdn.mytoken.org/f5a4d90c3cd52f0b2775dc93fbb9ff3a" alt="img"> IOTA（the tangle）的这张图还是很形象的</p><p>这张图可以帮助我们对于区块链中DAG的样子有一个非常直观的认识——因为DAG（有向无环图）只是一个定义，但是它的形态却并不止一种。而从这张图上，我们能看出来区块链中DAG大概长啥样：</p><p>1，首先，它不是一个链，但是，也不是一个无线变大的如同树状的图，它更像一条带子，而带子长度是时间，而宽度我们可以认为是同一段时间同时产生的区块。</p><p>2，于是，宽度实际上代表了这个DAG的输出，当宽度是1个区块的时候，我们实际上获得了区块链。而假设宽度是10个区块，我们相当于把区块链的输出提高了10倍。</p><p>3，与链式结构不同的地方在于，当矿工发布区块的时候，它不需要同步网络中所有的区块，而只需要同步一部分区块就可以了。在这幅图中，是所有在它之前并且直接或间接相连的区块。</p><p>4，于是，在最终，所有的矿工仍旧会对这条带子上的所有交易达成共识，也就是图中浅蓝的部分。这就是我在第一部分中所说的，DAG并不是无限扩展算法，因为它仍旧要求所有矿工对所有节点达成共识。</p><p>5，最终，一个区块被确认的前提是——它大概率不会被分叉，除非有人拥有超过50%算力。</p><p>那么，这个带子的宽度由什么决定呢？</p><p>答案是网络本身的特性（例如网速，拓扑结构）和区块链本身的参数（例如区块大小，间隔等），而后者，在理想状态下应该被设计成正好能够完全利用整个网络的带宽——这是什么概念呢？我们来换个角度：</p><p>假设你是一个矿工，理想的状态是，你一边坐着火车（挖着矿），一边吃着火锅（同步着区块），一边唱着歌（验证着交易），然后矿挖好了发布区块的时候，你正好也把之前你发现的网络中所有的区块同步并且验证完了，而在挖矿期间，你又发现了新的区块正好可以在下一轮挖矿的时候进行同步……</p><p><img src="https://cdn.mytoken.org/c0275be5748c66c1e509a8893394182b" alt="img"></p><p>如果所有矿工都处于理想状态，那么，这个网络中的带宽就被全部利用了。</p><p>然而，如果有矿工常常出现：火车还在开火锅吃完了，那么就说明带宽并没有被很好的利用，于是我们可以增大区块或者缩小区块间隔来提高输出。这种提高输出放在图里的体现，就是更多（更大）的区块会在同一个时间段被创造出来，于是带子变宽了。</p><p>另一个情况是，如果出现大量矿工无法同步所有区块的情况呢？显然，这个时候说明我们需要把输出降低一些。但是，如果我们不降低输出，会发生什么情况呢？</p><p>第一，既然网络的容量是一定的，所以最终得到确认的交易数量肯定不会增加。但问题是，因为新增的区块太多，那么对于矿工而言，就很难对于新增的区块达成一致的共识，最终导致的结果，就是——这条带子会变得越来越宽，而不是越来越长。因此，大部分的DAG需要对于这样的情况加以限制，所以通常DAG会给新挖出的区块以更大的权重，来鼓励这条带子往长而不是往宽的方向发展。同时，这也可以限制恶意节点故意从老区块上建立分叉的行为。</p><p>第二，这样的话，那些不能及时同步所有区块的矿工，会由于无法将他们的区块加在最新的区块上，导致他们的区块不能带来足够高的权重（因为太旧了）而被其他节点放弃。最终，这些区块和算力会被浪费。</p><p>第三，由于网络中节点的网络状况和算力是不均等的，所以必然有的节点会出现火锅没吃完车停了的情况，有的节点会出现车开着火锅吃完了的情况。因此，最终我们会调节区块链的参数，使得整个带子处于一个两者均衡的状态，以期达到最大的输出和浪费最少的算力。</p><p>听起来很好，不是吗？</p><p>DAG似乎只是一个简单的对于链式结构的扩展而已，我们减弱了链式结构中输出和安全性的相关性，最终能够通过调节参数，近似地利用所有的网络容量，达到接近最优的输出。</p><p>看上去，我们在这期间没有牺牲掉任何东西，不是么？</p><p>可惜，答案是否定的。</p><h2 id="DAG中的定序问题"><a href="#DAG中的定序问题" class="headerlink" title="DAG中的定序问题"></a><strong>DAG中的定序问题</strong></h2><p>其实，区块链以及一切BFT算法，除了要对内容（区块）达成共识，也必须对于这些内容的先后顺序达成共识。换句话说，顺序也是共识中不可缺少的一部分。</p><p>在PBFT中，两轮的通信中第一轮就是定序。</p><p>对于比特币POW而言，由于采用链式结构，所以定序和共识是同时进行的——当一个矿工引用了前一个区块的时候，自然而然就表明了这两个区块之间的顺序。</p><p>但在DAG中，虽然所有节点最终对于所有区块会达成共识，同时由于图的有向性，对于一条支链上的所有区块是有共识的，但是，如果两个区块互相之间并不能直接相连，那么两个区块之间的顺序是没有共识的，例如：</p><p><img src="https://cdn.mytoken.org/4576d2d6bc0c0e8afe4194d6d54560e1" alt="img"> 这里，6，7，8之间的顺序就是不定的</p><p>可能有人会问：顺序有这么重要吗？</p><p>答案是：在有些时候，可能没这么重要，这也是为什么IOTA号称“用于IOT”，因为他们自己很清楚IOTA的算法tangle是无法定序的，于是，就无法用于数字货币。</p><p>因为，数字货币需要定序才能决定两笔冲突的交易哪笔合法哪笔非法——</p><p>之前已经提到过，从GHOST到DAG的重要一步是，我们需要把同时产生的多个区块的交易全部纳入共识。这其中不可避免的两个问题是：</p><p>1，重复的交易会降低输出，这个我们一会再说。</p><p>2，冲突的交易，例如一个交易X说A把钱付给了B，一个交易X’说A把钱付给了C，这两个冲突的交易都纳入共识的话，我们必然需要一个一致性的算法来判定哪个是真的，而这就必然涉及到顺序的问题，可是如果所有的节点无法对两者的顺序达成共识，也就无法对于这两笔交易的合法性达成共识。而无法对于合法性达成共识的结果，就代表这两笔交易永远无法得到确认，换句话说就是达不到活性。</p><p>这是一个非常麻烦的问题，目前为止，有两个思路：</p><p><strong>思路一：通过后面区块的拓扑结构来定序</strong></p><p>这是GHOST的小组一直在尝试的方法，从SPECTRE到PHANTOM他们都采用了区块虚拟投票的方法，即，由后面的区块来决定谁先谁后。</p><p>他们设计了一种投票机制，来使投票的结果可以快速收敛到某一边——假设由于出现时间先后或者由于随机的原因，后面连着含有交易X的区块略多于连着含有X’的区块，那么，这个算法会保证结果会随着时间增长越来越压倒性地偏向X，最终迅速地收敛至X。</p><p>但是这个设计的问题在于，没法保证投票的结果一定会偏向向某一边——尤其是恶意节点可以通过很少的算力就去维持两边的平衡。</p><p>SPECTRE对于这个问题的解决方案是：不解决。</p><p>SPECTRE做出了这样一个假设：这是一个虚拟货币，如果X和X’同时出现，那么A一定在短时间内签署了两笔冲突的交易，那么他是恶意节点。于是，我们没必要保证这样的交易的活性。也就是说，如果恶意节点想要一直通过平衡两条差不多重的分支来让别人无法确认两笔交易谁合法的话，那就随它去，反正这是恶意节点的交易。</p><p>而那些诚实节点发出的交易，我们可以保证活性，并且确认任何两笔交易之间的先后顺序。</p><p>但这个假设就造成了SPECTRE的局限性使他无法作为图灵完备的区块链系统的算法，因为在那里面，我们需要全序性。因为智能合约也许需要判定两个不同的人发布的消息的先后。</p><p>于是Phantom和BlockDAG都致力于基于投票来解决这个问题，他们主要的思路是希望能够证明诚实的网络组成的图一定会有某些特性，并且，可以用之前的虚拟投票方法来定序。但一些恶意节点创造出来想要破坏全序性的分支一定不具备这些特性。于是，我们只需要通过某种判别方法筛出那些恶意节点创造出的分支。</p><p>然而，目前他们给出的判别方法还是有问题。而且，从某种角度看，它实际上就是复杂化的第二种思路：</p><p><strong>思路二：确定一条主链</strong></p><p>实际上，如果我们能够确定一条主链，我们就可以很容易地根据主链和一套确定性的规则来对所有区块定序了。</p><p>然而，确定主链并不容易——因为DAG是长这样的：</p><p><img src="https://cdn.mytoken.org/755c3f4f10d139861886e8888f2bb89b" alt="img"></p><p>如果网络均匀分布的话，那么我们大概率得到的是n条几乎差不多长而且匀速增长的链，想要从中确认一条主链，实际上几乎和定序一样难。除非我们能够在算法上进行一些改动，让算法能够更容易收敛出一条主链。但是，在这样的DAG结构中，需要收敛出一条主链就代表着矿工需要优先同步主链，而不能同步的节点就面临算力被浪费的风险。从这个角度讲，在这种DAG结构下，想要追求定序也可以，但是代价是输出的降低。</p><p>在这方面，Prism在这种结构上做出了改进——它从结构上把DAG拆解开，然后用传统的链式结构生成主链，然后用类似DAG的结构进行出块。从一种角度讲，它解决了DAG的定序问题，但是从另一种角度讲，它又很像Bitcoin-NG，唯一的区别就是micro block不再由领袖生成，而是由各个节点生成再用DAG的形式连在主链上……</p><p>而这就为POW-DAG和可扩展POW，建立了一座桥梁。</p><h2 id="DAG的重复交易问题"><a href="#DAG的重复交易问题" class="headerlink" title="DAG的重复交易问题"></a><strong>DAG的重复交易问题</strong></h2><p>DAG中绕不开的另一个问题，是重复交易。尤其是在比特币这种所有矿工共享交易池的系统里，如果每个节点都自行往外捞交易打包的话，那么必然会出现“矿工生成的区块中有大量重复交易”的情况，这就完全失去了我们采用DAG把一条链变成一条带子的意义——诚然，每个时间间隔达成共识的区块从一块变成三块，从100MB变成300MB，但是如果这300MB之中每个交易都被打包了三遍，那区块链的实际输出等于没变，反而需要储存和传输的数据多了三倍。</p><p>于是有人会问：重复率会有这么高么？</p><p>但是实际上，如果沿用比特币现在的交易池结构的话，重复率几乎一定是这么高的，因为所有矿工都用同样的规则从同一个池子里捞交易——而这样的话，其实输出不仅几乎没有提升，反而还要造成储存空间的浪费（因为重复交易也需要被传输和储存才能验证区块是否合法）。</p><p>所以，采用DAG的时候矿工必须同时采用一个不一样的交易选取机制——要么，取消交易池，把每个节点就近或者随机分给一个矿工负责打包交易；要么，矿工需要采用随机的方式从交易池里捞交易。</p><p>但两者其实都只能治标，不能治本——</p><p>前者会造成中心化。换句话说，如果接受你交易的矿工下线或者恶意，又甚至说它单纯地能力不行，都会导致你的交易无法被确认，那么结果就是你还是需要把你的交易广播给更多的矿工，于是再次造成重复交易。</p><p>后者则需要做一个“矿工会诚实地随机从池子里选取交易的假设”，但这个和“理性矿工应该优先选择交易费高的交易”是相悖的。如果严格约束前者，会同时损害矿工和交易者的利益，因为矿工有可能会无法获得最优的交易费，而交易者也无法通过提高交易费来保证自己的交易更快被矿工打包。因此，这招更像是在“交易市场”中采取“计划经济”的手段来强制分配资源。</p><p>但无论如何，重复交易对于DAG输出的影响都是巨大的——即便作为交易者，你只把你的交易多发给一个矿工作为备用方案，都会导致50%的交易重复，即输出下降50%，或者说，千辛万苦提高了的网络使用率，就这样被抹去了50%。</p><p>（大家有没有想起一个人？）</p><p><img src="https://cdn.mytoken.org/2f764c4dc3a249a8fe13f07c87abe953" alt="img"></p><p>IOTA作为最早的DAG之一，自然想过这个问题，所以它取消了区块和矿工的设定，让交易者自行进行POW和上传交易。然而，这种做法不仅带来了更严重的安全隐患，同时引入了另一个导致重复交易的设定——tangle算法里假设诚实节点会努力提高自己的交易被接受的速度，甚至可以继续在自己的交易后面连上空交易来增加自己交易被别人引用的几率，这其实是变相地在鼓励交易者为交易浪费更多的带宽。</p><p>但是，IOTA的有一点思路是没错的——如果在某个场景下，矿工本身不是从池子里捞交易而是自己生成交易并打包上链的话，那么这就不存在重复交易的问题。</p><h2 id="可扩展POW和POW-DAG之间的比较"><a href="#可扩展POW和POW-DAG之间的比较" class="headerlink" title="可扩展POW和POW-DAG之间的比较"></a><strong>可扩展POW和POW-DAG之间的比较</strong></h2><p>实际上，尽管看上去完全不同，在之前的介绍中我们也把这两个说成是两种不同的路线，但两者的输出其实是可以从某种角度比较的——</p><p>比如，以Bitcoin-NG，Hybrid Consensus和Prism为例。</p><p>三者都有类似主链的东西，并且也都支持消息的全序，那么以主链的一个区块为一轮来算的话。</p><p>Bitcoin-NG：领袖负责出块并把消息广播到全网，不能完全地利用带宽进行消息广播（由于只有领袖广播），同时，输出可能会受到恶意领袖的影响。</p><p>Hybrid Consensus：委员会负责出块并把消息广播到全网，可以更好利用带宽（随机选取的委员会成员可以更快将消息广播给全网），但必须要考虑委员会之间采用BFT算法的通信冗余。</p><p>Prism：所有节点自行出块并用DAG最终达成共识，可以最大程度地利用带宽，但必须考虑重复消息的问题。</p><p>我们之前对比了前两者在不同网络状况中的优劣势，但是和DAG对比起来会更加复杂，因为重复消息对于输出的影响极大，却又极大取决于前文所述矿工采取的策略。</p><p>下一篇，我们会介绍一些可扩展BFT的思路。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rw</title>
    <link href="/2024/01/15/rw/"/>
    <url>/2024/01/15/rw/</url>
    
    <content type="html"><![CDATA[<h3 id="evm-中生成读写集研究"><a href="#evm-中生成读写集研究" class="headerlink" title="evm 中生成读写集研究"></a>evm 中生成读写集研究</h3><h3 id="1-找到rust-evm"><a href="#1-找到rust-evm" class="headerlink" title="1.找到rust-evm"></a>1.找到rust-evm</h3><p><a href="https://github.com/rust-ethereum/evm">https://github.com/rust-ethereum/evm</a></p><h3 id="2-挂载slimchain代码"><a href="#2-挂载slimchain代码" class="headerlink" title="2. 挂载slimchain代码"></a>2. 挂载slimchain代码</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run --name slimchain -v <span class="hljs-regexp">/home/yum</span>ohan<span class="hljs-regexp">/gitBox/</span>slimchain:<span class="hljs-regexp">/slimchain -ti teaclave/</span>teaclave-build-ubuntu-<span class="hljs-number">1804</span>-sgx-<span class="hljs-number">2.17</span>.<span class="hljs-number">1</span>:<span class="hljs-number">0.2</span>.<span class="hljs-number">0</span><br><br>make SGX_MODE=SW<br><br>查看运行的容器：docker ps<br>查看所有容器：docker ps -a<br>停止容器：docker stop my_container/ID<br>重新启动容器：docker start my_container<br>进入容器：docker exec -it my_container <span class="hljs-regexp">/bin/</span>bash<br></code></pre></td></tr></table></figure><h3 id="3-读取读写集合"><a href="#3-读取读写集合" class="headerlink" title="3. 读取读写集合"></a>3. 读取读写集合</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TxReadSet</span></span>(<span class="hljs-keyword">pub</span> HashMap&lt;Address, AccountReadSet&gt;);<br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AccountReadSet</span></span> &#123;<br>    <span class="hljs-keyword">pub</span> access_flags: ReadAccessFlags,<br>    <span class="hljs-keyword">pub</span> values: HashSet&lt;StateKey&gt;,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TxReadData</span></span>(<span class="hljs-keyword">pub</span> HashMap&lt;Address, AccountReadData&gt;);<br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AccountReadData</span></span> &#123;<br>    <span class="hljs-keyword">pub</span> nonce: <span class="hljs-built_in">Option</span>&lt;Nonce&gt;,<br>    <span class="hljs-keyword">pub</span> code: <span class="hljs-built_in">Option</span>&lt;Code&gt;,<br>    <span class="hljs-keyword">pub</span> values: HashMap&lt;StateKey, StateValue&gt;,z<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TxWriteData</span></span>(<span class="hljs-keyword">pub</span> BTreeMap&lt;Address, AccountWriteData&gt;);<br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AccountWriteData</span></span> &#123;<br>    <span class="hljs-keyword">pub</span> nonce: <span class="hljs-built_in">Option</span>&lt;Nonce&gt;,<br>    <span class="hljs-keyword">pub</span> code: <span class="hljs-built_in">Option</span>&lt;Code&gt;,<br>    <span class="hljs-keyword">pub</span> values: BTreeMap&lt;StateKey, StateValue&gt;,<br>    <span class="hljs-keyword">pub</span> reset_values: <span class="hljs-built_in">bool</span>,<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><br><br>---------------------------tx_writes---------------------------------<br><br>tx_writes:<span class="hljs-built_in">TxWriteData</span>(&#123;<span class="hljs-built_in">Address</span>(<span class="hljs-number">0</span>x29ed001a09cd53e21e50a027f47b66f8e034534a): AccountWriteData &#123; nonce: <span class="hljs-built_in">Some</span>(<span class="hljs-built_in">Nonce</span>(<span class="hljs-number">2</span>)), code: None, values: &#123;&#125;, reset_values: false &#125;, <span class="hljs-selector-tag">Address</span>(<span class="hljs-number">0</span>x334174c99836bcc7c983b4fa13d702407354f003): AccountWriteData &#123; nonce: None, code: None, values: &#123;<span class="hljs-built_in">StateKey</span>(<span class="hljs-number">0</span>xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7d): <span class="hljs-built_in">StateValue</span>(<span class="hljs-number">0</span>x000000000000000000000000000000000000000000000000000000000000002b)&#125;, reset_values: false &#125;&#125;)<br><br>------------------------------------------------------------<br><br><br>-----------------------------tx_reads-------------------------------<br><br>tx_reads:<span class="hljs-built_in">TxReadSet</span>(&#123;<span class="hljs-built_in">Address</span>(<span class="hljs-number">0</span>x29ed001a09cd53e21e50a027f47b66f8e034534a): AccountReadSet &#123; access_flags: NONCE, values: &#123;&#125; &#125;, <span class="hljs-selector-tag">Address</span>(<span class="hljs-number">0</span>x334174c99836bcc7c983b4fa13d702407354f003): AccountReadSet &#123; access_flags: CODE, values: &#123;<span class="hljs-built_in">StateKey</span>(<span class="hljs-number">0</span>xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7d)&#125; &#125;&#125;)<br><br>------------------------------------------------------------<br></code></pre></td></tr></table></figure><p>tx3_writes:TxWriteData({Address(0x29ed001a09cd53e21e50a027f47b66f8e034534a): AccountWriteData { nonce: Some(Nonce(2)), code: None, values: {}, reset_values: false }, Address(0x334174c99836bcc7c983b4fa13d702407354f003): AccountWriteData { nonce: None, code: None, values: {StateKey(0x4db623e5c4870b62d3fc9b4e8f893a1a77627d75ab45d9ff7e56ba19564af99b): StateValue(0x0000000000000000000000000000000000000000000000000000000000000010), StateKey(0x74a5fbcb419ab7dbacbb2c92a4e163730f0da5c72b911deecf4f05a6b327d0a4): StateValue(0x0000000000000000000000000000000000000000000000000000000000000012), StateKey(0x7dfe757ecd65cbd7922a9c0161e935dd7fdbcc0e999689c7d31633896b1fc60b): StateValue(0x0000000000000000000000000000000000000000000000000000000000000006), StateKey(0x8f331abe73332f95a25873e8b430885974c0409691f89d643119a11623a7924a): StateValue(0x000000000000000000000000000000000000000000000000000000000000000c), StateKey(0xa6eef7e35abe7026729641147f7915573c7e97b47efa546f5f6e3230263bcb49): StateValue(0x0000000000000000000000000000000000000000000000000000000000000000), StateKey(0xcc69885fda6bcc1a4ace058b4a62bf5e179ea78fd58a1ccd71c22cc9b688792f): StateValue(0x0000000000000000000000000000000000000000000000000000000000000002), StateKey(0xd9d16d34ffb15ba3a3d852f0d403e2ce1d691fb54de27ac87cd2f993f3ec330f): StateValue(0x0000000000000000000000000000000000000000000000000000000000000004), StateKey(0xdc686ec4a0ff239c70e7c7c36e8f853eced3bc8618f48d2b816da2a74311237e): StateValue(0x000000000000000000000000000000000000000000000000000000000000000e), StateKey(0xe2689cd4a84e23ad2f564004f1c9013e9589d260bde6380aba3ca7e09e4df40c): StateValue(0x000000000000000000000000000000000000000000000000000000000000000a), StateKey(0xedc95719e9a3b28dd8e80877cb5880a9be7de1a13fc8b05e7999683b6b567643): StateValue(0x0000000000000000000000000000000000000000000000000000000000000008)}, reset_values: false }})</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>forOC</title>
    <link href="/2023/09/10/forOC/"/>
    <url>/2023/09/10/forOC/</url>
    
    <content type="html"><![CDATA[<p>以太坊工具：<a href="https://github.com/Consensys/ethereum-developer-tools-list/tree/master">https://github.com/Consensys/ethereum-developer-tools-list/tree/master</a></p><ol><li>合约编写，编写智能合约，若干个接口，以便于进行外包计算的任务发布、管理和结算。</li></ol><blockquote><p> 工具： truffle</p><p>资料：<a href="https://archive.trufflesuite.com/">https://archive.trufflesuite.com/</a></p></blockquote><ol><li>Enclave 程序编写，将外包计算代码加载到enclave 并运行。</li></ol><blockquote><p>工具：teaclave </p><p>资料：<a href="https://github.com/apache/incubator-teaclave-sgx-sdk">https://github.com/apache/incubator-teaclave-sgx-sdk</a></p></blockquote><ol><li>合约和enclave交互代码，从合约中获取外包任务，enclave计算完成后，将结果返回到合约上</li></ol><blockquote><p>库：ether.rs</p><p>语言： rust</p><p>资料：<a href="https://github.com/gakonst/ethers-rs">https://github.com/gakonst/ethers-rs</a></p></blockquote><ol><li>Enclave内密钥管理，计算的输入和输出如需保持隐私，需要设计enclave中的密钥，以加密输入和输出。</li></ol><blockquote><p>参考论文 ：Ekiden: A Platform for Confidentiality-Preserving, Trustworthy, and Performant Smart Contracts 中的密钥管理部分</p></blockquote><h2 id="truffle-部署智能合约到ganache-cli测试链"><a href="#truffle-部署智能合约到ganache-cli测试链" class="headerlink" title="truffle 部署智能合约到ganache-cli测试链"></a>truffle 部署智能合约到ganache-cli测试链</h2><h5 id="1-安装truffle"><a href="#1-安装truffle" class="headerlink" title="1.安装truffle"></a>1.安装truffle</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo npm <span class="hljs-keyword">install</span> -g truffle<br></code></pre></td></tr></table></figure><h5 id="2-安装ganache-cli"><a href="#2-安装ganache-cli" class="headerlink" title="2.安装ganache-cli"></a>2.安装ganache-cli</h5><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install ganache-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><h5 id="3-开启ganache-cli测试链"><a href="#3-开启ganache-cli测试链" class="headerlink" title="3.开启ganache-cli测试链"></a>3.开启ganache-cli测试链</h5><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c">启动测试链：ganache-cli -d -h localhost:<span class="hljs-number">8545</span> &gt; ganache.<span class="hljs-built_in">log</span> <span class="hljs-meta">&amp;</span><br>ganache-cli -d -h <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8545</span> &gt; ganache.<span class="hljs-built_in">log</span> <span class="hljs-meta">&amp;</span><br>ganache-cli &gt; ganache.<span class="hljs-built_in">log</span> <span class="hljs-meta">&amp;</span><br>查看测试链tail -f ganache.<span class="hljs-built_in">log</span><br>查看端口进程 lsof -i :<span class="hljs-number">8545</span><br>ganache-cli -p <span class="hljs-number">8546</span> &gt; ganache.<span class="hljs-built_in">log</span> <span class="hljs-meta">&amp;</span><br></code></pre></td></tr></table></figure><p><img src="/images/lab_test/image-20230910153212898.png" alt="image-20230910153212898"></p><h5 id="4-初始化truffle项目"><a href="#4-初始化truffle项目" class="headerlink" title="4.初始化truffle项目"></a>4.初始化truffle项目</h5><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">在项目根目录下<br>初始化：truffle init<br>.<br>├── contracts<br>├── migrations<br>├── test<br>└── truffle-<span class="hljs-built_in">config</span>.<span class="hljs-keyword">js</span><br><span class="hljs-keyword"></span><span class="hljs-number">3</span> <span class="hljs-keyword">directories, </span><span class="hljs-number">1</span> file<br></code></pre></td></tr></table></figure><p><img src="/images/lab_test/image-20230910152557622.png" alt="image-20230910152557622"></p><h5 id="5-创建合约"><a href="#5-创建合约" class="headerlink" title="5.创建合约"></a>5.创建合约</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">编写简单智能合约和测试代码<br>在项目根目录下的contracts目录中创建一个新的Solidity合约文件，例如SimpleStorage.sol，并添加以下内容：<br>// SimpleStorage.sol<br>// SPDX-License-Identifier: MIT<br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.17</span>;<br><br>contract SimpleStorage &#123;<br>    uint256 <span class="hljs-built_in">public</span> storedData;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">set</span>(uint256 x) <span class="hljs-built_in">public</span> &#123;<br>        storedData = x;<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">get</span>() <span class="hljs-built_in">public</span> <span class="hljs-keyword">view</span> <span class="hljs-keyword">returns</span> (uint256) &#123;<br>        <span class="hljs-keyword">return</span> storedData;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="6-创建一个合约迁移脚本"><a href="#6-创建一个合约迁移脚本" class="headerlink" title="6.创建一个合约迁移脚本"></a>6.创建一个合约迁移脚本</h5><p>在项目根目录下的<code>migrations</code>目录中创建一个新的迁移脚本，例如<code>2_deploy_simple_storage.js</code>，并添加以下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascriptCopy code<span class="hljs-comment">// 2_deploy_simple_storage.js</span><br><span class="hljs-keyword">const</span> SimpleStorage = artifacts.require(<span class="hljs-string">&quot;SimpleStorage&quot;</span>);<br><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">deployer</span>) </span>&#123;<br>  deployer.deploy(SimpleStorage);<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="7-部署合约到测试链"><a href="#7-部署合约到测试链" class="headerlink" title="7.部署合约到测试链"></a>7.部署合约到测试链</h5><p>（确保测试链处于运行状态，并且truffle-config.js内的网络配置正确连接到测试网）</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">部署：truffle migrate<br>truffle migrate <span class="hljs-comment">--to 2</span><br>truffle migrate <span class="hljs-comment">--reset --f 4 --to 4</span><br><br>truffle migrate <span class="hljs-comment">--f 2 --to 2</span><br>truffle-config.js<br> development: &#123;<br>     host: &quot;127.0.0.1&quot;,     // Localhost (<span class="hljs-keyword">default</span>: <span class="hljs-keyword">none</span>)<br>     port: <span class="hljs-number">8545</span>,            // Standard Ethereum port (<span class="hljs-keyword">default</span>: <span class="hljs-keyword">none</span>)<br>     network_id: &quot;*&quot;,       // <span class="hljs-keyword">Any</span> network (<span class="hljs-keyword">default</span>: <span class="hljs-keyword">none</span>)<br>    &#125;<br>    ../../coordinator/build/SimpleStorage.json<br>        let contract_address = Address::from_str(&quot;0x10fB2Ab116E2Eb3a8B5a1Ca912E05f63c3D969E4&quot;)?;<br>    let contract_abi = include_bytes!(&quot;SimpleStorage.json&quot;);<br></code></pre></td></tr></table></figure><p><img src="/images/lab_test/image-20230910153433034.png" alt="image-20230910153433034"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">查看已部署合约:<br>进入控制台：<span class="hljs-function">truffle console</span><br><span class="hljs-function"><span class="hljs-title">truffle</span>(<span class="hljs-params">development</span>)&gt; <span class="hljs-keyword">let</span> instance</span> = <span class="hljs-keyword">await</span> TexasHoldemPoker.deployed();<br>truffle(development)&gt; instance2.address<br><span class="hljs-keyword">let</span> instance2 = <span class="hljs-keyword">await</span> COORDINATOR.deployed()<br><span class="hljs-keyword">await</span> instance.<span class="hljs-keyword">set</span>(<span class="hljs-number">1234</span>); <span class="hljs-comment">//调用合约</span><br><span class="hljs-keyword">await</span> instance.<span class="hljs-keyword">get</span>();<br></code></pre></td></tr></table></figure><p><img src="/images/lab_test/image-20230912162616416.png" alt="image-20230912162616416"></p><p><img src="/images/lab_test/image-20230915165435356.png" alt="image-20230915165435356"></p><h2 id="rust项目"><a href="#rust项目" class="headerlink" title="rust项目"></a>rust项目</h2><p>1.安装rust <a href="https://rustup.rs/">https://rustup.rs/</a></p><p>参考： <a href="https://course.rs/first-try/installation.html">https://course.rs/first-try/installation.html</a></p><h2 id="rust和ganache-cli测试链交互"><a href="#rust和ganache-cli测试链交互" class="headerlink" title="rust和ganache-cli测试链交互"></a>rust和ganache-cli测试链交互</h2><p>1.添加web3依赖项，Cargo.toml</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">web3</span> = <span class="hljs-string">&quot;0.19&quot;</span><br><span class="hljs-attr">tokio</span> = &#123; version = <span class="hljs-string">&quot;1&quot;</span>, features = [<span class="hljs-string">&quot;full&quot;</span>] &#125;<br></code></pre></td></tr></table></figure><p>2.编写交互代码，main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> web3::transports::Http;<br><span class="hljs-keyword">use</span> web3::Web3;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// 创建一个web3实例，连接到本地的ganache-cli测试链</span><br>    <span class="hljs-keyword">let</span> http = Http::new(<span class="hljs-string">&quot;http://localhost:8545&quot;</span>).unwrap();<br><br>    <span class="hljs-comment">// 创建web3实例</span><br>    <span class="hljs-keyword">let</span> web3 = Web3::new(http);<br><br>    <span class="hljs-comment">// 调用web3.eth().accounts()方法，获取所有账户地址</span><br>    <span class="hljs-keyword">let</span> accounts = web3.eth().accounts().<span class="hljs-keyword">await</span>.unwrap();<br><br>    <span class="hljs-comment">// 打印所有账户地址</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Accounts: &#123;:?&#125;&quot;</span>, accounts);<br>&#125;<br></code></pre></td></tr></table></figure><p>3.运行项目</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">cargo <span class="hljs-built_in">run</span><br></code></pre></td></tr></table></figure><p><img src="/images/lab_test/image-20230910211339344.png" alt="image-20230910211339344"></p><p>检验正确性，初始的虚拟账户为：</p><p><img src="/images/lab_test/image-20230910211714219.png" alt="image-20230910211714219"></p><h2 id="安装Solidity编译器"><a href="#安装Solidity编译器" class="headerlink" title="安装Solidity编译器"></a>安装Solidity编译器</h2><p>资料： <a href="https://solidity-cn.readthedocs.io/zh/develop/installing-solidity.html">https://solidity-cn.readthedocs.io/zh/develop/installing-solidity.html</a></p><h5 id="1-安装solidity版本管理器"><a href="#1-安装solidity版本管理器" class="headerlink" title="1.安装solidity版本管理器"></a>1.安装solidity版本管理器</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">pip</span> install solc-<span class="hljs-literal">select</span><br></code></pre></td></tr></table></figure><h5 id="2-选择版本进行安装-启用-验证"><a href="#2-选择版本进行安装-启用-验证" class="headerlink" title="2.选择版本进行安装/启用/验证"></a>2.选择版本进行安装/启用/验证</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">solc</span>-select install <span class="hljs-number">0</span>.<span class="hljs-number">8</span>.<span class="hljs-number">17</span><br><span class="hljs-attribute">solc</span>-select install <span class="hljs-number">0</span>.<span class="hljs-number">8</span>.<span class="hljs-number">17</span> &amp;&amp; solc-select use <span class="hljs-number">0</span>.<span class="hljs-number">8</span>.<span class="hljs-number">17</span><br><span class="hljs-attribute">solc</span> --version<br></code></pre></td></tr></table></figure><p>3.与合约进行交互</p><p>参考：<a href="https://docs.moonbeam.network/cn/builders/build/eth-api/libraries/ethersrs/">https://docs.moonbeam.network/cn/builders/build/eth-api/libraries/ethersrs/</a></p><h2 id="安装Docker-部署sgx环境"><a href="#安装Docker-部署sgx环境" class="headerlink" title="安装Docker + 部署sgx环境"></a>安装Docker + 部署sgx环境</h2><p><strong>参考资料</strong></p><ol><li><a href="https://teaclave.apache.org/blog/2021-08-25-developing-sgx-application-with-teaclave-sgx-sdk/">使用 TEACLAVE SGX SDK 开发 SGX 应用</a></li><li><a href="https://github.com/dingelish/SGXfail/blob/master/01.md">剖析hello-rust</a></li><li><a href="https://github.com/apache/incubator-teaclave-sgx-sdk">incubator-teaclave-sgx-sdk</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>lab测试</title>
    <link href="/2023/09/10/lab_test/"/>
    <url>/2023/09/10/lab_test/</url>
    
    <content type="html"><![CDATA[<h2 id="truffle-部署智能合约到ganache-cli测试链"><a href="#truffle-部署智能合约到ganache-cli测试链" class="headerlink" title="truffle 部署智能合约到ganache-cli测试链"></a>truffle 部署智能合约到ganache-cli测试链</h2><h5 id="1-安装truffle"><a href="#1-安装truffle" class="headerlink" title="1.安装truffle"></a>1.安装truffle</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo npm <span class="hljs-keyword">install</span> -g truffle<br></code></pre></td></tr></table></figure><h5 id="2-安装ganache-cli"><a href="#2-安装ganache-cli" class="headerlink" title="2.安装ganache-cli"></a>2.安装ganache-cli</h5><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install ganache-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><h5 id="3-开启ganache-cli测试链"><a href="#3-开启ganache-cli测试链" class="headerlink" title="3.开启ganache-cli测试链"></a>3.开启ganache-cli测试链</h5><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c">启动测试链：ganache-cli -d -h localhost:<span class="hljs-number">8545</span> &gt; ganache.<span class="hljs-built_in">log</span> <span class="hljs-meta">&amp;</span><br>ganache-cli -d -h <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8545</span> &gt; ganache.<span class="hljs-built_in">log</span> <span class="hljs-meta">&amp;</span><br>ganache-cli &gt; ganache.<span class="hljs-built_in">log</span> <span class="hljs-meta">&amp;</span><br>查看测试链tail -f ganache.<span class="hljs-built_in">log</span><br>查看端口进程 lsof -i :<span class="hljs-number">8545</span><br>ganache-cli -p <span class="hljs-number">8546</span> &gt; ganache.<span class="hljs-built_in">log</span> <span class="hljs-meta">&amp;</span><br></code></pre></td></tr></table></figure><p><img src="/images/lab_test/image-20230910153212898.png" alt="image-20230910153212898"></p><h5 id="4-初始化truffle项目"><a href="#4-初始化truffle项目" class="headerlink" title="4.初始化truffle项目"></a>4.初始化truffle项目</h5><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">在项目根目录下<br>初始化：truffle init<br>.<br>├── contracts<br>├── migrations<br>├── test<br>└── truffle-<span class="hljs-built_in">config</span>.<span class="hljs-keyword">js</span><br><span class="hljs-keyword"></span><span class="hljs-number">3</span> <span class="hljs-keyword">directories, </span><span class="hljs-number">1</span> file<br></code></pre></td></tr></table></figure><p><img src="/images/lab_test/image-20230910152557622.png" alt="image-20230910152557622"></p><h5 id="5-创建合约"><a href="#5-创建合约" class="headerlink" title="5.创建合约"></a>5.创建合约</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">编写简单智能合约和测试代码<br>在项目根目录下的contracts目录中创建一个新的Solidity合约文件，例如SimpleStorage.sol，并添加以下内容：<br>// SimpleStorage.sol<br>// SPDX-License-Identifier: MIT<br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.17</span>;<br><br>contract SimpleStorage &#123;<br>    uint256 <span class="hljs-built_in">public</span> storedData;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">set</span>(uint256 x) <span class="hljs-built_in">public</span> &#123;<br>        storedData = x;<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">get</span>() <span class="hljs-built_in">public</span> <span class="hljs-keyword">view</span> <span class="hljs-keyword">returns</span> (uint256) &#123;<br>        <span class="hljs-keyword">return</span> storedData;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="6-创建一个合约迁移脚本"><a href="#6-创建一个合约迁移脚本" class="headerlink" title="6.创建一个合约迁移脚本"></a>6.创建一个合约迁移脚本</h5><p>在项目根目录下的<code>migrations</code>目录中创建一个新的迁移脚本，例如<code>2_deploy_simple_storage.js</code>，并添加以下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascriptCopy code<span class="hljs-comment">// 2_deploy_simple_storage.js</span><br><span class="hljs-keyword">const</span> SimpleStorage = artifacts.require(<span class="hljs-string">&quot;SimpleStorage&quot;</span>);<br><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">deployer</span>) </span>&#123;<br>  deployer.deploy(SimpleStorage);<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="7-部署合约到测试链"><a href="#7-部署合约到测试链" class="headerlink" title="7.部署合约到测试链"></a>7.部署合约到测试链</h5><p>（确保测试链处于运行状态，并且truffle-config.js内的网络配置正确连接到测试网）</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">部署：truffle migrate<br>truffle migrate <span class="hljs-comment">--to 2</span><br>truffle migrate <span class="hljs-comment">--reset --f 4 --to 4</span><br><br>truffle migrate <span class="hljs-comment">--f 2 --to 2</span><br>truffle-config.js<br> development: &#123;<br>     host: &quot;127.0.0.1&quot;,     // Localhost (<span class="hljs-keyword">default</span>: <span class="hljs-keyword">none</span>)<br>     port: <span class="hljs-number">8545</span>,            // Standard Ethereum port (<span class="hljs-keyword">default</span>: <span class="hljs-keyword">none</span>)<br>     network_id: &quot;*&quot;,       // <span class="hljs-keyword">Any</span> network (<span class="hljs-keyword">default</span>: <span class="hljs-keyword">none</span>)<br>    &#125;<br>    ../../coordinator/build/SimpleStorage.json<br>        let contract_address = Address::from_str(&quot;0x10fB2Ab116E2Eb3a8B5a1Ca912E05f63c3D969E4&quot;)?;<br>    let contract_abi = include_bytes!(&quot;SimpleStorage.json&quot;);<br></code></pre></td></tr></table></figure><p><img src="/images/lab_test/image-20230910153433034.png" alt="image-20230910153433034"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">查看已部署合约:<br>进入控制台：<span class="hljs-function">truffle console</span><br><span class="hljs-function"><span class="hljs-title">truffle</span>(<span class="hljs-params">development</span>)&gt; <span class="hljs-keyword">let</span> instance</span> = <span class="hljs-keyword">await</span> TexasHoldemPoker.deployed();<br>truffle(development)&gt; instance2.address<br><span class="hljs-keyword">let</span> instance2 = <span class="hljs-keyword">await</span> COORDINATOR.deployed()<br><span class="hljs-keyword">await</span> instance.<span class="hljs-keyword">set</span>(<span class="hljs-number">1234</span>); <span class="hljs-comment">//调用合约</span><br><span class="hljs-keyword">await</span> instance.<span class="hljs-keyword">get</span>();<br></code></pre></td></tr></table></figure><p><img src="/images/lab_test/image-20230912162616416.png" alt="image-20230912162616416"></p><p><img src="/images/lab_test/image-20230915165435356.png" alt="image-20230915165435356"></p><h5 id="8-编写性能测试脚本"><a href="#8-编写性能测试脚本" class="headerlink" title="8.编写性能测试脚本"></a>8.编写性能测试脚本</h5><p>在项目根目录中创建一个新的JavaScript文件，例如<code>performance_test.js</code>，并添加以下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascriptCopy code<span class="hljs-comment">// performance_test.js</span><br><span class="hljs-keyword">const</span> SimpleStorage = artifacts.require(<span class="hljs-string">&quot;SimpleStorage&quot;</span>);<br><br>contract(<span class="hljs-string">&quot;SimpleStorage&quot;</span>, <span class="hljs-keyword">async</span> (accounts) =&gt; &#123;<br>  <span class="hljs-keyword">let</span> simpleStorageInstance;<br><br>  before(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>    simpleStorageInstance = <span class="hljs-keyword">await</span> SimpleStorage.deployed();<br>  &#125;);<br><br>  it(<span class="hljs-string">&quot;should measure throughput and latency&quot;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-comment">// Measure throughput</span><br>    <span class="hljs-keyword">const</span> startTimestamp = <span class="hljs-built_in">Date</span>.now();<br>    <span class="hljs-keyword">const</span> numberOfTransactions = <span class="hljs-number">100</span>; <span class="hljs-comment">// Change this to the desired number of transactions</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numberOfTransactions; i++) &#123;<br>      <span class="hljs-keyword">await</span> simpleStorageInstance.set(i, &#123; <span class="hljs-attr">from</span>: accounts[<span class="hljs-number">0</span>] &#125;);<br>    &#125;<br>    <span class="hljs-keyword">const</span> endTimestamp = <span class="hljs-built_in">Date</span>.now();<br>    <span class="hljs-keyword">const</span> elapsedSeconds = (endTimestamp - startTimestamp) / <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">const</span> throughput = numberOfTransactions / elapsedSeconds;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Throughput: <span class="hljs-subst">$&#123;throughput&#125;</span> transactions per second`</span>);<br><br>    <span class="hljs-comment">// Measure latency</span><br>    <span class="hljs-keyword">const</span> latencyStartTimestamp = <span class="hljs-built_in">Date</span>.now();<br>    <span class="hljs-keyword">await</span> simpleStorageInstance.set(numberOfTransactions, &#123; <span class="hljs-attr">from</span>: accounts[<span class="hljs-number">0</span>] &#125;);<br>    <span class="hljs-keyword">const</span> latencyEndTimestamp = <span class="hljs-built_in">Date</span>.now();<br>    <span class="hljs-keyword">const</span> latency = latencyEndTimestamp - latencyStartTimestamp;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Latency: <span class="hljs-subst">$&#123;latency&#125;</span> milliseconds`</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="9-运行性能测试"><a href="#9-运行性能测试" class="headerlink" title="9.运行性能测试"></a>9.运行性能测试</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">truffle <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p><img src="/images/lab_test/image-20230910153630153.png" alt="image-20230910153630153"></p><h5 id="10-此过程中ganache-log持续写入日志"><a href="#10-此过程中ganache-log持续写入日志" class="headerlink" title="10.此过程中ganache.log持续写入日志"></a>10.此过程中ganache.log持续写入日志</h5><p><img src="/images/lab_test/image-20230910153711193.png" alt="image-20230910153711193"></p><h5 id="11-用ethers-js与合约交互"><a href="#11-用ethers-js与合约交互" class="headerlink" title="11.用ethers.js与合约交互"></a>11.用ethers.js与合约交互</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs javascript">安装npm install truffle-assertions<br>安装 npm install ethers<br><br>编写交互代码：testagain.js <br><span class="hljs-keyword">const</span> &#123;ethers&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;ethers&quot;</span>)<br><br><br><span class="hljs-keyword">let</span> provider = <span class="hljs-keyword">new</span> ethers.JsonRpcProvider(<span class="hljs-string">&#x27;http://localhost:8545&#x27;</span>)<br><br><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-comment">// 读取 JSON 文件</span><br><span class="hljs-keyword">const</span> rawdata = fs.readFileSync(<span class="hljs-string">&#x27;./build/contracts/SimpleStorage.json&#x27;</span>);<br><span class="hljs-keyword">const</span> contractData = <span class="hljs-built_in">JSON</span>.parse(rawdata);<br><br><span class="hljs-comment">// 提取 ABI</span><br><span class="hljs-keyword">const</span> abi = contractData.abi;<br><span class="hljs-comment">// 地址来自上面部署的合约</span><br><span class="hljs-keyword">let</span> contractAddress = <span class="hljs-string">&quot;0xC4bC1f775dB36c07b0bC506cbB83fCe12E182053&quot;</span>;<br><br><span class="hljs-comment">// 使用Provider 连接合约，将只有对合约的可读权限</span><br><span class="hljs-keyword">let</span> contract = <span class="hljs-keyword">new</span> ethers.Contract(contractAddress, abi, provider);<br><br>(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">let</span> currentValue = <span class="hljs-keyword">await</span> contract.get();<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> currentValue)<br><span class="hljs-built_in">console</span>.log(currentValue);<br><br><br><span class="hljs-comment">// 从私钥获取一个签名器 Signer</span><br><span class="hljs-keyword">let</span> privateKey = <span class="hljs-string">&#x27;0x6cbed15c793ce57650b9877cf6fa156fbef513c4e6134f022a85b1ffdd59b2a1&#x27;</span>;<br><span class="hljs-keyword">let</span> wallet = <span class="hljs-keyword">new</span> ethers.Wallet(privateKey, provider);<br><br><span class="hljs-comment">// 使用签名器创建一个新的合约实例，它允许使用可更新状态的方法</span><br><span class="hljs-keyword">let</span> contractWithSigner = contract.connect(wallet);<br><span class="hljs-comment">// ... 或 ...</span><br><span class="hljs-comment">// let contractWithSigner = new Contract(contractAddress, abi, wallet)</span><br><br><span class="hljs-comment">// 设置一个新值，返回交易</span><br><span class="hljs-keyword">let</span> tx = <span class="hljs-keyword">await</span> contractWithSigner.set(<span class="hljs-number">1111</span>);<br><br><span class="hljs-comment">// 查看: https://ropsten.etherscan.io/tx/0xaf0068dcf728afa5accd02172867627da4e6f946dfb8174a7be31f01b11d5364</span><br><span class="hljs-built_in">console</span>.log(tx.hash);<br><span class="hljs-comment">// &quot;0xaf0068dcf728afa5accd02172867627da4e6f946dfb8174a7be31f01b11d5364&quot;</span><br><br><span class="hljs-comment">// 操作还没完成，需要等待挖矿</span><br><span class="hljs-keyword">await</span> tx.wait();<br><br><span class="hljs-comment">// 再次调用合约的 getValue()</span><br><span class="hljs-keyword">let</span> newValue = <span class="hljs-keyword">await</span> contract.get();<br><br><span class="hljs-built_in">console</span>.log(currentValue);<br>&#125;)();<br><br><br><br><br></code></pre></td></tr></table></figure><p><img src="/images/lab_test/image-20230915190419636.png" alt="image-20230915190419636"></p><p>ethers-contract</p><p><a href="https://docs.rs/ethers-contract/0.2.2/ethers_contract/struct.Contract.html">https://docs.rs/ethers-contract/0.2.2/ethers_contract/struct.Contract.html</a></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs rust">Example<br>Assuming we already have our contract deployed at address, we’ll proceed to interact with its methods and retrieve raw logs it has emitted.<br><br><span class="hljs-keyword">use</span> ethers::&#123;<br>    abi::Abi,<br>    utils::Solc,<br>    types::&#123;Address, H256&#125;,<br>    contract::Contract,<br>    providers::&#123;Provider, Http&#125;,<br>    signers::Wallet,<br>&#125;;<br><span class="hljs-keyword">use</span> std::convert::TryFrom;<br><br><span class="hljs-comment">// this is a fake address used just for this example</span><br><span class="hljs-keyword">let</span> address = <span class="hljs-string">&quot;eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee&quot;</span>.parse::&lt;Address&gt;()?;<br><br><span class="hljs-comment">// (ugly way to write the ABI inline, you can otherwise read it from a file)</span><br><span class="hljs-keyword">let</span> abi: Abi = serde_json::from_str(<span class="hljs-string">r#&quot;[&#123;&quot;inputs&quot;:[&#123;&quot;internalType&quot;:&quot;string&quot;,&quot;name&quot;:&quot;value&quot;,&quot;type&quot;:&quot;string&quot;&#125;],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;constructor&quot;&#125;,&#123;&quot;anonymous&quot;:false,&quot;inputs&quot;:[&#123;&quot;indexed&quot;:true,&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;author&quot;,&quot;type&quot;:&quot;address&quot;&#125;,&#123;&quot;indexed&quot;:true,&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;oldAuthor&quot;,&quot;type&quot;:&quot;address&quot;&#125;,&#123;&quot;indexed&quot;:false,&quot;internalType&quot;:&quot;string&quot;,&quot;name&quot;:&quot;oldValue&quot;,&quot;type&quot;:&quot;string&quot;&#125;,&#123;&quot;indexed&quot;:false,&quot;internalType&quot;:&quot;string&quot;,&quot;name&quot;:&quot;newValue&quot;,&quot;type&quot;:&quot;string&quot;&#125;],&quot;name&quot;:&quot;ValueChanged&quot;,&quot;type&quot;:&quot;event&quot;&#125;,&#123;&quot;inputs&quot;:[],&quot;name&quot;:&quot;getValue&quot;,&quot;outputs&quot;:[&#123;&quot;internalType&quot;:&quot;string&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;string&quot;&#125;],&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;inputs&quot;:[],&quot;name&quot;:&quot;lastSender&quot;,&quot;outputs&quot;:[&#123;&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;address&quot;&#125;],&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;inputs&quot;:[&#123;&quot;internalType&quot;:&quot;string&quot;,&quot;name&quot;:&quot;value&quot;,&quot;type&quot;:&quot;string&quot;&#125;],&quot;name&quot;:&quot;setValue&quot;,&quot;outputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;&#125;]&quot;#</span>)?;<br><br><span class="hljs-comment">// connect to the network</span><br><span class="hljs-keyword">let</span> client = Provider::&lt;Http&gt;::try_from(<span class="hljs-string">&quot;http://localhost:8545&quot;</span>).unwrap();<br><br><span class="hljs-comment">// create the contract object at the address</span><br><span class="hljs-keyword">let</span> contract = Contract::new(address, abi, client);<br><br><span class="hljs-comment">// Calling constant methods is done by calling `call()` on the method builder.</span><br><span class="hljs-comment">// (if the function takes no arguments, then you must use `()` as the argument)</span><br><span class="hljs-keyword">let</span> init_value: <span class="hljs-built_in">String</span> = contract<br>    .method::&lt;_, <span class="hljs-built_in">String</span>&gt;(<span class="hljs-string">&quot;getValue&quot;</span>, ())?<br>    .call()<br>    .<span class="hljs-keyword">await</span>?;<br><br><span class="hljs-comment">// Non-constant methods are executed via the `send()` call on the method builder.</span><br><span class="hljs-keyword">let</span> call = contract<br>    .method::&lt;_, H256&gt;(<span class="hljs-string">&quot;setValue&quot;</span>, <span class="hljs-string">&quot;hi&quot;</span>.to_owned())?;<br><span class="hljs-keyword">let</span> pending_tx = call.send().<span class="hljs-keyword">await</span>?;<br><br><span class="hljs-comment">// `await`ing on the pending transaction resolves to a transaction receipt</span><br><span class="hljs-keyword">let</span> receipt = pending_tx.confirmations(<span class="hljs-number">6</span>).<span class="hljs-keyword">await</span>?;<br></code></pre></td></tr></table></figure><h2 id="rust项目"><a href="#rust项目" class="headerlink" title="rust项目"></a>rust项目</h2><p>1.安装rust <a href="https://rustup.rs/">https://rustup.rs/</a></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vim">curl --proto <span class="hljs-string">&#x27;=https&#x27;</span> --tlsv1.<span class="hljs-number">2</span> -sSf http<span class="hljs-variable">s:</span>//<span class="hljs-keyword">sh</span>.rustup.rs | <span class="hljs-keyword">sh</span><br>查看版本:rustc --<span class="hljs-keyword">version</span><br>初始化：cargo <span class="hljs-keyword">new</span> greeting<br>(posenv) yumohan@unislab-PowerEdge-T640:~/lab/greeting$ tree<br>.<br>├── Cargo.toml<br>└── src<br>    └── main.rs<br><br><span class="hljs-number">1</span> directory, <span class="hljs-number">2</span> <span class="hljs-keyword">files</span><br></code></pre></td></tr></table></figure><p><img src="/images/lab_test/image-20230910160309955.png" alt="image-20230910160309955"></p><p>2.编译项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo build<br>(posenv) yumohan@unislab-PowerEdge-T640:~/lab/greeting$ cargo build<br>   Compiling greeting v0.1.0 (/home/yumohan/lab/greeting)<br>    Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 0.25s<br>(posenv) yumohan@unislab-PowerEdge-T640:~/lab/greeting$ tree<br>.<br>├── Cargo.lock<br>├── Cargo.toml<br>├── src<br>│   └── main.rs<br>└── target<br>    ├── CACHEDIR.TAG<br>    └── debug<br>        ├── build<br>        ├── deps<br>        │   ├── greeting-306597fb1dc386c3<br>        │   └── greeting-306597fb1dc386c3.d<br>        ├── examples<br>        ├── greeting<br>        ├── greeting.d<br>        └── incremental<br>            └── greeting-2cxp7rwau06rz<br>                ├── s-gol9waps7s-18m1yne-a56391dvjman4qstop600xauy<br>                │   ├── 10hnn8nme6zzql0t.o<br>                │   ├── 1df718tgtyout27y.o<br>                │   ├── 2ptuowrc0zov12hh.o<br>                │   ├── 3i7h3lai9swm4afu.o<br>                │   ├── 3om4n0vc34r1o3ww.o<br>                │   ├── 43iba3rcptwn7z5c.o<br>                │   ├── dep-graph.bin<br>                │   ├── query-cache.bin<br>                │   └── work-products.bin<br>                └── s-gol9waps7s-18m1yne.lock<br><br>9 directories, 18 files<br></code></pre></td></tr></table></figure><p><img src="/images/lab_test/image-20230910160626788.png" alt="image-20230910160626788"></p><p>3.运行项目</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">cargo <span class="hljs-built_in">run</span><br></code></pre></td></tr></table></figure><p><img src="/images/lab_test/image-20230910160746443.png" alt="image-20230910160746443"></p><p><img src="/images/lab_test/image-20230910160827758.png" alt="image-20230910160827758"></p><h2 id="rust和ganache-cli测试链交互"><a href="#rust和ganache-cli测试链交互" class="headerlink" title="rust和ganache-cli测试链交互"></a>rust和ganache-cli测试链交互</h2><p>1.添加web3依赖项，Cargo.toml</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">web3</span> = <span class="hljs-string">&quot;0.19&quot;</span><br><span class="hljs-attr">tokio</span> = &#123; version = <span class="hljs-string">&quot;1&quot;</span>, features = [<span class="hljs-string">&quot;full&quot;</span>] &#125;<br></code></pre></td></tr></table></figure><p>2.编写交互代码，main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> web3::transports::Http;<br><span class="hljs-keyword">use</span> web3::Web3;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// 创建一个web3实例，连接到本地的ganache-cli测试链</span><br>    <span class="hljs-keyword">let</span> http = Http::new(<span class="hljs-string">&quot;http://localhost:8545&quot;</span>).unwrap();<br><br>    <span class="hljs-comment">// 创建web3实例</span><br>    <span class="hljs-keyword">let</span> web3 = Web3::new(http);<br><br>    <span class="hljs-comment">// 调用web3.eth().accounts()方法，获取所有账户地址</span><br>    <span class="hljs-keyword">let</span> accounts = web3.eth().accounts().<span class="hljs-keyword">await</span>.unwrap();<br><br>    <span class="hljs-comment">// 打印所有账户地址</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Accounts: &#123;:?&#125;&quot;</span>, accounts);<br>&#125;<br></code></pre></td></tr></table></figure><p>3.运行项目</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">cargo <span class="hljs-built_in">run</span><br></code></pre></td></tr></table></figure><p><img src="/images/lab_test/image-20230910211339344.png" alt="image-20230910211339344"></p><p>检验正确性，初始的虚拟账户为：</p><p><img src="/images/lab_test/image-20230910211714219.png" alt="image-20230910211714219"></p><h2 id="安装Solidity编译器"><a href="#安装Solidity编译器" class="headerlink" title="安装Solidity编译器"></a>安装Solidity编译器</h2><p>资料： <a href="https://solidity-cn.readthedocs.io/zh/develop/installing-solidity.html">https://solidity-cn.readthedocs.io/zh/develop/installing-solidity.html</a></p><h5 id="1-安装solidity版本管理器"><a href="#1-安装solidity版本管理器" class="headerlink" title="1.安装solidity版本管理器"></a>1.安装solidity版本管理器</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">pip</span> install solc-<span class="hljs-literal">select</span><br></code></pre></td></tr></table></figure><p><img src="/images/lab_test/image-20230913143429967.png" alt="image-20230913143429967"></p><h5 id="2-选择版本进行安装-启用-验证"><a href="#2-选择版本进行安装-启用-验证" class="headerlink" title="2.选择版本进行安装/启用/验证"></a>2.选择版本进行安装/启用/验证</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">solc</span>-select install <span class="hljs-number">0</span>.<span class="hljs-number">8</span>.<span class="hljs-number">17</span><br><span class="hljs-attribute">solc</span>-select install <span class="hljs-number">0</span>.<span class="hljs-number">8</span>.<span class="hljs-number">17</span> &amp;&amp; solc-select use <span class="hljs-number">0</span>.<span class="hljs-number">8</span>.<span class="hljs-number">17</span><br><span class="hljs-attribute">solc</span> --version<br></code></pre></td></tr></table></figure><p><img src="/images/lab_test/image-20230913143547150.png" alt="image-20230913143547150"></p><p><img src="/images/lab_test/image-20230913143355543.png" alt="image-20230913143355543"></p><p>3.与合约进行交互</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><code class="hljs rust">用ethers.js与合约交互 <br><br>main.rs<br><br><span class="hljs-keyword">use</span> std::env;<br><br><span class="hljs-keyword">use</span> std::time::&#123;SystemTime&#125;;<br><br><span class="hljs-keyword">use</span> std::time::Duration;<br><br><span class="hljs-keyword">use</span> std::thread::sleep;<br><br><br><br><span class="hljs-keyword">use</span> ethers_signers::&#123;LocalWallet&#125;;<br><br><span class="hljs-keyword">use</span> ethers_core::types::transaction::eip2930::&#123;AccessList,AccessListItem&#125;;<br><br><span class="hljs-keyword">use</span> ethers_providers::&#123;Provider&#125;;<br><br><span class="hljs-keyword">use</span> ethers_core::types::&#123;Address&#125;;<br><br><span class="hljs-keyword">use</span> ethers_middleware::SignerMiddleware;<br><br><span class="hljs-keyword">use</span> std::sync::Arc;<br><br><br><br><span class="hljs-keyword">use</span> ethers::&#123;<br><br>  prelude::*,<br><br>&#125;;<br><br><br><br><span class="hljs-keyword">use</span> eyre::<span class="hljs-built_in">Result</span>;<br><br><span class="hljs-keyword">const</span> RPC_URL: &amp;<span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;http://localhost:8545&quot;</span>;<br><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">print_balances</span></span>(provider: &amp;Provider&lt;Http&gt;, address_from: Address, address_to: Address) -&gt; <span class="hljs-built_in">Result</span>&lt;(), <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> std::error::Error&gt;&gt; &#123;<br><br>  <span class="hljs-comment">// 2. Use the get_balance function</span><br><br>  <span class="hljs-keyword">let</span> balance_from = provider.get_balance(address_from, <span class="hljs-literal">None</span>).<span class="hljs-keyword">await</span>?;<br><br>  <span class="hljs-keyword">let</span> balance_to = provider.get_balance(address_to, <span class="hljs-literal">None</span>).<span class="hljs-keyword">await</span>?;<br><br><br><br>  <span class="hljs-comment">// 3. Print the resultant balance</span><br><br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; has &#123;&#125;&quot;</span>, address_from, balance_from);<br><br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; has &#123;&#125;&quot;</span>, address_to, balance_to);<br><br><br><br>  <span class="hljs-literal">Ok</span>(())<br><br>&#125;<br><br><br><br><br><br><span class="hljs-comment">//解析abi</span><br><br>  abigen!(SimpleStorage, <span class="hljs-string">&quot;./SimpleStorageABI.json&quot;</span>);<br><br><br><br>\<span class="hljs-meta">#[tokio::main]</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; <span class="hljs-built_in">Result</span>&lt;(), <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> std::error::Error&gt;&gt; &#123;<br><br><br><br>  <span class="hljs-comment">//创建provider连接区块链,用try_from</span><br><br>  <span class="hljs-keyword">let</span> provider = Provider::&lt;Http&gt;::try_from(RPC_URL)?;<br><br>  <span class="hljs-comment">//查询区块数量</span><br><br>  <span class="hljs-keyword">let</span> block_number: U64 = provider.get_block_number().<span class="hljs-keyword">await</span>?;<br><br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;block_number&#125;&quot;</span>);<br><br>  <br><br><br><br>  <span class="hljs-comment">//用私钥创建钱包</span><br><br>  <span class="hljs-keyword">let</span> wallet: LocalWallet = <span class="hljs-string">&quot;4f3edf983ac636a65a842ce7c78d9aa706d3b113bce9c46f30d7d21715b23b1d&quot;</span><br><br>​    .parse::&lt;LocalWallet&gt;()?<br><br>​    .with_chain_id(Chain::MoonbeamDev);<br><br><br><br>  <span class="hljs-comment">//将provider和钱包一起包装成一个client</span><br><br>  <span class="hljs-keyword">let</span> client = SignerMiddleware::new(provider.clone(), wallet.clone());<br><br><br><br>  <span class="hljs-comment">//确定转账的对方</span><br><br>  <span class="hljs-keyword">let</span> address_from = <span class="hljs-string">&quot;0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1&quot;</span>.parse::&lt;Address&gt;()?;<br><br>  <span class="hljs-keyword">let</span> address_to = <span class="hljs-string">&quot;0xFFcf8FDEE72ac11b5c542428B35EEF5769C409f0&quot;</span>.parse::&lt;Address&gt;()?;<br><br><br><br>  <span class="hljs-comment">//调用函数查询余额</span><br><br>  print_balances(&amp;provider,address_from,address_to).<span class="hljs-keyword">await</span>?;<br><br><br><br>  <span class="hljs-comment">//调用读取合约数据函数</span><br><br>  <span class="hljs-keyword">let</span> contract_addr = <span class="hljs-string">&quot;0xC4bC1f775dB36c07b0bC506cbB83fCe12E182053&quot;</span>.parse::&lt;Address&gt;()?;<br><br>  <span class="hljs-keyword">let</span> client_arc = Arc::new(client.clone());<br><br>  <span class="hljs-keyword">let</span> simple_storage_instance = SimpleStorage::new(contract_addr, Arc::clone(&amp;client_arc)); <br><br>  <span class="hljs-comment">//Contracts Rust Ethers credit: https://docs.rs/ethers-contract/0.2.2/ethers_contract/struct.Contract.html</span><br><br><br><br>  <span class="hljs-keyword">let</span> stored_data_value = simple_storage_instance.get().call().<span class="hljs-keyword">await</span>?;<br><br>  <br><br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;storedDataValue before transaction: &#123;0&#125;&quot;</span>, stored_data_value);<br><br><br><br>  <span class="hljs-comment">// send_set_tx(simple_storage_instance.clone()).await.expect(&quot;Transaction function error&quot;); //Clone the value to avoid Rust borrow checker error.</span><br><br>  <span class="hljs-literal">Ok</span>(())<br><br><br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><img src="/images/lab_test/image-20230915190627452.png" alt="image-20230915190627452"></p><h2 id="安装Docker-部署sgx环境"><a href="#安装Docker-部署sgx环境" class="headerlink" title="安装Docker + 部署sgx环境"></a>安装Docker + 部署sgx环境</h2><h5 id="1-安装Docker"><a href="#1-安装Docker" class="headerlink" title="1.安装Docker"></a>1.安装Docker</h5><p>参考：<a href="https://docs.docker.com/engine/install/ubuntu/">https://docs.docker.com/engine/install/ubuntu/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin<br>(posenv) yumohan@unislab-PowerEdge-T640:~/lab$ sudo docker run hello-world<br><br>Hello from Docker!<br>This message shows that your installation appears to be working correctly.<br><br>To generate this message, Docker took the following steps:<br><br>  1. The Docker client contacted the Docker daemon.<br>  2. The Docker daemon pulled the <span class="hljs-string">&quot;hello-world&quot;</span> image from the Docker Hub.<br>     (amd64)<br>  3. The Docker daemon created a new container from that image <span class="hljs-built_in">which</span> runs the<br>     executable that produces the output you are currently reading.<br>  4. The Docker daemon streamed that output to the Docker client, <span class="hljs-built_in">which</span> sent it<br>     to your terminal.<br><br>To try something more ambitious, you can run an Ubuntu container with:<br> $ docker run -it ubuntu bash<br><br>Share images, automate workflows, and more with a free Docker ID:<br> https://hub.docker.com/<br><br>For more examples and ideas, visit:<br> https://docs.docker.com/get-started/<br></code></pre></td></tr></table></figure><h5 id="2-安装-docker-compose"><a href="#2-安装-docker-compose" class="headerlink" title="2.安装 docker-compose"></a>2.安装 docker-compose</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo curl -L <span class="hljs-string">&quot;https://github.com/docker/compose/releases/download/1.27.4/docker-compose-$(uname -s)-$(uname -m)&quot;</span> -o <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>docker-compose<br></code></pre></td></tr></table></figure><h5 id="3-拉取teaclave仓库和docker镜像"><a href="#3-拉取teaclave仓库和docker镜像" class="headerlink" title="3.拉取teaclave仓库和docker镜像"></a>3.拉取teaclave仓库和docker镜像</h5><p><strong>参考资料</strong></p><ol><li><a href="https://teaclave.apache.org/blog/2021-08-25-developing-sgx-application-with-teaclave-sgx-sdk/">使用 TEACLAVE SGX SDK 开发 SGX 应用</a></li><li><a href="https://github.com/dingelish/SGXfail/blob/master/01.md">剖析hello-rust</a></li><li><a href="https://github.com/apache/incubator-teaclave-sgx-sdk">incubator-teaclave-sgx-sdk</a></li><li><a href="https://teaclave.apache.org/docs/my-first-function/#simulation-mode"> Simulation Mode</a></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/apache/incubator-teaclave-sgx-sdk.git<br>$ docker pull teaclave/teaclave-build-ubuntu-1804-sgx-2.9.1:latest<br><br>将sdk仓库挂载到容器中的root/sgx/目录下，并启动拉取到的镜像<br>$ docker run -v /path/to/rust-sgx（你下载的sgx仓库的绝对路径）:/root/sgx -ti teaclave/teaclave-build-ubuntu-1804-sgx-2.9.1:latest<br><br>docker run --name pet --net host -v /home/yumohan/lab/incubator-teaclave-sgx-sdk:/root/sgx -p 8080:50051 -ti teaclave/teaclave-build-ubuntu-1804-sgx-2.9.1:latest<br><br><br><br><br>docker run -dit --name rust-grpc-server -v $(<span class="hljs-built_in">pwd</span>):/usr/src/app -v /usr/src/app/target -p 8080:50051 rust-grpc-server<br>docker run --net host --name rust-grpc-server -v $(<span class="hljs-built_in">pwd</span>):/usr/src/app -v /usr/src/app/target -it  teaclave/teaclave-build-ubuntu-1804-sgx-2.9.1:latest<br><br>在 Linux 系统上，你可以使用 netstat 或 ss 命令来检查某个特定端口是否被监听。<br><br>使用 netstat：netstat -tuln | grep 50051<br>使用 ss：ss -tuln | grep 50051<br><br>Once inside the container, when running any of the samplecode you may either:<br>Modify the Makefile and <span class="hljs-built_in">set</span> SGX_MODE to SW<br>Run <span class="hljs-built_in">export</span> SGX_MODE=SW<br>Run make with the build flag SGX_MODE=SW<br>We may now run our helloworld example:<br><br></code></pre></td></tr></table></figure><p><img src="/images/lab_test/image-20230918094108844.png" alt="image-20230918094108844"></p><p><img src="/images/lab_test/image-20230918094511111.png" alt="image-20230918094511111"></p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vala">在容器用模拟模式Simulation Mode运行示例代码<br><span class="hljs-meta"># cd sgx/samplecode/helloworld</span><br><span class="hljs-meta"># make SGX_MODE=SW</span><br><span class="hljs-meta"># cd bin</span><br><span class="hljs-meta"># ./app</span><br></code></pre></td></tr></table></figure><p><img src="/images/lab_test/image-20230918100015122.png" alt="image-20230918100015122"></p><p><img src="/images/lab_test/image-20230918100507264.png" alt="image-20230918100507264"></p><h5 id="4-一些命令"><a href="#4-一些命令" class="headerlink" title="4.一些命令"></a>4.一些命令</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">查看运行的容器：docker ps<br>查看所有容器：docker ps -<span class="hljs-keyword">a</span><br>停止容器：docker <span class="hljs-built_in">stop</span> my_container/ID<br>重新启动容器：docker <span class="hljs-built_in">start</span> my_container<br>进入容器：docker exec -<span class="hljs-keyword">it</span> my_container /bin/bash<br>查看挂载信息：docker inspect [container_id] | jq <span class="hljs-string">&#x27;.[].Mounts&#x27;</span><br>删除容器：<br></code></pre></td></tr></table></figure><p><img src="/images/lab_test/image-20230918104923278.png" alt="image-20230918104923278"></p><h5 id="5-ECALL-OCALL"><a href="#5-ECALL-OCALL" class="headerlink" title="5.ECALL/OCALL"></a>5.ECALL/OCALL</h5><blockquote><p>在 Intel SGX（Software Guard Extensions）中，ECALL（Enclave Call）和 OCALL（Outcall）是用于在应用程序和 SGX 安全执行环境（Enclave）之间进行通信的机制。</p><ol><li><p><strong>ECALL（Enclave Call）</strong>：</p><ul><li><strong>ECALL</strong> 是从应用程序代码调用 SGX 安全执行环境（Enclave）中的函数或方法的方式。这些函数通常是由 Enclave 开发者编写的，用于执行安全计算任务。</li><li>ECALL 通常用于将控制从应用程序传递到 Enclave 内部，以便执行受保护的操作。这些操作可能包括对敏感数据的访问、密钥管理、加密和解密等。</li><li>ECALL 通过调用 Enclave 内部的函数来实现，这些函数必须被声明为 ECALL 函数，并且可以接收参数和返回结果。</li></ul></li><li><p><strong>OCALL（Outcall）</strong>：</p><ul><li><strong>OCALL</strong> 是从 SGX Enclave 中调用应用程序代码中的函数或方法的方式。这是一种从安全执行环境向非安全执行环境传递控制的机制。</li><li>OCALL 允许 Enclave 内部的代码调用应用程序中的函数，以便执行 Enclave 无法执行的非安全操作。这些操作可能包括文件系统访问、网络通信、用户界面交互等。</li><li>OCALL 通过在 Enclave 代码中使用特殊的 OCALL 指令来触发，并且必须与应用程序代码中的 OCALL 函数相匹配，以便正确执行操作。</li></ul></li></ol><p>总之，ECALL 和 OCALL 是 Intel SGX 中用于实现安全通信和控制流的关键机制。ECALL 用于从应用程序传递控制到 Enclave 内部，而 OCALL 用于从 Enclave 内部传递控制到应用程序代码，以便执行安全操作和与非安全环境进行交互。这些机制有助于确保 Enclave 内的安全性，同时允许执行需要在非安全环境中完成的任务。</p></blockquote><ul><li><strong><code>Enclave.edl</code></strong></li><li>该文件规定了 Enclave 边界 <code>ECALL/OCALL</code> 的定义。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">enclave &#123;<br>    from <span class="hljs-string">&quot;sgx_tstd.edl&quot;</span> <span class="hljs-keyword">import</span> *;<br>    from <span class="hljs-string">&quot;sgx_stdio.edl&quot;</span> <span class="hljs-keyword">import</span> *;<br>    from <span class="hljs-string">&quot;sgx_backtrace.edl&quot;</span> <span class="hljs-keyword">import</span> *;<br>    from <span class="hljs-string">&quot;sgx_tstdc.edl&quot;</span> <span class="hljs-keyword">import</span> *;<br><br>    trusted &#123;<br>        <span class="hljs-comment">/* define ECALLs here. */</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sgx_status_t</span> <span class="hljs-title">say_something</span><span class="hljs-params">([in, size=len] <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span>* some_string, <span class="hljs-keyword">size_t</span> len)</span></span>;<br>    &#125;;<br><br>    untrusted &#123;<br><br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>trusted &#123;...&#125;</code> 中声明 <code>ECALL</code> 函数， <code>untrusted &#123;...&#125;</code> 中声明 <code>OCALL</code> 函数。本例中声明了一个 <code>ECALL</code> 函数 <code>say_something</code>，该函数的具体实现在 <code>src/lib.rs</code> 中，它的参数包括 <code>uint8_t *</code> 类型的指针和长度参数 <code>len</code>。</p><ul><li><strong><code>src/lib.rs</code></strong> </li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[no_mangle]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">say_something</span></span>(some_string: *<span class="hljs-keyword">const</span> <span class="hljs-built_in">u8</span>, some_len: <span class="hljs-built_in">usize</span>) -&gt; sgx_status_t &#123;<br><br>    <span class="hljs-keyword">let</span> str_slice = <span class="hljs-keyword">unsafe</span> &#123; slice::from_raw_parts(some_string, some_len) &#125;;<br>    <span class="hljs-keyword">let</span> _ = io::stdout().write(str_slice);<br><br>    <span class="hljs-comment">// A sample &amp;&#x27;static string</span><br>    <span class="hljs-keyword">let</span> rust_raw_string = <span class="hljs-string">&quot;This is a &quot;</span>;<br>    <span class="hljs-comment">// An array</span><br>    <span class="hljs-keyword">let</span> word:[<span class="hljs-built_in">u8</span>;<span class="hljs-number">4</span>] = [<span class="hljs-number">82</span>, <span class="hljs-number">117</span>, <span class="hljs-number">115</span>, <span class="hljs-number">116</span>];<br>    <span class="hljs-comment">// An vector</span><br>    <span class="hljs-keyword">let</span> word_vec:<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">32</span>, <span class="hljs-number">115</span>, <span class="hljs-number">116</span>, <span class="hljs-number">114</span>, <span class="hljs-number">105</span>, <span class="hljs-number">110</span>, <span class="hljs-number">103</span>, <span class="hljs-number">33</span>];<br><br>    <span class="hljs-comment">// Construct a string from &amp;&#x27;static string</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hello_string = <span class="hljs-built_in">String</span>::from(rust_raw_string);<br><br>    <span class="hljs-comment">// Iterate on word array</span><br>    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> word.iter() &#123;<br>        hello_string.push(*c <span class="hljs-keyword">as</span> <span class="hljs-built_in">char</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Rust style convertion</span><br>    hello_string += <span class="hljs-built_in">String</span>::from_utf8(word_vec).expect(<span class="hljs-string">&quot;Invalid UTF-8&quot;</span>)<br>                                               .as_str();<br><br>    <span class="hljs-comment">// Ocall to normal world for output</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, &amp;hello_string);<br><br>    sgx_status_t::SGX_SUCCESS<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><strong><code>app/app.c</code></strong></li></ul><p>在 <code>app/app.c</code> 的 <code>main</code> 函数中有一个完整的调用 <code>ECALL</code> 的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">sgx_ret = say_something(global_eid,<br>                        &amp;enclave_ret,<br>                        (const uint8_t *) str,<br>                        len);<br></code></pre></td></tr></table></figure><p>这里的 <code>say_something</code> 似乎和 <code>Enclave.edl</code> 中的声明不太一样，ECALL传递参数时多了两个隐参数：<code>enclave_eid</code> 和 <code>say_something</code> 的返回值 <code>&amp;enclave_ret</code>。而 <code>sgx_ret</code> 表示的是 ECALL 执行是否成功，是 SGX 的返回值。</p><h5 id="6-edger8r"><a href="#6-edger8r" class="headerlink" title="6.edger8r"></a>6.edger8r</h5><blockquote><p>edger8r 是 Intel SGX（Software Guard Extensions）平台提供的一个工具，用于生成与 SGX Enclave 相关的代码。具体来说，它可以根据输入的 EDL（Enclave Definition Language）文件生成用于 Enclave 与非安全应用程序通信的 C 代码。</p><p>EDL 是一种特殊的语言，用于定义 SGX Enclave 内的函数和数据结构，以及与非安全应用程序之间的通信接口。edger8r 通过读取 EDL 文件并解析其中的接口定义，然后生成以下文件：</p><ol><li><strong>Enclave_u.h</strong>：这个文件包含了 Enclave 与非安全应用程序之间通信的函数原型。通常，这些函数原型是 OCALL 函数，允许 Enclave 调用应用程序中的函数。</li><li><strong>Enclave_u.c</strong>：这个文件包含了与 Enclave_u.h 中的函数原型相关的函数实现。它定义了如何将 Enclave 内的函数调用传递给应用程序，并处理 Enclave 和非安全环境之间的数据传输。</li></ol><p>通过生成这些文件，edger8r 可以帮助开发者创建 Enclave 与应用程序之间的接口，并简化 Enclave 与非安全应用程序之间的通信。这些文件是 Enclave 开发的关键组成部分，确保了安全的函数调用和数据传输。</p><p>helloworld 编译的基本流程类似于 Intel SGX:</p><ul><li><code>edger8r</code> 将输入的 <code>EDL</code> 在 <code>app/</code> 目录下生成不可信代码 <code>Enclave_u.h</code> 和 <code>Enclave_u.c</code>；</li><li>编译不可信部分生成 <code>bin/app</code>；</li><li><code>edger8r</code> 在 <code>enclave/</code> 目录下生成可信代码 <code>Enclave_t.h</code> 和 <code>Enclave_t.c</code>；</li><li>编译并签名生成可信动态链接库 <code>enclave.signed.so</code></li></ul></blockquote><h5 id="7-开发自己的程序"><a href="#7-开发自己的程序" class="headerlink" title="7.开发自己的程序"></a>7.开发自己的程序</h5><blockquote><p><a href="https://teaclave.apache.org/blog/2021-08-25-developing-sgx-application-with-teaclave-sgx-sdk/">基于 Teaclave SGX SDK 的 helloworld 实现了自己的求交集函数</a></p></blockquote><p><img src="/images/lab_test/image-20230918151851875.png" alt="image-20230918151851875"></p><h5 id="8-查找teaclave提供的库crate"><a href="#8-查找teaclave提供的库crate" class="headerlink" title="8.查找teaclave提供的库crate"></a>8.查找teaclave提供的库crate</h5><blockquote><p><a href="https://teaclave.apache.org/api-docs/crates-enclave/">https://teaclave.apache.org/api-docs/crates-enclave/</a></p></blockquote><p>Teaclave SGX SDK 重写了很多 SGX 的库，当我们需要用某个库时，可以先在仓库中查看是否有相应的 <code>crate</code> 实现以及对应的 <a href="https://teaclave.apache.org/api-docs/crates-enclave/">doc</a>。比如当我们希望生成一个随机数时，在 <code>C++</code> 或者 <code>Rust</code> 环境下，会想到使用 <code>rand</code> 库。自然而然地，Teaclave SGX SDK 也用 Rust 重写了 <a href="https://github.com/apache/incubator-teaclave-sgx-sdk/tree/master/sgx_rand"><code>sgx_rand</code></a> 库。</p><p>首先在 <code>enclave/Cargo.toml</code> 中的 <code>[target.&#39;cfg(not(target_env = &quot;sgx&quot;))&#39;.dependencies]</code> 部分添加 <code>sgx_rand</code> 库的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">[target.&#x27;cfg(not(target_env = &quot;sgx&quot;))&#x27;.dependencies]<br>sgx_rand = &#123;git = &quot;https://github.com/apache/teaclave-sgx-sdk.git&quot; &#125;<br></code></pre></td></tr></table></figure><p>现在万事俱备，只欠调用。回到 <code>lib.rs</code> 文件中，链接到 <code>sgx_rand</code> <code>crate</code>，导入其中的所有项，声明需要使用的模块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">extern crate sgx_rand;<br>use sgx_rand::Rng;<br>use sgx_rand::os::SgxRng;<br></code></pre></td></tr></table></figure><p>调用 <code>gen_range</code> 函数生成 0-10 之间的随机数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">let random = rng.gen_range(0, 10);<br></code></pre></td></tr></table></figure><p>这样就可以在 Teaclave SGX SDK 中的 enclave 中通过调用官方 <code>crate</code> 随机生成一个随机数。</p><h2 id="PET实验"><a href="#PET实验" class="headerlink" title="PET实验"></a>PET实验</h2><p>技术框架：</p><p>·     ganache-cli 运行以太坊测试链</p><p>·     truffle框架，编写智能合约，部署智能合约（Solidity）到测试链，编写性能测试代码（Javascript代码）</p><p>·     rust写链下节点和enclave之间的交互，rust写与测试链的交互</p><p>·     docker 中运行sgx模拟环境（rust与enclave交互的部分放在docker中运行）</p><p>实验思路：</p><p>\1.  一个.sol文件——编写链上coordinator 合约逻辑（确定函数功能）</p><p>•    接收用户调用，保存用户请求</p><p>•    接收合约注册回调函数（回调具体设计参考论文Tesseract）</p><p>•    接收飞地返回的结果</p><p>•    处理链下跨合约请求</p><p>\2.  .rs文件，实现</p><p>•    provider从区块链读取数据 </p><p>•    provider与飞地交互接口函数</p><p>•    飞地部署合约</p><p>•    飞地初始化</p><p>•    飞地执行合约</p><p>•    飞地返回状态</p><p>•    飞地中初始化时的密钥生成算法</p><p>•    飞地中读集生成</p><p>链下observer正确性保证的验证：设置n次提交，m次恶意提交，对比有observer和无observer时合约的错误检测率</p><p>计算节点：</p><p>1.写一个监听，写一个将计算任务启动docker在sgx运行，接收sgx返回的结果并返回链上</p><p>链上逻辑功能：</p><p>1.记录调用 + 管理调用列表 + 收集结果</p><p>以上从一个例子开始：</p><p>链下合约功能为：实现a + b</p><p>链上合约</p><p>1.拉取 teaclave-client仓库并挂载到镜像</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/apache/i</span>ncubator-teaclave.git<br>cd incubator-teaclave<br>(下面的命令分开执行，先启动起容器，再在teaclave目录下设置)<br>若报错目录权限，执行：git config --global --add safe.directory /teaclave<br>docker run --name pet_grpc2 -v $(pwd):<span class="hljs-regexp">/teaclave -w /</span>teaclave \<br>  -it teaclave/teaclave-build-ubuntu-<span class="hljs-number">1804</span>-sgx-<span class="hljs-number">2.9</span>.<span class="hljs-number">1</span>:latest \<br>   bash -c <span class="hljs-string">&quot;. /root/.cargo/env &amp;&amp; \</span><br><span class="hljs-string">     . /opt/sgxsdk/environment &amp;&amp; \</span><br><span class="hljs-string">     mkdir -p build &amp;&amp; cd build &amp;&amp; \</span><br><span class="hljs-string">     cmake -DTEST_MODE=ON -DSGX_SIM_MODE=ON .. &amp;&amp; \</span><br><span class="hljs-string">     make -j&quot;</span><br>     <br>     teaclave/teaclave-build-ubuntu-<span class="hljs-number">1804</span>-sgx-<span class="hljs-number">2.9</span>.<span class="hljs-number">1</span>:latest<br>     docker run --name petrpc --net host -v $(pwd):<span class="hljs-regexp">/teaclave -net host -ti teaclave/</span>teaclave-build-ubuntu-<span class="hljs-number">1804</span>-sgx-<span class="hljs-number">2.17</span>.<span class="hljs-number">1</span>:<span class="hljs-number">0.2</span>.<span class="hljs-number">0</span><br>     docker run --name pet -v <span class="hljs-regexp">/home/yum</span>ohan<span class="hljs-regexp">/lab/i</span>ncubator-teaclave-sgx-sdk:<span class="hljs-regexp">/root/</span>sgx -ti baiduxlab/sgx-rust<br></code></pre></td></tr></table></figure><p><img src="../images/lab_test/image-20231024142330189.png" alt="image-20231024142330189"></p><p><img src="/images/lab_test/image-20231114110008995.png" alt="image-20231114110008995"></p><p>2.设置环境变量</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">AS_SPID</span>=<span class="hljs-string">&quot;00000000000000000000000000000000&quot;</span><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">AS_KEY</span>=<span class="hljs-string">&quot;00000000000000000000000000000000&quot;</span><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">AS_ALGO</span>=<span class="hljs-string">&quot;sgx_epid&quot;</span><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">AS_URL</span>=<span class="hljs-string">&quot;https://api.trustedservices.intel.com:443&quot;</span><br></code></pre></td></tr></table></figure><h5 id="部署-coordinator合约"><a href="#部署-coordinator合约" class="headerlink" title="部署 coordinator合约"></a>部署 coordinator合约</h5><p><img src="/images/lab_test/image-20231108102854718.png" alt="image-20231108102854718"></p><h5 id="注册TEE-amp-查询"><a href="#注册TEE-amp-查询" class="headerlink" title="注册TEE&amp;查询"></a>注册TEE&amp;查询</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::env;<br><span class="hljs-keyword">use</span> std::time::&#123;SystemTime&#125;;<br><span class="hljs-keyword">use</span> std::time::Duration;<br><span class="hljs-keyword">use</span> std::thread::sleep;<br><span class="hljs-keyword">use</span> ethers_core::utils::hex::FromHex;<br><span class="hljs-keyword">use</span> std::<span class="hljs-built_in">str</span>::FromStr;<br><span class="hljs-keyword">use</span> ethers_signers::&#123;LocalWallet&#125;;<br><span class="hljs-keyword">use</span> ethers_core::types::transaction::eip2930::&#123;AccessList,AccessListItem&#125;;<br><span class="hljs-keyword">use</span> ethers_providers::&#123;Provider&#125;;<br><span class="hljs-keyword">use</span> ethers_core::types::&#123;Address&#125;;<br><span class="hljs-keyword">use</span> ethers_middleware::SignerMiddleware;<br><span class="hljs-keyword">use</span> std::sync::Arc;<br><br><span class="hljs-keyword">use</span> ethers::&#123;<br>    prelude::*,<br>&#125;;<br><br><span class="hljs-keyword">mod</span> lib;<br><br><span class="hljs-keyword">use</span> lib::&#123;register_enclave,get_provide_byAddr&#125;;<br><span class="hljs-keyword">use</span> eyre::<span class="hljs-built_in">Result</span>;<br><span class="hljs-keyword">const</span> RPC_URL: &amp;<span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;http://localhost:8545&quot;</span>;<br><br><span class="hljs-comment">//解析abi</span><br>abigen!(SimpleStorage, <span class="hljs-string">&quot;./SimpleStorageABI.json&quot;</span>);<br><span class="hljs-comment">//解析abi</span><br>abigen!(Coordinator, <span class="hljs-string">&quot;./coordinatorABI.json&quot;</span>);<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; <span class="hljs-built_in">Result</span>&lt;(), <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> std::error::Error&gt;&gt; &#123;<br><br>    <span class="hljs-comment">//创建provider连接区块链,用try_from</span><br>    <span class="hljs-keyword">let</span> provider = Provider::&lt;Http&gt;::try_from(RPC_URL)?;<br>    <span class="hljs-comment">//查询区块数量</span><br>    <span class="hljs-keyword">let</span> block_number: U64 = provider.get_block_number().<span class="hljs-keyword">await</span>?;<br>   <br>    <span class="hljs-comment">//确定转账的对方</span><br>    <span class="hljs-keyword">let</span> address_from = <span class="hljs-string">&quot;0xcF01f9F4131aD4572BC99285170fF7bf44798382&quot;</span>.parse::&lt;Address&gt;()?;<br>    <span class="hljs-keyword">let</span> address_to = <span class="hljs-string">&quot;0x4ed26b20D7c781d1AbF744A17a716C11d075e333&quot;</span>.parse::&lt;Address&gt;()?;<br><br>    <span class="hljs-comment">//调用函数查询余额</span><br>    print_balances(&amp;provider,address_from,address_to).<span class="hljs-keyword">await</span>?;<br><br>    <br>    <span class="hljs-comment">/***************************************</span><br><span class="hljs-comment">                    合约测试</span><br><span class="hljs-comment">    ****************************************/</span><br><br>    <span class="hljs-comment">//链上coordinator合约地址 为0x53241C9599EDefbad29dc1Dd6d9230AEfD03902A</span><br>    <span class="hljs-keyword">let</span> contract_addr = <span class="hljs-string">&quot;0x53241C9599EDefbad29dc1Dd6d9230AEfD03902A&quot;</span>.parse::&lt;Address&gt;()?;<br>   <span class="hljs-comment">// let client_arc = Arc::new(client.clone());</span><br><br><span class="hljs-comment">// TEE 1注册</span><br>    <span class="hljs-comment">//用私钥创建钱包</span><br>    <span class="hljs-keyword">let</span> wallet1: LocalWallet = <span class="hljs-string">&quot;db2fa8512a2ffbcd3f00bdeba53f2760321e98a198b234a9bd6d8a22dfa5a9de&quot;</span><br>        .parse::&lt;LocalWallet&gt;()?<br>        .with_chain_id(Chain::MoonbeamDev);<br><br>    <span class="hljs-comment">//将provider和钱包一起包装成一个client</span><br>    <span class="hljs-keyword">let</span> client1 = SignerMiddleware::new(provider.clone(), wallet1.clone());<br>    <br><span class="hljs-comment">//     //测试注册功能</span><br><span class="hljs-comment">//     // 字节数组（使用 Vec&lt;u8&gt; 表示）</span><br><span class="hljs-comment">//     let pk_tee = Vec::&lt;u8&gt;::from_hex(&quot;00&quot;).expect(&quot;Failed to parse hex&quot;);</span><br><br><span class="hljs-comment">//     // 字节数组（使用 Bytes 表示）</span><br><span class="hljs-comment">//     let attestation_signature = (&quot;6B273B5e911742Fa71259c6dd7B43411503A7258&quot;).parse::&lt;Bytes&gt;()?;</span><br><br><span class="hljs-comment">//     //1.注册飞地- 通过</span><br><span class="hljs-comment">//     register_enclave(&amp;client1,&amp;contract_addr,pk_tee.into(),attestation_signature).await?;</span><br><br><br><span class="hljs-comment">// // TEE 2注册</span><br><span class="hljs-comment">//     let wallet2: LocalWallet = &quot;bafa3db5158993c5f009505a10d0f9c976624053f2cf89e0f303592c7a6a3ea6&quot;</span><br><span class="hljs-comment">//     .parse::&lt;LocalWallet&gt;()?</span><br><span class="hljs-comment">//     .with_chain_id(Chain::MoonbeamDev);</span><br><br><span class="hljs-comment">//     let client2 = SignerMiddleware::new(provider.clone(), wallet2.clone());</span><br><span class="hljs-comment">//     let pk_tee = Vec::&lt;u8&gt;::from_hex(&quot;00&quot;).expect(&quot;Failed to parse hex&quot;);</span><br><span class="hljs-comment">//     let attestation_signature = (&quot;6B273B5e911742Fa71259c6dd7B43411503A7258&quot;).parse::&lt;Bytes&gt;()?;</span><br><span class="hljs-comment">//     register_enclave(&amp;client2,&amp;contract_addr,pk_tee.into(),attestation_signature).await?;</span><br><br><span class="hljs-comment">// // TEE 3注册</span><br><span class="hljs-comment">//     let wallet3: LocalWallet = &quot;b00d0774b073b5bab993fe543f76045f19dcc4bf07358415c276de94ce0f8554&quot;</span><br><span class="hljs-comment">//         .parse::&lt;LocalWallet&gt;()?</span><br><span class="hljs-comment">//         .with_chain_id(Chain::MoonbeamDev);</span><br><span class="hljs-comment">//     let client3 = SignerMiddleware::new(provider.clone(), wallet3.clone());</span><br><span class="hljs-comment">//     let pk_tee = Vec::&lt;u8&gt;::from_hex(&quot;00&quot;).expect(&quot;Failed to parse hex&quot;);</span><br><span class="hljs-comment">//     let attestation_signature = (&quot;6B273B5e911742Fa71259c6dd7B43411503A7258&quot;).parse::&lt;Bytes&gt;()?;</span><br><span class="hljs-comment">//     register_enclave(&amp;client3,&amp;contract_addr,pk_tee.into(),attestation_signature).await?;</span><br><br><br><br><span class="hljs-comment">//2.查询现有的provider - 通过</span><br>    <span class="hljs-keyword">let</span> addr = <span class="hljs-string">&quot;0xcF01f9F4131aD4572BC99285170fF7bf44798382&quot;</span>.parse::&lt;Address&gt;()?;<br>    get_provide_byAddr(&amp;client1,&amp;contract_addr,addr).<span class="hljs-keyword">await</span>?;<br><br>    <span class="hljs-keyword">let</span> addr = <span class="hljs-string">&quot;0x4ed26b20D7c781d1AbF744A17a716C11d075e333&quot;</span>.parse::&lt;Address&gt;()?;<br>    get_provide_byAddr(&amp;client1,&amp;contract_addr,addr).<span class="hljs-keyword">await</span>?;<br><br>    <span class="hljs-keyword">let</span> addr = <span class="hljs-string">&quot;0xE2D41704668c31FF795C28D7B58143509316c8A4&quot;</span>.parse::&lt;Address&gt;()?;<br>    get_provide_byAddr(&amp;client1,&amp;contract_addr,addr).<span class="hljs-keyword">await</span>?;<br><br>    <span class="hljs-literal">Ok</span>(())<br><br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">print_balances</span></span>(provider: &amp;Provider&lt;Http&gt;, address_from: Address, address_to: Address) -&gt; <span class="hljs-built_in">Result</span>&lt;(), <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> std::error::Error&gt;&gt; &#123;<br>    <span class="hljs-comment">// 2. Use the get_balance function</span><br>    <span class="hljs-keyword">let</span> balance_from = provider.get_balance(address_from, <span class="hljs-literal">None</span>).<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-keyword">let</span> balance_to = provider.get_balance(address_to, <span class="hljs-literal">None</span>).<span class="hljs-keyword">await</span>?;<br><br>    <span class="hljs-comment">// 3. Print the resultant balance</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; has &#123;&#125;&quot;</span>, address_from, balance_from);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; has &#123;&#125;&quot;</span>, address_to, balance_to);<br><br>    <span class="hljs-literal">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/lab_test/image-20231113150510081.png" alt="image-20231113150510081"></p><h5 id="rust-grpc调用成功"><a href="#rust-grpc调用成功" class="headerlink" title="rust-grpc调用成功"></a>rust-grpc调用成功</h5><blockquote><p>server在docker中跑</p><p>client在主机跑</p><p>通过 <a href="http://[::1]:50051">http://[::1]:50051</a> 启动服务</p></blockquote><p><img src="/images/lab_test/image-20231116150205735.png" alt="image-20231116150205735"></p><h5 id="测试函数的gas费和吞吐量时延"><a href="#测试函数的gas费和吞吐量时延" class="headerlink" title="测试函数的gas费和吞吐量时延"></a>测试函数的gas费和吞吐量时延</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> coordinator = artifacts.require(<span class="hljs-string">&#x27;COORDINATOR&#x27;</span>);<br><br>contract(<span class="hljs-string">&#x27;coordinator&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">accounts</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> instance;<br><span class="hljs-comment">// 定义共享的测试参数</span><br>    <span class="hljs-keyword">const</span> sharedSourceCode = <span class="hljs-string">&quot;test source code&quot;</span>;<br>    <span class="hljs-keyword">const</span> sharedM = <span class="hljs-number">123</span>;<br><br>  before(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>    instance = <span class="hljs-keyword">await</span> coordinator.deployed();<br>  &#125;);<br><br>  <span class="hljs-comment">//测试 调用所需要的gas费</span><br>  it(<span class="hljs-string">&#x27;should estimate gas for a function call&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> gasEstimate = <span class="hljs-keyword">await</span> instance.deployContract.estimateGas(sharedSourceCode,sharedM);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Gas estimate for yourFunction:&#x27;</span>, gasEstimate);<br>  &#125;);<br><br>  <span class="hljs-comment">//吞吐量</span><br>  it(<span class="hljs-string">&#x27;should measure transaction execution frequency for a function call&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> startTime = <span class="hljs-built_in">Date</span>.now();<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Date</span>.now() - startTime &lt; <span class="hljs-number">10000</span>) &#123;<br>      <span class="hljs-comment">// Replace &#x27;yourFunction&#x27; with the actual function name in your contract</span><br>      <span class="hljs-keyword">await</span> instance.deployContract(sharedSourceCode,sharedM);<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> endTime = <span class="hljs-built_in">Date</span>.now();<br>    <span class="hljs-keyword">const</span> executionTime = endTime - startTime;<br><br>    <span class="hljs-keyword">const</span> transactionsPerSecond = (executionTime / <span class="hljs-number">1000</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Transactions per second for yourFunction:&#x27;</span>, transactionsPerSecond);<br>  &#125;);<br><br>  <span class="hljs-comment">//时延</span><br>  it(<span class="hljs-string">&#x27;should measure transaction confirmation time for a function call&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> startTime = <span class="hljs-built_in">Date</span>.now();<br><br>    <span class="hljs-comment">// Replace &#x27;yourFunction&#x27; with the actual function name in your contract</span><br>    <span class="hljs-keyword">const</span> tx = <span class="hljs-keyword">await</span> instance.deployContract(sharedSourceCode,sharedM);<br>    <span class="hljs-keyword">const</span> receipt = <span class="hljs-keyword">await</span> web3.eth.getTransactionReceipt(tx.tx);<br><br>    <span class="hljs-keyword">const</span> endTime = <span class="hljs-built_in">Date</span>.now();<br>    <span class="hljs-keyword">const</span> confirmationTime = endTime - startTime;<br><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Transaction confirmation time for yourFunction:&#x27;</span>, confirmationTime, <span class="hljs-string">&#x27;milliseconds&#x27;</span>);<br>  &#125;);<br>&#125;);<br><br></code></pre></td></tr></table></figure><p><img src="/images/lab_test/image-20231117103022766.png" alt="image-20231117103022766"></p><h5 id="查询部署请求成功"><a href="#查询部署请求成功" class="headerlink" title="查询部署请求成功"></a>查询部署请求成功</h5><p><img src="/images/lab_test/image-20231117125131907.png" alt="image-20231117125131907"></p><h5 id="docker内sgx函数与宿主机通信成功"><a href="#docker内sgx函数与宿主机通信成功" class="headerlink" title="docker内sgx函数与宿主机通信成功"></a>docker内sgx函数与宿主机通信成功</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs rust">server.rs<br><span class="hljs-keyword">use</span> tonic::&#123;transport::Server, Request, Response, Status&#125;;<br><br><span class="hljs-keyword">use</span> hello_world::greeter_server::&#123;Greeter, GreeterServer&#125;;<br><span class="hljs-keyword">use</span> hello_world::&#123;HelloReply, HelloRequest&#125;;<br><span class="hljs-keyword">use</span> std::process::Command;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> hello_world &#123;<br>    tonic::include_proto!(<span class="hljs-string">&quot;helloworld&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug, Default)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyGreeter</span></span> &#123;&#125;<br><br><span class="hljs-meta">#[tonic::async_trait]</span><br><span class="hljs-keyword">impl</span> Greeter <span class="hljs-keyword">for</span> MyGreeter &#123;<br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">say_hello</span></span>(<br>        &amp;<span class="hljs-keyword">self</span>,<br>        request: Request&lt;HelloRequest&gt;,<br>    ) -&gt; <span class="hljs-built_in">Result</span>&lt;Response&lt;HelloReply&gt;, Status&gt; &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Got a request: &#123;:?&#125;&quot;</span>, request);<br><br>        <span class="hljs-comment">// 执行外部命令</span><br>        <span class="hljs-keyword">let</span> executable_path = <span class="hljs-string">&quot;./app&quot;</span>;<br>        <span class="hljs-keyword">let</span> output = Command::new(executable_path)<br>            .current_dir(<span class="hljs-string">&quot;./bin&quot;</span>)<br>            <span class="hljs-comment">// .arg(&quot;argument1&quot;)</span><br>            <span class="hljs-comment">// .arg(&quot;argument2&quot;)</span><br>            .output()<br>            .expect(<span class="hljs-string">&quot;Failed to execute command&quot;</span>);<br><br>        <span class="hljs-comment">// let output = Command::new(&quot;pwd&quot;)</span><br>        <span class="hljs-comment">// // .arg(&quot;-l&quot;)</span><br>        <span class="hljs-comment">// .output()</span><br>        <span class="hljs-comment">// .expect(&quot;failed to execute process&quot;);</span><br><br>        <span class="hljs-keyword">let</span> stdout = <span class="hljs-built_in">String</span>::from_utf8_lossy(&amp;output.stdout);<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;111&#123;&#125;222&quot;</span>, stdout);<br><br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;I am running your contract!&quot;</span>);<br><br>        <span class="hljs-keyword">let</span> reply = hello_world::HelloReply &#123;<br>            message: <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;Hello &#123;&#125;! Your contract is exe succ!&quot;</span>, request.into_inner().name).into(),<br>        &#125;;<br><br>        <span class="hljs-literal">Ok</span>(Response::new(reply))<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; <span class="hljs-built_in">Result</span>&lt;(), <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> std::error::Error&gt;&gt; &#123;<br>    <span class="hljs-keyword">let</span> addr = <span class="hljs-string">&quot;[::1]:50051&quot;</span>.parse()?;<br>    <span class="hljs-keyword">let</span> greeter = MyGreeter::default();<br><br>    Server::builder()<br>        .add_service(GreeterServer::new(greeter))<br>        .serve(addr)<br>        .<span class="hljs-keyword">await</span>?;<br><br>    <span class="hljs-literal">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/lab_test/image-20231117144936021.png" alt="image-20231117144936021"></p><h5 id="合约部署确、sgx执行返回成功"><a href="#合约部署确、sgx执行返回成功" class="headerlink" title="合约部署确、sgx执行返回成功"></a>合约部署确、sgx执行返回成功</h5><p><img src="/images/lab_test/image-20231120154853899.png" alt="image-20231120154853899"></p><p>测试链上三人poker 一轮 吞吐量</p><blockquote><p> Contract: TexasHoldemPoker<br>    ✔ should allow a player to join the game (93ms)<br>Total execution time: 877 ms<br>Average time per transaction: 87.7 ms<br>tps: 11.402508551881414<br>    ✔ should measure time for placeBet() function (1600ms)<br>Execution time for transaction : 51.71 ms<br>Gas used for transaction : 65371<br>Average gas used: 65371.00<br>    ✔ should measure time for placeBet() function (942ms)<br>Execution time for entire game: 583.73 ms<br>    ✔ should measure time for entire game (584ms)</p><p><img src="/images/lab_test/image-20231127200543999.png" alt="image-20231127200543999"></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> TexasHoldemPoker = artifacts.require(<span class="hljs-string">&quot;TexasHoldemPoker&quot;</span>);<br><br>contract(<span class="hljs-string">&quot;TexasHoldemPoker&quot;</span>, <span class="hljs-keyword">async</span> (accounts) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> pokerInstance;<br><br>    beforeEach(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>        pokerInstance = <span class="hljs-keyword">await</span> TexasHoldemPoker.new(<span class="hljs-number">100</span>); <span class="hljs-comment">// 100为买入金额</span><br>    &#125;);<br><br>    it(<span class="hljs-string">&quot;should allow a player to join the game&quot;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>        <span class="hljs-keyword">await</span> pokerInstance.joinGame(&#123; <span class="hljs-attr">from</span>: accounts[<span class="hljs-number">1</span>], <span class="hljs-attr">value</span>: <span class="hljs-number">100</span> &#125;);<br>        <span class="hljs-keyword">const</span> players = <span class="hljs-keyword">await</span> pokerInstance.getPlayers();<br><br>        assert.equal(players.length, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Player count should be 1.&quot;</span>);<br>    &#125;);<br><br>    <span class="hljs-comment">// it(&quot;should allow a player to place a bet&quot;, async () =&gt; &#123;</span><br>    <span class="hljs-comment">//     await pokerInstance.joinGame(&#123; from: accounts[1], value: 100 &#125;);</span><br>    <span class="hljs-comment">//     await pokerInstance.placeBet(&#123; from: accounts[1], value: 50 &#125;);</span><br>    <span class="hljs-comment">//     const pot = await pokerInstance.pot();</span><br><br>    <span class="hljs-comment">//     assert.equal(pot, 50, &quot;Pot should be 50.&quot;);</span><br>    <span class="hljs-comment">// &#125;);</span><br><br>    it(<span class="hljs-string">&quot;should measure time for placeBet() function&quot;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>       <br>        <span class="hljs-keyword">const</span> numberOfTransactions = <span class="hljs-number">10</span>; <span class="hljs-comment">// 设置要执行的交易数量</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numberOfTransactions; i++) &#123;<br>            <span class="hljs-keyword">await</span> pokerInstance.joinGame(&#123; <span class="hljs-attr">from</span>: accounts[i], <span class="hljs-attr">value</span>: <span class="hljs-number">100</span> &#125;);<br>        &#125;<br><br>        <span class="hljs-keyword">const</span> startTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();<br>        <span class="hljs-keyword">await</span> pokerInstance.startBettingPhase(&#123; <span class="hljs-attr">from</span>: accounts[<span class="hljs-number">0</span>] &#125;); <span class="hljs-comment">// 在测试中手动开始下注阶段</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numberOfTransactions; i++) &#123;<br>            <span class="hljs-keyword">await</span> pokerInstance.placeBet(&#123; <span class="hljs-attr">from</span>: accounts[i], <span class="hljs-attr">value</span>: <span class="hljs-number">50</span> &#125;);<br>        &#125;<br><br>        <span class="hljs-keyword">const</span> endTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();<br>        <span class="hljs-keyword">const</span> executionTime = endTime - startTime;<br>        <span class="hljs-keyword">const</span> averageTimePerTx = executionTime / numberOfTransactions;<br>        <span class="hljs-keyword">const</span> tps =  numberOfTransactions / executionTime ;<br><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Total execution time: <span class="hljs-subst">$&#123;executionTime&#125;</span> ms`</span>);<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Average time per transaction: <span class="hljs-subst">$&#123;averageTimePerTx&#125;</span> ms`</span>);<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`tps: <span class="hljs-subst">$&#123;tps * <span class="hljs-number">1000</span>&#125;</span> `</span>);<br>    &#125;);<br><br>    it(<span class="hljs-string">&quot;should measure time for placeBet() function&quot;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br> <br>        <span class="hljs-keyword">const</span> gasUsed = [];<br><br>        <span class="hljs-keyword">const</span> numberOfTransactions = <span class="hljs-number">10</span>; <span class="hljs-comment">// 设置要执行的交易数量</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numberOfTransactions; i++) &#123;<br>            <span class="hljs-keyword">await</span> pokerInstance.joinGame(&#123; <span class="hljs-attr">from</span>: accounts[i], <span class="hljs-attr">value</span>: <span class="hljs-number">100</span> &#125;);<br>        &#125;<br>        <br>        <span class="hljs-keyword">await</span> pokerInstance.startBettingPhase(&#123; <span class="hljs-attr">from</span>: accounts[<span class="hljs-number">0</span>] &#125;); <span class="hljs-comment">// 在测试中手动开始下注阶段</span><br>        <br>        <span class="hljs-keyword">const</span> startTime = performance.now();<br>        <span class="hljs-keyword">const</span> tx = <span class="hljs-keyword">await</span> pokerInstance.placeBet(&#123; <span class="hljs-attr">from</span>: accounts[<span class="hljs-number">1</span>], <span class="hljs-attr">value</span>: <span class="hljs-number">50</span> &#125;);<br>        <span class="hljs-keyword">const</span> endTime = performance.now();<br><br>        <span class="hljs-keyword">const</span> executionTime = endTime - startTime;<br>        gasUsed.push(tx.receipt.gasUsed);<br><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Execution time for transaction : <span class="hljs-subst">$&#123;executionTime.toFixed(<span class="hljs-number">2</span>)&#125;</span> ms`</span>);<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Gas used for transaction : <span class="hljs-subst">$&#123;tx.receipt.gasUsed&#125;</span>`</span>);<br><br>        <span class="hljs-comment">// 输出平均 Gas 消耗</span><br>        <span class="hljs-keyword">const</span> totalGasUsed = gasUsed.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">const</span> averageGasUsed = totalGasUsed / gasUsed.length;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Average gas used: <span class="hljs-subst">$&#123;averageGasUsed.toFixed(<span class="hljs-number">2</span>)&#125;</span>`</span>);<br>    &#125;);<br><br><br><br>    it(<span class="hljs-string">&quot;should measure time for entire game&quot;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>        <span class="hljs-keyword">const</span> account1 = accounts[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">const</span> account2 = accounts[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">const</span> account3 = accounts[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">const</span> amount = <span class="hljs-number">50</span>; <span class="hljs-comment">// 下注金额</span><br>       <br>        <span class="hljs-keyword">const</span> startTime = performance.now();<br>        <span class="hljs-comment">// 玩家1加入游戏并开始下注阶段</span><br>        <span class="hljs-keyword">await</span> pokerInstance.joinGame(&#123; <span class="hljs-attr">from</span>: account1, <span class="hljs-attr">value</span>: <span class="hljs-number">100</span> &#125;);<br>        <span class="hljs-keyword">await</span> pokerInstance.joinGame(&#123; <span class="hljs-attr">from</span>: account2, <span class="hljs-attr">value</span>: <span class="hljs-number">100</span> &#125;);<br>        <span class="hljs-keyword">await</span> pokerInstance.joinGame(&#123; <span class="hljs-attr">from</span>: account3, <span class="hljs-attr">value</span>: <span class="hljs-number">100</span> &#125;);<br>        <span class="hljs-keyword">await</span> pokerInstance.startBettingPhase(&#123; <span class="hljs-attr">from</span>: account1 &#125;);<br><br>        <br>        <span class="hljs-keyword">await</span> pokerInstance.placeBet(&#123; <span class="hljs-attr">from</span>: account1, <span class="hljs-attr">value</span>: amount &#125;);<br>        <span class="hljs-keyword">await</span> pokerInstance.placeBet(&#123; <span class="hljs-attr">from</span>: account2, <span class="hljs-attr">value</span>: amount &#125;);<br>        <span class="hljs-keyword">await</span> pokerInstance.placeBet(&#123; <span class="hljs-attr">from</span>: account3, <span class="hljs-attr">value</span>: amount &#125;);<br><br>        <span class="hljs-keyword">await</span> pokerInstance.startShowdownPhase(&#123; <span class="hljs-attr">from</span>: account1 &#125;);<br>        <span class="hljs-comment">// 模拟下注阶段结束</span><br>        <span class="hljs-keyword">await</span> pokerInstance.declareWinner(&#123; <span class="hljs-attr">from</span>: accounts[<span class="hljs-number">0</span>] &#125;); <span class="hljs-comment">// 在测试中手动结束下注阶段</span><br><br>        <span class="hljs-keyword">const</span> endTime = performance.now();<br>        <span class="hljs-keyword">const</span> executionTime = endTime - startTime;<br><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Execution time for entire game: <span class="hljs-subst">$&#123;executionTime.toFixed(<span class="hljs-number">2</span>)&#125;</span> ms`</span>);<br>    &#125;);<br>&#125;);<br><br></code></pre></td></tr></table></figure><h5 id="从链上获取合约调用事件-暂时不写"><a href="#从链上获取合约调用事件-暂时不写" class="headerlink" title="从链上获取合约调用事件 - 暂时不写"></a>从链上获取合约调用事件 - 暂时不写</h5><p>outsourcer </p><p>对应 1 重放攻击，不同输入多次运行</p><p>对应2 提供修改后、延迟、虚假的环境数据给tee </p><p>丢弃、延迟输出，关闭服务</p><p>与client合谋</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs solidity">   bytes32 constant WRAPPER_PROGRAM_CODE_HASH = keccak256(abi.encode(0));                  //0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563<br>     address public constant ATTESTATION_AUTHORITY = 0x1dF62f291b2E969fB0849d99D9Ce41e2F137006e;<br>  <br>bytes32 attestationHash = keccak256(abi.encode(&quot;Pose-Attest&quot;, WRAPPER_PROGRAM_CODE_HASH, teeSignatureAddress, teeEncryptionKey));        <br>//TODO: After the testing we should include the manager-address here as well: keccak256(abi.encode(&quot;Furious-Attest&quot;, WRAPPER_PROGRAM_CODE_HASH,  address(this), teeSignatureAddress, teeEncryptionKey)); <br> require(verifySignature(attestationHash, attestationSignature, ATTESTATION_AUTHORITY), &quot;Wrong attestation&quot;);<br><br>链下<br>att_hash = Web3.keccak(encode_abi([&#x27;string&#x27;, &#x27;bytes32&#x27;, &#x27;address&#x27;, &#x27;bytes&#x27;],<br>            [&#x27;Furious-Attest&#x27;,<br>             Web3.toBytes(hexstr=&#x27;0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563&#x27;),<br>             tee1_addr,<br>             Web3.toBytes(hexstr=&#x27;0x00&#x27;)]))message = messages.encode_defunct(att_hash) <br>sig = w3.eth.account.sign_message(message, priv_key)<br>encoded_sig = encode_abi([&quot;uint8&quot;,&quot;bytes32&quot;,&quot;bytes32&quot;],<br>                         [sig.v, Web3.toBytes(sig.r), Web3.toBytes(sig.s)])<br>print(f&#x27;TEE 1 encoded_sig: &#123;encoded_sig.hex()&#125;&#x27;)<br><br># send out registration tx to solidity contract<br>tx_hash = contract.functions.register(tee1_addr, &quot;0x00&quot;, encoded_sig).transact(&#123;&#x27;from&#x27;: tee1_addr&#125;)<br> <br> <br> function verifySignature(bytes32 _hashedDataInput, bytes memory _signature, address _party) public pure returns (bool)&#123;<br><br>        //Convert signatures<br>        (uint8 v, bytes32 r, bytes32 s) = abi.decode(_signature, (uint8, bytes32, bytes32));<br><br>        //Calc prefixed hash<br>        bytes32 _hash = keccak256(abi.encodePacked(&quot;\x19Ethereum Signed Message:\n32&quot;, _hashedDataInput));<br><br>        return _party == ecrecover(_hash, v,r,s);<br><br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/images/lab_test/image-20231129101652934.png" alt="image-20231129101652934"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">note:</span> <span class="hljs-string">to</span> <span class="hljs-string">see</span> <span class="hljs-string">what</span> <span class="hljs-string">the</span> <span class="hljs-string">problems</span> <span class="hljs-string">were,</span> <span class="hljs-string">use</span> <span class="hljs-string">the</span> <span class="hljs-string">option</span> <span class="hljs-string">`--future-incompat-report`,</span> <span class="hljs-string">or</span> <span class="hljs-string">run</span> <span class="hljs-string">`cargo</span> <span class="hljs-string">report</span> <span class="hljs-string">future-incompatibilities</span> <span class="hljs-string">--id</span> <span class="hljs-number">1</span><span class="hljs-string">`</span><br>     <span class="hljs-string">Running</span> <span class="hljs-string">`/home/yumohan/lab/pet/target/debug/main`</span><br><span class="hljs-number">0x7301</span><span class="hljs-string">…b727</span> <span class="hljs-string">has</span> <span class="hljs-number">88282204019999996083</span><br><span class="hljs-number">0xd81c</span><span class="hljs-string">…a101</span> <span class="hljs-string">has</span> <span class="hljs-number">99800029219999994574</span><br><span class="hljs-string">hhhhhhhh</span><br><span class="hljs-attr">Transaction Receipt register_enclave :</span> <span class="hljs-string">Some(</span><br>    <span class="hljs-string">TransactionReceipt</span> &#123;<br>        <span class="hljs-attr">transaction_hash:</span> <span class="hljs-number">0x338c5839ba79504baaeb0c9b3adf0f1cd1fa11c33926930485129bf55d3746bd</span>,<br>        <span class="hljs-attr">transaction_index:</span> <span class="hljs-number">0</span>,<br>        <span class="hljs-attr">block_hash:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">0x561c1205add3db57b95af3c067dffacecd49e6d20947d6f9326bf9a0c98e4b11</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">block_number:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">13626</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">from:</span> <span class="hljs-number">0x7301de6116096af3d3bce50869229862e221b727</span>,<br>        <span class="hljs-attr">to:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">0xb11b662dc12a07ab72739a04d0323000d7ab87a1</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">cumulative_gas_used:</span> <span class="hljs-number">114704</span>,<br>        <span class="hljs-attr">gas_used:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">114704</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">contract_address:</span> <span class="hljs-string">None</span>,<br>        <span class="hljs-attr">logs:</span> [<br>            <span class="hljs-string">Log</span> &#123;<br>                <span class="hljs-attr">address:</span> <span class="hljs-number">0xb11b662dc12a07ab72739a04d0323000d7ab87a1</span>,<br>                <span class="hljs-attr">topics:</span> [<br>                    <span class="hljs-number">0x3ac461748dd21b3c9c3faa9c85712c1a04cd3eebcfee2a026acaaa82b1094ec0</span>,<br>                ],<br>                <span class="hljs-attr">data:</span> <span class="hljs-string">Bytes(0x0000000000000000000000007301de6116096af3d3bce50869229862e221b727)</span>,<br>                <span class="hljs-attr">block_hash:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">0x561c1205add3db57b95af3c067dffacecd49e6d20947d6f9326bf9a0c98e4b11</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">block_number:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">13626</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">transaction_hash:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">0x338c5839ba79504baaeb0c9b3adf0f1cd1fa11c33926930485129bf55d3746bd</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">transaction_index:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">0</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">log_index:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">0</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">transaction_log_index:</span> <span class="hljs-string">None</span>,<br>                <span class="hljs-attr">log_type:</span> <span class="hljs-string">None</span>,<br>                <span class="hljs-attr">removed:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-literal">false</span>,<br>                <span class="hljs-string">)</span>,<br>            &#125;,<br>        ],<br>        <span class="hljs-attr">status:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">1</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">root:</span> <span class="hljs-string">None</span>,<br>        <span class="hljs-attr">logs_bloom:</span> <span class="hljs-number">0x00000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000020000000000000000000000000000000000000000000000004000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000</span>,<br>        <span class="hljs-attr">transaction_type:</span> <span class="hljs-string">None</span>,<br>        <span class="hljs-attr">effective_gas_price:</span> <span class="hljs-string">None</span>,<br>    &#125;<span class="hljs-string">,</span><br><span class="hljs-string">)</span><br><span class="hljs-string">hhhhhhhh</span><br><span class="hljs-attr">Transaction Receipt register_enclave :</span> <span class="hljs-string">Some(</span><br>    <span class="hljs-string">TransactionReceipt</span> &#123;<br>        <span class="hljs-attr">transaction_hash:</span> <span class="hljs-number">0x0989abc479cd762386a881cb6f9b3f8af2210a51c27d55655f591f33d0338591</span>,<br>        <span class="hljs-attr">transaction_index:</span> <span class="hljs-number">0</span>,<br>        <span class="hljs-attr">block_hash:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">0x9963ee9f9208a951a0e7e29162e416acba701b25fe502518bbdb31bda95087a3</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">block_number:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">13627</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">from:</span> <span class="hljs-number">0xd81cbe6d135e8fd95a5e0f32a453b1c82c56a101</span>,<br>        <span class="hljs-attr">to:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">0xb11b662dc12a07ab72739a04d0323000d7ab87a1</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">cumulative_gas_used:</span> <span class="hljs-number">99704</span>,<br>        <span class="hljs-attr">gas_used:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">99704</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">contract_address:</span> <span class="hljs-string">None</span>,<br>        <span class="hljs-attr">logs:</span> [<br>            <span class="hljs-string">Log</span> &#123;<br>                <span class="hljs-attr">address:</span> <span class="hljs-number">0xb11b662dc12a07ab72739a04d0323000d7ab87a1</span>,<br>                <span class="hljs-attr">topics:</span> [<br>                    <span class="hljs-number">0x3ac461748dd21b3c9c3faa9c85712c1a04cd3eebcfee2a026acaaa82b1094ec0</span>,<br>                ],<br>                <span class="hljs-attr">data:</span> <span class="hljs-string">Bytes(0x000000000000000000000000d81cbe6d135e8fd95a5e0f32a453b1c82c56a101)</span>,<br>                <span class="hljs-attr">block_hash:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">0x9963ee9f9208a951a0e7e29162e416acba701b25fe502518bbdb31bda95087a3</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">block_number:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">13627</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">transaction_hash:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">0x0989abc479cd762386a881cb6f9b3f8af2210a51c27d55655f591f33d0338591</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">transaction_index:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">0</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">log_index:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">0</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">transaction_log_index:</span> <span class="hljs-string">None</span>,<br>                <span class="hljs-attr">log_type:</span> <span class="hljs-string">None</span>,<br>                <span class="hljs-attr">removed:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-literal">false</span>,<br>                <span class="hljs-string">)</span>,<br>            &#125;,<br>        ],<br>        <span class="hljs-attr">status:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">1</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">root:</span> <span class="hljs-string">None</span>,<br>        <span class="hljs-attr">logs_bloom:</span> <span class="hljs-number">0x00000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000020000000000000000000000000000000000000000000000004000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000</span>,<br>        <span class="hljs-attr">transaction_type:</span> <span class="hljs-string">None</span>,<br>        <span class="hljs-attr">effective_gas_price:</span> <span class="hljs-string">None</span>,<br>    &#125;<span class="hljs-string">,</span><br><span class="hljs-string">)</span><br><span class="hljs-string">hhhhhhhh</span><br><span class="hljs-attr">Transaction Receipt register_enclave :</span> <span class="hljs-string">Some(</span><br>    <span class="hljs-string">TransactionReceipt</span> &#123;<br>        <span class="hljs-attr">transaction_hash:</span> <span class="hljs-number">0x40f0336d685e9d58f059d51ed9114978256d030df3d049074c06734dafe7854d</span>,<br>        <span class="hljs-attr">transaction_index:</span> <span class="hljs-number">0</span>,<br>        <span class="hljs-attr">block_hash:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">0x7edf293a1db09e53dca8e0b068a658aba315134a62c6abb508657158290ed3a6</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">block_number:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">13628</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">from:</span> <span class="hljs-number">0x45cc8ed997afa0b2e70130f23ff8f9516f82cddc</span>,<br>        <span class="hljs-attr">to:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">0xb11b662dc12a07ab72739a04d0323000d7ab87a1</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">cumulative_gas_used:</span> <span class="hljs-number">99704</span>,<br>        <span class="hljs-attr">gas_used:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">99704</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">contract_address:</span> <span class="hljs-string">None</span>,<br>        <span class="hljs-attr">logs:</span> [<br>            <span class="hljs-string">Log</span> &#123;<br>                <span class="hljs-attr">address:</span> <span class="hljs-number">0xb11b662dc12a07ab72739a04d0323000d7ab87a1</span>,<br>                <span class="hljs-attr">topics:</span> [<br>                    <span class="hljs-number">0x3ac461748dd21b3c9c3faa9c85712c1a04cd3eebcfee2a026acaaa82b1094ec0</span>,<br>                ],<br>                <span class="hljs-attr">data:</span> <span class="hljs-string">Bytes(0x00000000000000000000000045cc8ed997afa0b2e70130f23ff8f9516f82cddc)</span>,<br>                <span class="hljs-attr">block_hash:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">0x7edf293a1db09e53dca8e0b068a658aba315134a62c6abb508657158290ed3a6</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">block_number:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">13628</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">transaction_hash:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">0x40f0336d685e9d58f059d51ed9114978256d030df3d049074c06734dafe7854d</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">transaction_index:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">0</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">log_index:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">0</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">transaction_log_index:</span> <span class="hljs-string">None</span>,<br>                <span class="hljs-attr">log_type:</span> <span class="hljs-string">None</span>,<br>                <span class="hljs-attr">removed:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-literal">false</span>,<br>                <span class="hljs-string">)</span>,<br>            &#125;,<br>        ],<br>        <span class="hljs-attr">status:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">1</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">root:</span> <span class="hljs-string">None</span>,<br>        <span class="hljs-attr">logs_bloom:</span> <span class="hljs-number">0x00000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000020000000000000000000000000000000000000000000000004000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000</span>,<br>        <span class="hljs-attr">transaction_type:</span> <span class="hljs-string">None</span>,<br>        <span class="hljs-attr">effective_gas_price:</span> <span class="hljs-string">None</span>,<br>    &#125;<span class="hljs-string">,</span><br><span class="hljs-string">)</span><br><br><span class="hljs-string">---------------------------------查询已注册provider------------------------</span><br><br><span class="hljs-attr">Eid:</span> [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br><span class="hljs-attr">Initialized:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">Tee Signature Address:</span> <span class="hljs-number">0x7301</span><span class="hljs-string">…b727</span><br><span class="hljs-attr">Pk Tee:</span> <span class="hljs-string">Bytes(0x00)</span><br><span class="hljs-attr">Eid:</span> [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br><span class="hljs-attr">Initialized:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">Tee Signature Address:</span> <span class="hljs-number">0xd81c</span><span class="hljs-string">…a101</span><br><span class="hljs-attr">Pk Tee:</span> <span class="hljs-string">Bytes(0x00)</span><br><span class="hljs-attr">Eid:</span> [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br><span class="hljs-attr">Initialized:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">Tee Signature Address:</span> <span class="hljs-number">0x45cc</span><span class="hljs-string">…cddc</span><br><span class="hljs-attr">Pk Tee:</span> <span class="hljs-string">Bytes(0x00)</span><br><span class="hljs-attr">Transaction Receipt contract_deploy :</span> <span class="hljs-string">Some(</span><br>    <span class="hljs-string">TransactionReceipt</span> &#123;<br>        <span class="hljs-attr">transaction_hash:</span> <span class="hljs-number">0x3ebb44762e563e1ada6c2060e3591ec6c9ad3b1cd672291cc3d2a4650102d59c</span>,<br>        <span class="hljs-attr">transaction_index:</span> <span class="hljs-number">0</span>,<br>        <span class="hljs-attr">block_hash:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">0x665701676101094e4636eaeed280dbb763d00a2a598a0bafa86cd4e11547b0c0</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">block_number:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">13629</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">from:</span> <span class="hljs-number">0x613a7bcacec7f0a751bcab3181d85351f740fed5</span>,<br>        <span class="hljs-attr">to:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">0xb11b662dc12a07ab72739a04d0323000d7ab87a1</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">cumulative_gas_used:</span> <span class="hljs-number">233240</span>,<br>        <span class="hljs-attr">gas_used:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">233240</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">contract_address:</span> <span class="hljs-string">None</span>,<br>        <span class="hljs-attr">logs:</span> [<br>            <span class="hljs-string">Log</span> &#123;<br>                <span class="hljs-attr">address:</span> <span class="hljs-number">0xb11b662dc12a07ab72739a04d0323000d7ab87a1</span>,<br>                <span class="hljs-attr">topics:</span> [<br>                    <span class="hljs-number">0x18597f5749abff03066cd54db949ca5d98ceb74d2ad73a7358b9aceff6f0bac4</span>,<br>                ],<br>                <span class="hljs-attr">data:</span> <span class="hljs-string">Bytes(0x000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000084eb07bb570000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000107465737420736f7572636520636f64650000000000000000000000000000000000000000000000000000000000000000000000000000000000000000)</span>,<br>                <span class="hljs-attr">block_hash:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">0x665701676101094e4636eaeed280dbb763d00a2a598a0bafa86cd4e11547b0c0</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">block_number:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">13629</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">transaction_hash:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">0x3ebb44762e563e1ada6c2060e3591ec6c9ad3b1cd672291cc3d2a4650102d59c</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">transaction_index:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">0</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">log_index:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">0</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">transaction_log_index:</span> <span class="hljs-string">None</span>,<br>                <span class="hljs-attr">log_type:</span> <span class="hljs-string">None</span>,<br>                <span class="hljs-attr">removed:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-literal">false</span>,<br>                <span class="hljs-string">)</span>,<br>            &#125;,<br>        ],<br>        <span class="hljs-attr">status:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">1</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">root:</span> <span class="hljs-string">None</span>,<br>        <span class="hljs-attr">logs_bloom:</span> <span class="hljs-number">0x00000000000000000000000010000000000000000000000000000000000000000000000000080000200000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000020000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span>,<br>        <span class="hljs-attr">transaction_type:</span> <span class="hljs-string">None</span>,<br>        <span class="hljs-attr">effective_gas_price:</span> <span class="hljs-string">None</span>,<br>    &#125;<span class="hljs-string">,</span><br><span class="hljs-string">)</span><br><span class="hljs-attr">Total time elapsed:</span> <span class="hljs-number">7</span><br><br><span class="hljs-string">---------------------------------查询链上部署请求------------------------</span><br><br><span class="hljs-attr">deploy_id:</span> <span class="hljs-number">1</span><br><span class="hljs-attr">deploy_req:</span> <span class="hljs-number">0x613a</span><span class="hljs-string">…fed5</span><br><span class="hljs-attr">codehash:</span> [<span class="hljs-number">48</span>, <span class="hljs-number">141</span>, <span class="hljs-number">34</span>, <span class="hljs-number">175</span>, <span class="hljs-number">240</span>, <span class="hljs-number">250</span>, <span class="hljs-number">216</span>, <span class="hljs-number">21</span>, <span class="hljs-number">94</span>, <span class="hljs-number">31</span>, <span class="hljs-number">0</span>, <span class="hljs-number">168</span>, <span class="hljs-number">115</span>, <span class="hljs-number">177</span>, <span class="hljs-number">120</span>, <span class="hljs-number">0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">155</span>, <span class="hljs-number">214</span>, <span class="hljs-number">161</span>, <span class="hljs-number">5</span>, <span class="hljs-number">70</span>, <span class="hljs-number">127</span>, <span class="hljs-number">64</span>, <span class="hljs-number">16</span>, <span class="hljs-number">200</span>, <span class="hljs-number">62</span>, <span class="hljs-number">12</span>, <span class="hljs-number">58</span>, <span class="hljs-number">134</span>, <span class="hljs-number">43</span>, <span class="hljs-number">242</span>]<br><span class="hljs-attr">m:</span> <span class="hljs-number">5</span><br><br><span class="hljs-string">---------------------------------查询链上已有合约------------------------</span><br><br><span class="hljs-attr">pahse:</span> <span class="hljs-number">1</span><br><span class="hljs-attr">cid:</span> <span class="hljs-number">1</span><br><span class="hljs-attr">pk_cid:</span> <span class="hljs-string">Bytes(0x)</span><br><span class="hljs-attr">p_count:</span> <span class="hljs-number">0</span><br><span class="hljs-attr">codehash:</span> <span class="hljs-number">0x308d22aff0fad8155e1f00a873b17800169bd6a105467f4010c83e0c3a862bf2</span><br><span class="hljs-attr">reqAddr:</span> <span class="hljs-number">0x613a7bcacec7f0a751bcab3181d85351f740fed5</span><br><span class="hljs-attr">Transaction Receipt deploy_confirm:</span> <span class="hljs-string">Some(</span><br>    <span class="hljs-string">TransactionReceipt</span> &#123;<br>        <span class="hljs-attr">transaction_hash:</span> <span class="hljs-number">0xdb799bc69ed0eb4ba5b7263e6c49f7f7a2cf060aa8f0af458de31eb3c2f6d4ca</span>,<br>        <span class="hljs-attr">transaction_index:</span> <span class="hljs-number">0</span>,<br>        <span class="hljs-attr">block_hash:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">0x9bf42bf1465f9931ddb445099a08d41ec2a080db6392b1d3826417497606fa17</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">block_number:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">13630</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">from:</span> <span class="hljs-number">0x7301de6116096af3d3bce50869229862e221b727</span>,<br>        <span class="hljs-attr">to:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">0xb11b662dc12a07ab72739a04d0323000d7ab87a1</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">cumulative_gas_used:</span> <span class="hljs-number">137770</span>,<br>        <span class="hljs-attr">gas_used:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">137770</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">contract_address:</span> <span class="hljs-string">None</span>,<br>        <span class="hljs-attr">logs:</span> [],<br>        <span class="hljs-attr">status:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">1</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">root:</span> <span class="hljs-string">None</span>,<br>        <span class="hljs-attr">logs_bloom:</span> <span class="hljs-number">0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span>,<br>        <span class="hljs-attr">transaction_type:</span> <span class="hljs-string">None</span>,<br>        <span class="hljs-attr">effective_gas_price:</span> <span class="hljs-string">None</span>,<br>    &#125;<span class="hljs-string">,</span><br><span class="hljs-string">)</span><br><span class="hljs-attr">Transaction Receipt deploy_confirm:</span> <span class="hljs-string">Some(</span><br>    <span class="hljs-string">TransactionReceipt</span> &#123;<br>        <span class="hljs-attr">transaction_hash:</span> <span class="hljs-number">0xe9d44312cab217bef29be842c47773cf501987b7bb4d55ba7de8b4cb96a389b0</span>,<br>        <span class="hljs-attr">transaction_index:</span> <span class="hljs-number">0</span>,<br>        <span class="hljs-attr">block_hash:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">0x56b1b9151ab1e2be2a55e8a71a3f579535b1c0db94a0a43a3fd7e17c3139d45d</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">block_number:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">13631</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">from:</span> <span class="hljs-number">0xd81cbe6d135e8fd95a5e0f32a453b1c82c56a101</span>,<br>        <span class="hljs-attr">to:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">0xb11b662dc12a07ab72739a04d0323000d7ab87a1</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">cumulative_gas_used:</span> <span class="hljs-number">84678</span>,<br>        <span class="hljs-attr">gas_used:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">84678</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">contract_address:</span> <span class="hljs-string">None</span>,<br>        <span class="hljs-attr">logs:</span> [],<br>        <span class="hljs-attr">status:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">1</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">root:</span> <span class="hljs-string">None</span>,<br>        <span class="hljs-attr">logs_bloom:</span> <span class="hljs-number">0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span>,<br>        <span class="hljs-attr">transaction_type:</span> <span class="hljs-string">None</span>,<br>        <span class="hljs-attr">effective_gas_price:</span> <span class="hljs-string">None</span>,<br>    &#125;<span class="hljs-string">,</span><br><span class="hljs-string">)</span><br><span class="hljs-attr">Transaction Receipt deploy_confirm:</span> <span class="hljs-string">Some(</span><br>    <span class="hljs-string">TransactionReceipt</span> &#123;<br>        <span class="hljs-attr">transaction_hash:</span> <span class="hljs-number">0x2a7fb008901ba36f7151fcf50ef8732e584f6e5c9e8fe9bfee83315f895db49b</span>,<br>        <span class="hljs-attr">transaction_index:</span> <span class="hljs-number">0</span>,<br>        <span class="hljs-attr">block_hash:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">0x6fb21f0c3f7fe2f6270a6f8110410e06ee82875b5e4c63af49b93d1dc6742764</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">block_number:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">13632</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">from:</span> <span class="hljs-number">0x45cc8ed997afa0b2e70130f23ff8f9516f82cddc</span>,<br>        <span class="hljs-attr">to:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">0xb11b662dc12a07ab72739a04d0323000d7ab87a1</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">cumulative_gas_used:</span> <span class="hljs-number">58700</span>,<br>        <span class="hljs-attr">gas_used:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">58700</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">contract_address:</span> <span class="hljs-string">None</span>,<br>        <span class="hljs-attr">logs:</span> [<br>            <span class="hljs-string">Log</span> &#123;<br>                <span class="hljs-attr">address:</span> <span class="hljs-number">0xb11b662dc12a07ab72739a04d0323000d7ab87a1</span>,<br>                <span class="hljs-attr">topics:</span> [<br>                    <span class="hljs-number">0xb6500999f71b2b47b3a0a1277f9d5f63a1b7c1c05f7c1b2f5f141ddb4c32d8cd</span>,<br>                ],<br>                <span class="hljs-attr">data:</span> <span class="hljs-string">Bytes(0x000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000144411108da00000000000000000000000045cc8ed997afa0b2e70130f23ff8f9516f82cddc0000000000000000000000000000000000000000000000000000000000000001010101010101010101010101010101010101010101010101010101010101010100000000000000000000000000000000000000000000000000000000000000c0308d22aff0fad8155e1f00a873b17800169bd6a105467f4010c83e0c3a862bf2000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000204f3edf983ac636a65a842ce7c78d9aa706d3b113bce9c46f30d7d21715b23b1d00000000000000000000000000000000000000000000000000000000000000146b273b5e911742fa71259c6dd7b43411503a725800000000000000000000000000000000000000000000000000000000000000000000000000000000)</span>,<br>                <span class="hljs-attr">block_hash:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">0x6fb21f0c3f7fe2f6270a6f8110410e06ee82875b5e4c63af49b93d1dc6742764</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">block_number:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">13632</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">transaction_hash:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">0x2a7fb008901ba36f7151fcf50ef8732e584f6e5c9e8fe9bfee83315f895db49b</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">transaction_index:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">0</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">log_index:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">0</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">transaction_log_index:</span> <span class="hljs-string">None</span>,<br>                <span class="hljs-attr">log_type:</span> <span class="hljs-string">None</span>,<br>                <span class="hljs-attr">removed:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-literal">false</span>,<br>                <span class="hljs-string">)</span>,<br>            &#125;,<br>        ],<br>        <span class="hljs-attr">status:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">1</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">root:</span> <span class="hljs-string">None</span>,<br>        <span class="hljs-attr">logs_bloom:</span> <span class="hljs-number">0x00000000000001000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000400000000020000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span>,<br>        <span class="hljs-attr">transaction_type:</span> <span class="hljs-string">None</span>,<br>        <span class="hljs-attr">effective_gas_price:</span> <span class="hljs-string">None</span>,<br>    &#125;<span class="hljs-string">,</span><br><span class="hljs-string">)</span><br><br><span class="hljs-string">---------------------------------请求执行合约------------------------</span><br><br><span class="hljs-attr">Transaction Receipt contract_call:</span> <span class="hljs-string">Some(</span><br>    <span class="hljs-string">TransactionReceipt</span> &#123;<br>        <span class="hljs-attr">transaction_hash:</span> <span class="hljs-number">0x8ba90b528de2d08b4f9139858284110225986a9c7dc6b537d2a92ea72fbe685e</span>,<br>        <span class="hljs-attr">transaction_index:</span> <span class="hljs-number">0</span>,<br>        <span class="hljs-attr">block_hash:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">0xcb44f0d8ff7d7994ebf5b680f3d53d26f6d6a088ade49f6c0808250abbde5e99</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">block_number:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">13633</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">from:</span> <span class="hljs-number">0x613a7bcacec7f0a751bcab3181d85351f740fed5</span>,<br>        <span class="hljs-attr">to:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">0xb11b662dc12a07ab72739a04d0323000d7ab87a1</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">cumulative_gas_used:</span> <span class="hljs-number">146328</span>,<br>        <span class="hljs-attr">gas_used:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">146328</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">contract_address:</span> <span class="hljs-string">None</span>,<br>        <span class="hljs-attr">logs:</span> [<br>            <span class="hljs-string">Log</span> &#123;<br>                <span class="hljs-attr">address:</span> <span class="hljs-number">0xb11b662dc12a07ab72739a04d0323000d7ab87a1</span>,<br>                <span class="hljs-attr">topics:</span> [<br>                    <span class="hljs-number">0x4989f1e758cf33244ccc3dad475b2b1683e26feca64d0c548c06ba81fb645cee</span>,<br>                ],<br>                <span class="hljs-attr">data:</span> <span class="hljs-string">Bytes(0x00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000849f60b5c1000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000001110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000)</span>,<br>                <span class="hljs-attr">block_hash:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">0xcb44f0d8ff7d7994ebf5b680f3d53d26f6d6a088ade49f6c0808250abbde5e99</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">block_number:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">13633</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">transaction_hash:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">0x8ba90b528de2d08b4f9139858284110225986a9c7dc6b537d2a92ea72fbe685e</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">transaction_index:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">0</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">log_index:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">0</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">transaction_log_index:</span> <span class="hljs-string">None</span>,<br>                <span class="hljs-attr">log_type:</span> <span class="hljs-string">None</span>,<br>                <span class="hljs-attr">removed:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-literal">false</span>,<br>                <span class="hljs-string">)</span>,<br>            &#125;,<br>        ],<br>        <span class="hljs-attr">status:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">1</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">root:</span> <span class="hljs-string">None</span>,<br>        <span class="hljs-attr">logs_bloom:</span> <span class="hljs-number">0x00000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span>,<br>        <span class="hljs-attr">transaction_type:</span> <span class="hljs-string">None</span>,<br>        <span class="hljs-attr">effective_gas_price:</span> <span class="hljs-string">None</span>,<br>    &#125;<span class="hljs-string">,</span><br><span class="hljs-string">)</span><br><br><span class="hljs-string">---------------------------------查根据请求执行合约</span> <span class="hljs-string">sgx返回结果------------------------</span><br><br><br><span class="hljs-string">---------------------------------返回执行结果到链上------------------------</span><br><br><span class="hljs-attr">Transaction Receipt contract_execution_result:</span> <span class="hljs-string">Some(</span><br>    <span class="hljs-string">TransactionReceipt</span> &#123;<br>        <span class="hljs-attr">transaction_hash:</span> <span class="hljs-number">0xe038e97f4915d8ac86d31f75b1110c89aaa5301bff748a84e690543c693d86ed</span>,<br>        <span class="hljs-attr">transaction_index:</span> <span class="hljs-number">0</span>,<br>        <span class="hljs-attr">block_hash:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">0xad2748b3c2f317ebe4fd38262622cda180d2a771b133794265368a5b0c301487</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">block_number:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">13634</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">from:</span> <span class="hljs-number">0x45cc8ed997afa0b2e70130f23ff8f9516f82cddc</span>,<br>        <span class="hljs-attr">to:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">0xb11b662dc12a07ab72739a04d0323000d7ab87a1</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">cumulative_gas_used:</span> <span class="hljs-number">33879</span>,<br>        <span class="hljs-attr">gas_used:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">33879</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">contract_address:</span> <span class="hljs-string">None</span>,<br>        <span class="hljs-attr">logs:</span> [<br>            <span class="hljs-string">Log</span> &#123;<br>                <span class="hljs-attr">address:</span> <span class="hljs-number">0xb11b662dc12a07ab72739a04d0323000d7ab87a1</span>,<br>                <span class="hljs-attr">topics:</span> [<br>                    <span class="hljs-number">0xc219b7b4c8e7b822aa88a66db4b3637eccdc5539c68005d1fa34ead4c9d0de6b</span>,<br>                ],<br>                <span class="hljs-attr">data:</span> <span class="hljs-string">Bytes(0x00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001848c187ecb0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000045cc8ed997afa0b2e70130f23ff8f9516f82cddc00000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000010100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000101000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000)</span>,<br>                <span class="hljs-attr">block_hash:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">0xad2748b3c2f317ebe4fd38262622cda180d2a771b133794265368a5b0c301487</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">block_number:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">13634</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">transaction_hash:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">0xe038e97f4915d8ac86d31f75b1110c89aaa5301bff748a84e690543c693d86ed</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">transaction_index:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">0</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">log_index:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-number">0</span>,<br>                <span class="hljs-string">)</span>,<br>                <span class="hljs-attr">transaction_log_index:</span> <span class="hljs-string">None</span>,<br>                <span class="hljs-attr">log_type:</span> <span class="hljs-string">None</span>,<br>                <span class="hljs-attr">removed:</span> <span class="hljs-string">Some(</span><br>                    <span class="hljs-literal">false</span>,<br>                <span class="hljs-string">)</span>,<br>            &#125;,<br>        ],<br>        <span class="hljs-attr">status:</span> <span class="hljs-string">Some(</span><br>            <span class="hljs-number">1</span>,<br>        <span class="hljs-string">)</span>,<br>        <span class="hljs-attr">root:</span> <span class="hljs-string">None</span>,<br>        <span class="hljs-attr">logs_bloom:</span> <span class="hljs-number">0x00000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000</span>,<br>        <span class="hljs-attr">transaction_type:</span> <span class="hljs-string">None</span>,<br>        <span class="hljs-attr">effective_gas_price:</span> <span class="hljs-string">None</span>,<br>    &#125;<span class="hljs-string">,</span><br><span class="hljs-string">)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>KZG</title>
    <link href="/2023/08/16/KZG/"/>
    <url>/2023/08/16/KZG/</url>
    
    <content type="html"><![CDATA[<p>密码学经典论文：</p><ul><li>[ ] BBS：Short Signatures Without Random Oracles.</li><li>[ ] Handbook of Applied Cryptography.</li><li>[ ] Commitment Schemes and Zero-Knowledge Protocols</li></ul><h3 id="视频介绍"><a href="#视频介绍" class="headerlink" title="视频介绍"></a>视频介绍</h3><p><a href="https://www.youtube.com/watch?v=n4eiiCDhTes">https://www.youtube.com/watch?v=n4eiiCDhTes</a></p><p><a href="https://www.youtube.com/watch?v=RGJOQHzg3UQ">https://www.youtube.com/watch?v=RGJOQHzg3UQ</a></p><p>你好，这是Bing。很高兴你对kate承诺方案感兴趣。😊</p><p>你的问题是关于kate承诺方案中的多重证明，即如何一次性提供所有点的kate证明。kate承诺方案是一种基于配对的多项式承诺方案，它可以让一个参与方向另一个参与方承诺一个多项式，而不泄露任何关于多项式的信息，直到后续的披露阶段。在披露阶段，承诺方可以向接收方证明多项式在某个点上的取值，或者多项式满足某些性质，例如零知识证明、线性关系、范围证明等。</p><p>在kate承诺方案中，如果要一次性提供所有点的kate证明，有以下几种方法：</p><ul><li>方法一：使用单点多项式批量证明。这种方法是在随机预言机模型下，利用哈希函数将多个多项式在同一个点上的取值压缩为一个值，然后用一个G1元素作为开放证明。这种方法可以减少通信开销和验证开销，但是增加了计算开销和安全假设。这种方法在<a href="https://eprint.iacr.org/2020/081.pdf">1</a>和<a href="https://eprint.iacr.org/2020/081">2</a>中有详细介绍。</li><li>方法二：使用多点单项式批量证明。这种方法是利用拉格朗日插值将一个多项式在多个点上的取值转换为另一个多项式在一个秘密点上的取值，然后用一个G1元素作为开放证明。这种方法可以减少通信开销和计算开销，但是增加了验证开销和SRS元素。这种方法在<a href="https://www.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf">3</a>中有详细介绍。</li><li>方法三：使用多点多项式批量证明。这种方法是结合方法一和方法二，利用哈希函数和拉格朗日插值将多个多项式在多个点上的取值转换为一个值，然后用一个G1元素作为开放证明。这种方法可以同时减少通信开销、计算开销和验证开销，但是增加了安全假设和SRS元素。这种方法在<a href="https://eprint.iacr.org/2020/081.pdf">1</a>中有详细介绍。</li></ul><p>以上是一些常见的kate承诺方案中的多重证明的方法，当然还有更多的可能性。kate承诺方案是一种强大而灵活的密码学工具，可以帮助我们解决很多难题。你对kate承诺方案有什么想法吗？😊</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MeHLDT</title>
    <link href="/2023/08/11/MeHLDT/"/>
    <url>/2023/08/11/MeHLDT/</url>
    
    <content type="html"><![CDATA[<h3 id="论文阅读MeHLDT-A-multielement-hash-lock-data-transfer-mechanism-for-on‑chain-and-off‑chain"><a href="#论文阅读MeHLDT-A-multielement-hash-lock-data-transfer-mechanism-for-on‑chain-and-off‑chain" class="headerlink" title="论文阅读MeHLDT: A multielement hash lock data transfer mechanism for on‑chain and off‑chain"></a>论文阅读MeHLDT: A multielement hash lock data transfer mechanism for on‑chain and off‑chain</h3><p>研究区块链链上链下数据交互如何保证安全性，原子性。</p><h3 id="Hashed-Time-Lock-Contract-HTLC"><a href="#Hashed-Time-Lock-Contract-HTLC" class="headerlink" title="Hashed Time-Lock Contract (HTLC)"></a>Hashed Time-Lock Contract (HTLC)</h3><blockquote><p>哈希时间锁使多个用户之间「条件支付」（Conditional Payment）能以去中心化、无需第三方受信任中介的方式完成，这些用户不一定在同一条区块链上。哈希时间锁可以组成多跳支付 (即双方在交易过程中可藉助多个中间节点来完成交易）和原子交换（Atomic Swap），是链下支付通道和跨链交易的基础，并在央行数字货币跨境支付、证券结算以及去中心化交易所中有广泛应用。</p></blockquote><ul><li>HashLock(哈希锁)：限制资金支出的功能，直到一些数据被公开披露(例如：加密证明)；证明也可以称为<code>哈希锁原像</code>。<code>哈希锁原像</code>是用来生成哈希锁、并随后解锁资金的信息。</li><li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.jianshu.com/p/c08c3525910d">TimeLock(时间锁)</a>：限制资金直到未来的指定时间才能进行支出的功能；在bitcoin中有实现，例如：<code>CheckLockTimeVerify</code>或者<code>CheckSequenceVerify</code></li></ul><blockquote><p>将区块链 A 中用户 X 拥有的资产 M 与区块链 B 中用户 Y 拥有的资产 N 进行交换，如下图<br>Step 1. user X hashes s to generate H = Hash(s);<br>Step 2. user X uses H to lock M on blockchain A for a duration of T;<br>Step 3. user Y similarly locks N with H (which is public) on blockchain B for T/2;<br>Step 4. user X unlocks N on blockchain B by presenting s (the hash must match H) for a duration of T/2;<br>Step 5. user Y similarly unlocks M on blockchain A by providing s (now public) after X’s statement but within T.</p></blockquote><p><img src="images/MeHLDT/image-20230811163118729.png" alt="image-20230811163118729"></p>]]></content>
    
    
    
    <tags>
      
      <tag>paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DKG</title>
    <link href="/2023/07/07/DKG/"/>
    <url>/2023/07/07/DKG/</url>
    
    <content type="html"><![CDATA[<h2 id="分布式密钥生成"><a href="#分布式密钥生成" class="headerlink" title="分布式密钥生成"></a>分布式密钥生成</h2><blockquote><p>Distributed key generation is a main component of threshold cryptosystems. It allows a set of n servers to jointly generate a pair of public and private keys according to the distribution defined by the underlying cryptosystem without having to ever compute, reconstruct, or store the secret key in any single lo cation and without assuming any trusted party (dealer). While the public key is output in the clear, the private key is maintained as a (virtual) secret shared via a threshold scheme.</p></blockquote><h2 id="DKG目标"><a href="#DKG目标" class="headerlink" title="DKG目标"></a>DKG目标</h2><blockquote><p>在无可信中心的情况下为一组参与者生成对应于一个主公钥的私钥份额</p><p>不希望由任何人指定私钥，而是每个参与者都提供一个随机性，有恶意参与者</p></blockquote><p><img src="/images/DKG/image-20230708103947867.png" alt="image-20230708103947867"></p><p><img src="/images/DKG/image-20230708104436980.png" alt="image-20230708104436980"></p><p><img src="/images/DKG/image-20230708104423802.png" alt="image-20230708104423802"></p><h2 id="一、DKG是什么DKG"><a href="#一、DKG是什么DKG" class="headerlink" title="一、DKG是什么DKG"></a>一、DKG是什么DKG</h2><p>(分布式密钥生成)提供了一种去中心化的方法,使各个参与方在不相互信任的情况下生成共享密钥,以确保安全通信和多方参与的机密性。</p><p>DKG技术的关键思想是使用多方计算( secure multiparty computation)和秘钥共享({ secretsharing)的概念。</p><ul><li>秘钥共享则将密钥分割成多个部分,每个参与方只持有其中的一部分,需要达到一定國值オ能重构出完整的钥;</li><li>多方计算使得多个参与方能够共同执行计算任务,而不泄露私有输入</li></ul><p>DKG技术在「需要多方参与」和「分布式信任」的领域得到应用:</p><p>1.共识协议:DKG可用于生成共识协议所需的密钥,确保在分布式环境中节点之间的通信和交互的安全性和可靠性。例如, Algorand和 Finity等区块链项目使用DKG来生成节点的共识密钥,从而实现拜占庭容错和安全的共识算法</p><p>2.密钥管理和安全多方计算:DKG技术可用于密钥管理方案中,以生成和分发用于加密通信和身份验证的密钥。此外,它也可以用于安全多方计算场景( Secure MultipartyComputation,SMC),使多个参与方能够在不泄露私有数据的情况下进行协作计算</p><p>3.分布式存储系统:DKG可用于分布式存储系统中,用于生成和管理用于数据保护和访问控制的密钥,以确保数据的机密性和完整性。</p><p>4.门限密码学:DKG是门限密码学方案中的关键组成部分,例如门限签名方案和门限加密方案。它用于在门限数量的参与方之间生成共享密钥,从而实现高度安全和鲁棒的密码方案。</p><p><img src="/images/DKG/image-20230710171932661.png" alt="image-20230710171932661"></p><p><img src="/images/DKG/image-20230711143932669.png" alt="image-20230711143932669"></p><blockquote><p>该段描述涉及阈值 Schnorr 签名方案中的步骤，解释了参与方如何运行 JF-DKG 协议来生成一次性秘密 k 的秘密分享以及公共值 r = gk。具体的步骤如下：</p><ol><li>参与方执行 JF-DKG 协议：参与方执行 JF-DKG 协议的一个实例，生成一次性秘密 k 的秘密分享和公共值 r = gk。在这一步中，参与方 Pi ∈ QUAL 生成一个秘密分享的份额 ui，对应于一次性秘密 k。这些份额 ui 本身也是通过秘密分享方案生成的。</li><li>计算挑战值 c：每个参与方独立地计算挑战值 c = H(m, r)，其中 H 是一个哈希函数。这个挑战值将用于后续的签名计算。</li><li>广播秘密份额分享：QUAL ∩ QUAL’ 中的参与方 Pi 广播自己的秘密份额分享 si = ui + czi。其中，zi 是该参与方持有的一次性秘密 k 的份额。这些份额分享可以通过验证来验证其正确性。</li><li>验证和重构：每个参与方 Pi 在广播份额分享时，同时也广播验证值 Xi0 = yi = gzi 和 Ki0 = ri = gui。这些验证值是在初始的密钥生成 JF-DKG 协议和生成 r 和 k 的 JF-DKG 协议中由参与方广播的。其他参与方可以通过验证这些值来验证份额分享的正确性。</li><li><ul><li>如果验证失败，表示一些参与方的份额分享不正确。在这种情况下，参与方需要重构 xi 和 ki 的 Feldman 秘密分享，并公开计算 si 的值。</li><li>对于 QUAL 中的参与方，但不在 QUAL’ 中的参与方，其份额 zi 会被公开重构。这些参与方被认为是“不良参与方”。对于这些参与方，si 的值被设置为 czi。</li></ul></li><li>计算最终的签名值 s：最终的签名值 s 被计算为 s = ∑ i∈QUAL si。这样，秘密 s 可以像 Feldman-VSS 协议中那样有效地进行重构。</li></ol><p>通过执行以上步骤，阈值 Schnorr 签名方案中的参与方可以生成有效的签名。每个参与方根据自己持有的一次性秘密份额 zi 和挑战值 c 计算出自己的份额分享 si，并通过验证和重构确保了份额分享的正确性。最终，所有参与方的份额分享被合并计算出签名值 s。这样，阈值 Schnorr 签名方案就完成了消息 m 的签名过程。</p></blockquote><p><img src="/images/DKG/image-20230711155256538.png" alt="image-20230711155256538"></p><p><img src="/images/DKG/image-20230711155003494.png" alt="image-20230711155003494"></p><blockquote><p>论文 <a href="https://www.usenix.org/conference/usenixsecurity23/presentation/das">https://www.usenix.org/conference/usenixsecurity23/presentation/das</a></p><p><img src="/images/DKG/image-20231101155230491.png" alt="image-20231101155230491"></p></blockquote><p><img src="/images/DKG/image-20230712163150262.png" alt="image-20230712163150262"></p><h2 id="拉格朗日插值"><a href="#拉格朗日插值" class="headerlink" title="拉格朗日插值"></a>拉格朗日插值</h2><p><img src="/images/DKG/image-20230712183325531.png" alt="image-20230712183325531"></p><p><img src="/images/DKG/image-20230712184604273.png" alt="image-20230712184604273"><img src="/images/DKG/image-20230712184616968.png" alt="image-20230712184616968"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Apply_for_Ph.D.</title>
    <link href="/2023/06/29/Apply-for-Ph-D/"/>
    <url>/2023/06/29/Apply-for-Ph-D/</url>
    
    <content type="html"><![CDATA[<h2 id="材料准备"><a href="#材料准备" class="headerlink" title="材料准备"></a>材料准备</h2><ol><li>中英文简历</li><li>个人主页</li><li>材料: 本科成绩单(中英)、研究生成绩单(中英,待扫描)、在读证明(中英,待扫描)、学术证明材料(竞赛奖状等)</li></ol><h2 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h2><h4 id="套路"><a href="#套路" class="headerlink" title="套路"></a>套路</h4><ol><li>Self introduction</li><li>Why do you want to study in our University?</li><li>Tell me something about your research experience/what did you do/talk about yourself</li><li>what is your career goal/tell me about your long term goal/what do you want to do with your phd/why do you want the phd</li><li>Why do you think you can complete it?</li><li>Have you applied to other research programs?</li><li>Do you have any other questions?</li><li>what are you interested in/What research do you want to do</li></ol><h3 id="偏学术"><a href="#偏学术" class="headerlink" title="偏学术"></a>偏学术</h3><ol><li><p>why are you interested in our program or my research？</p></li><li><p>The project you want to do and what experience makes you want to do it.</p></li><li><p>Your future research plan</p></li><li><p>Please describe a recent research project you did.</p></li></ol><h3 id="technical-presentation"><a href="#technical-presentation" class="headerlink" title="technical presentation"></a>technical presentation</h3><p>做PPT，第一部分已完成的研究，第二部分未来计划的方向</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>like_slimchain</title>
    <link href="/2023/05/24/like-slimchain/"/>
    <url>/2023/05/24/like-slimchain/</url>
    
    <content type="html"><![CDATA[<h4 id="更改区块链执行架构"><a href="#更改区块链执行架构" class="headerlink" title="更改区块链执行架构"></a>更改区块链执行架构</h4><p><img src="/images/like-slimchain/image-20230524103247037.png" alt="image-20230524103247037"></p><p>BIDL：<a href="http://xintelligence.pro/archives/754">http://xintelligence.pro/archives/754</a></p><p><img src="/images/like-slimchain/image-20230524103351434.png" alt="image-20230524103351434"></p><p><img src="/images/like-slimchain/image-20230622182300137.png" alt="image-20230622182300137"></p><p>NeuChain: A Fast Permissioned Blockchain System with Deterministic Ordering</p><p>NeuChain：具有确定性排序的快速许可区块链系统（VLDB 2022）</p><p>概述：这篇论文的方法是基于确定性执行的无序快速许可区块链系统的设计和实现。论文提出了一个执行-验证（EV）的架构，通过给每个交易分配一个全局唯一的ID来隐式地确定交易的执行顺序，从而消除了昂贵的排序阶段。论文还设计和实现了一个基于EV架构的区块链原型NeuChain，采用了一些优化技术，如异步区块生成和流水线，并提供了一些安全机制来抵御恶意攻击。</p><p>Code :<a href="https://github.com/iDC-NEU/NeuChain">https://github.com/iDC-NEU/NeuChain</a></p><p>相关知识：</p><ol><li><p>strict serializability：Strict serializability is a strong level of isolation that ensures that the outcome of transactions executed in parallel is equal to one in which the transactions had been executed atomically and sequentially in the order apparent to an external observer.</p></li><li><p>确定性排序是一种数据库技术，它可以保证在不同的副本上执行相同的事务时，得到相同的结果。确定性排序可以避免使用昂贵的复制和提交协议，提高数据库的性能和可扩展性。确定性排序的一种方法是给每个事务分配一个全局唯一的ID，根据这个ID来隐式地确定事务的执行顺序。</p></li><li><p>并发控制协议：1）两阶段Two-phase；2）Optimistic Concurrency Control (OCC)；3）Serializable Snapshot Isolation (SSI)</p></li></ol><p>相关论文：</p><p>Xia H, Chen J, Ma N, et al. <strong>Efficient Execution of Blockchain Transactions Through Deterministic Concurrency Control</strong>[C]//International Conference on Database Systems for Advanced Applications. Cham: Springer Nature Switzerland, 2023: 509-518.</p><p>注：链下执行系统的设计时可能会考虑到分布式提交协议，并发控制等问题</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>system</title>
    <link href="/2023/05/17/privateSC/"/>
    <url>/2023/05/17/privateSC/</url>
    
    <content type="html"><![CDATA[<blockquote><p>SoK: Layer-Two Blockchain Protocols</p><p>Teechain [47] and Teechan [48] synchronize payments across channels using TEEs. TEE enable expressive and off-chain smart contracts on restricted Bitcoinbased blockchain [49]. Tesseract [91] proposes to construct a scalable TEE based real-time cross-chain cryptocurrency exchange. In relation to light clients in Bitcoin, BITE [92] leverages TEEs to enable full nodes to serve privacy-preserving requests from light clients, when used in combination with other private information retrieval and side-channel protection techniques. ZLiTE [93] also leverages TEEs to provide privacy-preserving light clients for Zcash, whereby light clients operate in conjunction with a TEE-enabled server (e.g., running Intel SGX [89]).</p><p>A survey of Layer-two blockchain protocols</p><p>Teechan (Lind et al., 2016) uses TEEs to enable two mutually distrusting nodes to transact with each other. Here, a channel is set up between the two nodes by exchanging secrets via their TEEs. As long as the channel is open, the nodes can exchange funds with each other in a peer-to-peer manner using TEE-supported operations; even without involving the parent Bitcoin blockchain. The TEEs bear the responsibility to maintain and update the channel’s state securely throughout the channel’s lifetime. Upon channel termination, the TEEs create a Bitcoin transaction to be added to the parent chain. During the entire lifetime of such a channel, only two transactions are reflected on-chain; one for channel establishment using a 2-of-2 multisig Bitcoin address and the other for channel closure. To summarize, Teechan reduces the load on the parent chain and increases transaction throughput among distrusting nodes. Teechain Lind et al. (2019) is another such solution that executes off-chain transactions asynchronously with the main chain. Teechain employs TEE-protected treasuries to preserve the correct channel state. Teechain forms a chain of committee that holds replicated states of treasuries to handle treasury failures. Some other prominent solutions leveraging features of TEEs are Tesseract (Bentov et al., 2019), BITE (Matetic et al., 2019), and ZLiTE (Wüst et al., 2019). Tesseract is a TEE-based cryptocurrency exchange, BITE focuses on the privacy of Bitcoin lightweight clients, and ZLiTE improves the privacy of Zcash lightweight clients by involving TEEequipped servers. Nevertheless, all TEE-based solutions rely upon the integrity of the TEEs while TEEs have their own vulnerabilities and concerns (Nilsson et al., 2020; Fei et al., 2021).</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Stateless</title>
    <link href="/2023/05/15/Stateless/"/>
    <url>/2023/05/15/Stateless/</url>
    
    <content type="html"><![CDATA[<h1 id="Giving-State-to-the-Stateless-Augmenting-Trustworthy-Computation-with-Ledgers"><a href="#Giving-State-to-the-Stateless-Augmenting-Trustworthy-Computation-with-Ledgers" class="headerlink" title="Giving State to the Stateless: Augmenting Trustworthy Computation with Ledgers"></a>Giving State to the Stateless: Augmenting Trustworthy Computation with Ledgers</h1><ol><li><p>来自Ekiden评价,该论文引用为[40]</p><blockquote><p>Thus, while it’s tempting to use a blockchain to checkpoint a TEE’s state (e.g. [40]), the lack of a reliable timer renders it tricky for a TEE to ascertain an up-to-date view of the blockchain.</p><p>因此，虽然很想使用区块链来检查 TEE 的状态（例如 [40]），但由于缺乏可靠的计时器，TEE 很难确定区块链的最新视图。</p><p>The missing timer also makes it hard for TEEs to verify that an item has been persisted in the blockchain, i.e. to establish “proofs of publication,” as coined by [40]. However [40] doesn’t consider threats caused by lack of trustworthy time in TEEs—e.g., injection of old, fake, easily minable blocks—that are critical in PoW-based blockchains. One of our contributions is a general, time-based proof-of-publication protocol that is secure against network adversary delaying clock read, as we now briefly explain.</p><p>缺少计时器还使 TEE 很难验证某个项目是否已保存在区块链中，即建立“发布证明”，如 [40] 所创造的那样。然而，[40] 没有考虑因 TEE 中缺乏可信时间而造成的威胁——例如，注入旧的、假的、容易开采的区块——这在基于 PoW 的区块链中至关重要。我们的贡献之一是一种通用的、基于时间的发布证明协议，该协议可以防止网络对手延迟时钟读取，正如我们现在简要解释的那样。</p><p>The idea of combining ledgers with trusted hardware for smart contract execution is briefly mentioned in Hawk and also treated in [21], [40]. [21] combines blockchain with TEE to achieve one-time programs that resemble smart contracts but only aim for a restricted functionality (one-shot MPC with N parties providing input). [40] includes a basic prototype, but omits critical system design issues; e.g., its permissionless “proof-of-publication” overlooks the technical difficulties arising from lack of trusted wall-clock time in enclaves.</p><p>Hawk 中简要提到了将分类账与可信硬件相结合以执行智能合约的想法，并在 [21]、[40] 中进行了处理。 [21] 将区块链与 TEE 相结合，以实现类似于智能合约但仅针对受限功能的一次性程序（一次性 MPC，N 方提供输入）。 [40] 包括一个基本原型，但省略了关键的系统设计问题；例如，其未经许可的“发布证明”忽略了由于飞地中缺乏可信的挂钟时间而产生的技术困难。</p></blockquote></li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>blockchain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ethereum_Graph_Analysis</title>
    <link href="/2023/05/15/Ethereum-Graph-Analysis/"/>
    <url>/2023/05/15/Ethereum-Graph-Analysis/</url>
    
    <content type="html"><![CDATA[<h2 id="图解以太坊"><a href="#图解以太坊" class="headerlink" title="图解以太坊"></a>图解以太坊</h2><ol><li>以太坊上智能合约超800万，但人们不是特别熟悉</li><li>金融类智能合约调用率高</li><li>用户更喜欢转账而不是调用智能合约</li></ol><h3 id="图、拓扑"><a href="#图、拓扑" class="headerlink" title="图、拓扑"></a>图、拓扑</h3><ul><li>聚类系数</li><li>强连通分量</li><li>弱</li></ul>]]></content>
    
    
    <categories>
      
      <category>blockchain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>layer2_sum</title>
    <link href="/2023/04/25/layer2-sum/"/>
    <url>/2023/04/25/layer2-sum/</url>
    
    <content type="html"><![CDATA[<h2 id="layer2-top项目"><a href="#layer2-top项目" class="headerlink" title="layer2 top项目"></a>layer2 top项目</h2><p><a href="https://l2beat.com/scaling/tvl?view=risk">https://l2beat.com/scaling/tvl?view=risk</a></p><p><img src="/images/layer2-sum/image-20230622184644000.png" alt="image-20230622184644000"></p><h2 id="layer2扩容方案"><a href="#layer2扩容方案" class="headerlink" title="layer2扩容方案"></a>layer2扩容方案</h2><p>layer2 二层解决方案：基本想法是链下计算/执行，结果上链；离线批量处理。直接从第一层以太坊共识中获得安全性。</p><p>不同的layer2方案 会在安全性、扩容效率、去中心化程度、通用性之间寻找平衡。</p><p><a href="https://www.odaily.news/post/5182589">LD Research：一文详解以太坊扩容全方案</a></p><h4 id="侧链"><a href="#侧链" class="headerlink" title="侧链"></a>侧链</h4><p>侧链通常是选择牺牲了一些去中心化或安全性来实现高吞吐量。</p><blockquote><p>侧链主要是通过双向锚定的跨链桥（two way pegged cross chain bridge）来实现与主网的链接、以及互相操作（这个概念我们很快就会细说）。而这里所谓的双向锚定式主要是指支持资产的双向锚定，即资产在主链与侧链之间的互转。不过这里需要注意一下，实际上资产并非实现真正意义上的转移，只是通过”一条链锁定，另一条链铸造相同面额资产“的方式来进行”跨链“。但凡是架设双向锚定跨链桥的项目都可以被视为侧链。</p></blockquote><h3 id="理解以太坊的Layer-2扩容解决方案：状态通道（State-Channels）、Plasma-和-Truebit"><a href="#理解以太坊的Layer-2扩容解决方案：状态通道（State-Channels）、Plasma-和-Truebit" class="headerlink" title="理解以太坊的Layer 2扩容解决方案：状态通道（State Channels）、Plasma 和 Truebit"></a><a href="https://www.bcskill.com/index.php/archives/965.html">理解以太坊的Layer 2扩容解决方案：状态通道（State Channels）、Plasma 和 Truebit</a></h3><h4 id="状态通道"><a href="#状态通道" class="headerlink" title="状态通道"></a>状态通道</h4><p><a href="https://www.nichanank.com/blog/2018/9/27/scalability-pt-2-state-channels-counterfactual-instantiation"><strong>Scalability pt 2: State Channels &amp; Counterfactual Instantiation</strong></a></p><h2 id="Rollup"><a href="#Rollup" class="headerlink" title="Rollup"></a>Rollup</h2><p><a href="https://medium.com/cortexlabs/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82%E4%BB%80%E4%B9%88%E6%98%AFzk-rollup-8c0200a4dfab">一文读懂什么是ZK-Rollup?</a></p><p><a href="https://zhuanlan.zhihu.com/p/551777466">https://zhuanlan.zhihu.com/p/551777466</a></p><p>(推荐)<a href="https://mp.weixin.qq.com/s/GT4Yfw8VPhBikME4mKCTNQ">https://mp.weixin.qq.com/s/GT4Yfw8VPhBikME4mKCTNQ</a></p><p>Rollup方案目前的代表项目主要有Polygon、Arbitrum、StarkEx、Optimism、zkSync、Aztec、StarkNet等。</p><p><img src="https://pic1.zhimg.com/80/v2-cba9ed08a4e1b5481471c30b55b7bcfc_720w.webp" alt="img"></p><p><img src="/images/layer2-sum/image-20230622100305206.png" alt="image-20230622100305206"></p><p><img src="/images/layer2-sum/image-20230622100457107.png" alt="image-20230622100457107"></p><blockquote><p>以太坊达成共识过程？？</p></blockquote><p><img src="/images/layer2-sum/image-20230622100941551.png" alt="image-20230622100941551"></p><blockquote><p>State Channel : 用户首先将资金锁在主链的智能合约中，在layer2上复制出相应的资产，在layer2上进行各种交易，不占用主链资源，直到参与方都同意结束交易，state Channel将交易终止信息发回layer1,layer1根据交易结果完成资产分配。</p><p>Plasma ：向主链发送的内容为初始和结束的状态根</p><p>以上用欺诈证明，假设layer2中交易是真实的。</p><p>validium：每个区块结束之后都向主链发送初始和结束的状态根 + 有效性证明（零知识证明），智能合约去验证有效性证明，完成对layer2的一个信任，用户可以从主链的智能合约里面去提款了。</p><p>rollup :向主链发送的 是 <strong>区块状态根 + 压缩后的交易数据</strong> （安全性更高，但占用主链空间）</p><p>zk rollup : 用户直接通过主链智能合约提款</p></blockquote><p><img src="/images/layer2-sum/image-20230622102719216.png" alt="image-20230622102719216"></p><p><img src="/images/layer2-sum/image-20230622104053148.png" alt="image-20230622104053148"></p><blockquote><p><strong>将资金存入rollup</strong></p><ol><li>用户将资金存入layer1的智能合约</li><li>相应的在layer2链上创建对应的账户和余额，layer2中有很多账户，账户和余额组织成一颗默克尔树，得到root,保证账户余额不会被更改</li></ol><p><strong>交易</strong> ——中继者 coordinator</p><ol><li>用户创建交易，发送给中继者，中继者验证余额树，账户地址等等</li><li>中继者收到一定数量的交易，创建批处理，对ZK -proof电路编译一堆输入，得到证明（j交易树，merkel-proof）</li><li>上传到主链的rollup合约状态</li></ol></blockquote><p><img src="/images/layer2-sum/image-20230622104542137.png" alt="image-20230622104542137"></p><p><img src="/images/layer2-sum/image-20230622110210365.png" alt="image-20230622110210365"></p><blockquote><p>前状态根：更新之前的账户余额树，用账户的merkle证明检查发送者的正确性（zk 电路）</p><p>更新账户余额树：发送者的余额和随机数被改变，整个树根被改变（zk电路）</p><p>每次交易都会产生以上两个证明，每一次从更新的状态根中产生后续状态根证明</p></blockquote><p><img src="/images/layer2-sum/image-20230622110349902.png" alt="image-20230622110349902"></p><blockquote><p>每个更新的状态根反映了每一次只有一件事发生变化。从发送者产生更新前的状态根，从接收者产生后续的状态根。</p><p><strong>电路遍历这个批次里的交易去创造更新后的链状态，产生最后的余额树状态根，为下一个区块的初始状态根。</strong></p><p>发送给Layer1上智能合约（数据 + 证明）前状态根和当前树匹配、验证中间状态根、后状态根，根据后状态根更新主链的状态、</p><p>取款（从layer2提款到主链）：用户将要提的资金数发送到余额树索引为0的账户，在layer2销毁资金，当这个交易被上传主链，主链智能合约将执行提款请求。</p></blockquote><p>zk rollup 不是只能执行交易，需要更加普适的功能，需要部署虚拟机，zk-VM，统一处理交易和智能合约的执行。如果zk-VM和EVM兼容，之前在以太坊上的应用很容易迁移到rollup上，但是目前还没有很好的解决。</p><p>兼容性体现在：共识层、字节码层、语言层（不懂）</p><blockquote><p>翻译EVM字节码，运行到zk-EVM上</p><p>翻译solidity语言</p></blockquote><p><img src="/images/layer2-sum/image-20230622144105314.png" alt="image-20230622144105314"></p><h4 id="layer2痛点"><a href="#layer2痛点" class="headerlink" title="layer2痛点"></a>layer2痛点</h4><p><img src="/images/layer2-sum/image-20230622145415842.png" alt="image-20230622145415842"></p><p><img src="/images/layer2-sum/image-20230622145659105.png" alt="image-20230622145659105"></p><p>为EVM每个操作码设计zk电路？</p><p>佩德森承诺</p><p>zk-rollup主要瓶颈：零知识证明的生成速度，技术突破，，，</p><h2 id="零知识证明在币圈"><a href="#零知识证明在币圈" class="headerlink" title="零知识证明在币圈"></a>零知识证明在币圈</h2><p><img src="/images/layer2-sum/image-20230602144922178.png" alt="image-20230602144922178"></p><p><img src="/images/layer2-sum/image-20230602145001327.png" alt="image-20230602145001327"></p><p><img src="/images/layer2-sum/image-20230602145156549.png" alt="image-20230602145156549"></p><p><img src="/images/layer2-sum/image-20230602145347083.png" alt="image-20230602145347083"></p><p><img src="/images/layer2-sum/image-20230602145845986.png" alt="image-20230602145845986"></p><p><img src="/images/layer2-sum/image-20230602150431099.png" alt="image-20230602150431099"></p><p><img src="/images/layer2-sum/image-20230602150616688.png" alt="image-20230602150616688"></p><p>What are the differences and connections between the following papers, what is researched, and what is the relationship with blockchain scaling, please analyze their core shortcomings and give suggestions for future research:</p><p>1.SlimChain: Scaling Blockchain Transactions through Off-Chain Storage and Parallel Processing</p><p>2.Ekiden: A Platform for Confidentiality-Preserving, Trustworthy, and Performant Smart Contracts</p><p>3.FASTKITTEN: Practical Smart Contracts on Bitcoin</p><p>4.POSE: Practical Off-chain Smart Contract Execution</p><p>5.Giving State to the Stateless: Augmenting Trustworthy Computation with Ledgers</p><h1 id="不完整的汇总指南"><a href="#不完整的汇总指南" class="headerlink" title="不完整的汇总指南"></a>不完整的汇总指南</h1><p>2021年1月5日<a href="https://vitalik.ca/index.html">查看所有帖子</a></p><p><a href="https://vitalik.ca/general/2021/01/05/rollup.html">https://vitalik.ca/general/2021/01/05/rollup.html</a></p><p>Rollup 在以太坊社区非常流行，并且在可预见的未来将<a href="https://ethereum-magicians.org/t/a-rollup-centric-ethereum-roadmap/4698">成为</a>以太坊的关键可扩展性解决方案。但这项技术到底是什么？您对它有何期望？您将如何使用它？这篇文章将尝试回答其中一些关键问题。</p><h2 id="背景：什么是第-1-层和第-2-层缩放？"><a href="#背景：什么是第-1-层和第-2-层缩放？" class="headerlink" title="背景：什么是第 1 层和第 2 层缩放？"></a>背景：什么是第 1 层和第 2 层缩放？</h2><p><strong>有两种方法可以扩展区块链生态系统。首先，可以让区块链本身具有更高的交易能力</strong>。这项技术的主要挑战是，具有“更大区块”的区块链本质上更难以验证，并且可能变得更加中心化。为了避免此类风险，开发人员可以提高客户端软件的效率，或者更可持续地使用<a href="https://eth.wiki/sharding/Sharding-FAQs">分片等</a>技术，将构建和验证链的工作分散到多个节点上；<a href="https://ethereum.org/en/eth2">被称为“eth2”的项目</a>目前正在构建对以太坊的升级。</p><p><strong>其次，您可以改变使用区块链的方式</strong>。用户不是将<em>所有</em>活动直接放在区块链上，而是通过“第 2 层”协议在链外执行大部分活动。链上有一个智能合约，它只有两个任务：处理存款和取款，以及验证链下发生的一切都遵循规则的证据。进行这些证明的方法有多种，但它们都有一个共同的特点，即在链上验证证明比在链下进行原始计算要便宜得多。</p><h2 id="状态通道、等离子、汇总"><a href="#状态通道、等离子、汇总" class="headerlink" title="状态通道、等离子、汇总"></a>状态通道、等离子、汇总</h2><p>Layer-2 扩展的三种主要类型是<a href="https://statechannels.org/">状态通道</a>、<a href="http://plasma.io/">Plasma</a>和 Rollups。它们是三种不同的范式，具有不同的优点和缺点，在这一点上，我们相当有信心所有的第 2 层缩放都大致属于这三个类别（尽管边缘存在命名争议，例如参见“validium” <a href="https://medium.com/starkware/volition-and-the-emerging-data-availability-spectrum-87e8bfa09bb">）</a>。</p><h3 id="渠道如何运作？"><a href="#渠道如何运作？" class="headerlink" title="渠道如何运作？"></a>渠道如何运作？</h3><p><em>另请参阅： https: <a href="https://www.jeffcoleman.ca/state-channels">//www.jeffcoleman.ca/state-channels</a>和<a href="https://statechannels.org/">statechannels.org</a></em></p><p>想象一下，Alice 向 Bob 提供互联网连接，作为交换，Bob 向她支付每兆字节 0.001 美元。Alice 和 Bob 使用以下第 2 层方案，而不是为每次付款进行交易。</p><p>首先，Bob 将 1 美元（或一些 ETH 或稳定币等价物）放入智能合约中。为了向 Alice 进行第一笔付款，Bob 签署了一张“票据”（一条链外消息），上面简单地写着“0.001 美元”，然后将其发送给 Alice。为了进行第二次付款，鲍勃将签署另一张写有“$0.002”的票据，并将其发送给爱丽丝。依此类推，根据需要支付尽可能多的款项。当爱丽丝和鲍勃完成交易时，爱丽丝可以将价值最高的票发布到链上，并包含在她自己的另一个签名中。智能合约验证爱丽丝和鲍勃的签名，向爱丽丝支付鲍勃票上的金额，并将其余部分返还给鲍勃。如果Alice不愿意关闭通道（由于恶意或技术故障），Bob可以启动提现期（例如7天）；如果 Alice 没有在该时间内提供票证，</p><p>这项技术非常强大：可以调整它来处理双向支付、智能合约关系（例如，Alice 和 Bob 在通道内制定金融合约）和组合（如果 Alice 和 Bob 有一个开放通道，Bob 和 Charlie 也有开放通道）爱丽丝可以与查理进行不信任的互动）。但渠道能做的事情是有限的。通道不能用于将资金从链下发送给还不是参与者的人。通道不能用于表示没有明确逻辑所有者的对象（例如 Uniswap）。而渠道，特别是如果用来做比简单的定期支付更复杂的事情，需要锁定大量资金。</p><h3 id="Plasma如何工作？"><a href="#Plasma如何工作？" class="headerlink" title="Plasma如何工作？"></a>Plasma如何工作？</h3><p><em>另请参阅：<a href="http://plasma.io/plasma-deprecated.pdf">原始 Plasma 纸</a>和<a href="https://ethresear.ch/t/plasma-cash-plasma-with-much-less-per-user-data-checking/1298">Plasma Cash</a>。</em></p><p>为了存入资产，用户将其发送到管理 Plasma 链的智能合约。美丽链链为该资产分配一个新的唯一 ID（例如 537）。每个 Plasma 链都有一个<em>运营商</em>（这可以是中心化参与者、多重签名，或者更复杂的东西，如 PoS 或 DPoS）。每个时间间隔（可以是 15 秒，或一小时，或介于两者之间的任何时间），操作员都会生成一个“批次”，其中包含他们在链下收到的所有 Plasma 交易。他们生成一棵 Merkle 树，其中在<code>X</code>树中的每个索引处，<code>X</code>如果存在这样的交易，则存在传输资产 ID 的交易，否则该叶子为零。他们将这棵树的 Merkle 根发布到链上。他们还发送每个索引的 Merkle 分支<code>X</code>该资产的当前所有者。要提取资产，用户需要发布向他们发送资产的最近交易的 Merkle 分支。合约开始一个挑战期，在此期间任何人都可以尝试使用其他 Merkle 分支，通过证明 (i) 发送者在发送资产时并不拥有该资产，或者 (ii) 他们发送了资产，从而使退出无效稍后的某个时间点给其他人。如果（例如）7天内没有人证明退出是欺诈性的，则用户可以提取资产。</p><p>Plasma 提供了比通道更强大的属性：您可以将资产发送给从未属于系统的参与者，并且资本要求要低得多。但这是有代价的：在“正常操作”期间，通道不需要任何数据就可以上链，但 Plasma 要求每个链定期发布一个哈希值。此外，Plasma 传输不是即时的：您必须等待间隔结束并发布区块。</p><p>此外，Plasma 和通道有一个共同的关键弱点：它们安全背后的博弈论依赖于这样的想法：两个系统控制的每个对象都有一些逻辑“所有者”。如果该所有者不关心他们的资产，则可能会导致涉及该资产的“无效”结果。这对于许多应用程序来说没问题，但对于许多其他应用程序（例如 Uniswap）来说却是一个问题。即使是在未经所有者同意的情况下可以更改对象状态的系统（例如基于帐户的系统，您可以在其中<em>增加</em>未经同意的某人的余额）不适用于 Plasma。这一切都意味着在任何现实的等离子或通道部署中都需要大量的“特定于应用程序的推理”，并且不可能制作仅模拟完整以太坊环境（或“EVM”）的等离子或通道系统。为了解决这个问题，我们需要……汇总。</p><h3 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h3><p><em>另请参阅：<a href="https://docs.ethhub.io/ethereum-roadmap/layer-2-scaling/optimistic_rollups/">EthHub 关于乐观汇总</a>和<a href="https://docs.ethhub.io/ethereum-roadmap/layer-2-scaling/zk-rollups/">ZK 汇总</a>。</em></p><p>Plasma 和通道是“完整”的第 2 层方案，因为它们试图将数据<em>和</em>计算移至链下。然而，<a href="https://www.youtube.com/watch?v=OJT_fR7wexw">围绕数据可用性的基本博弈论问题</a>意味着不可能对所有应用程序安全地执行此操作。Plasma 和通道通过依赖明确的所有者概念来解决这个问题，但这阻止了它们完全通用。另一方面，Rollup 是一种“混合”第 2 层方案。<strong>汇总将计算（和状态存储）移至链外，但将每个交易的一些数据保留在链上</strong>。为了提高效率，他们使用了一整套奇特的压缩技巧来用<em>计算代替数据</em>只要有可能。结果是系统的可扩展性仍然受到底层区块链数据带宽的限制，但比率非常有利：以太坊基础层 ERC20 代币传输成本约为 45000 Gas，而汇总中的 ERC20 代币传输需要 16字节的链上空间和低于 300 Gas 的成本。</p><p>数据在链上这一事实是关键（注意：将数据“放在 IPFS 上”是行不通的<em>，</em>因为 IPFS 无法就任何给定数据是否可用提供<em>共识；数据**必须</em>放在区块链上）。将数据放在链上并就这一事实达成共识，允许任何人在本地处理汇总中的所有操作（如果他们愿意），从而允许他们检测欺诈、发起提款或亲自开始生成交易批次。缺乏数据可用性问题意味着恶意或离线操作员可以做的事情<em>更少</em>危害（例如，它们不能导致 1 周的延迟），为有权发布批次的人开辟了更大的设计空间，并使汇总更容易推理。最重要的是，缺乏数据可用性问题意味着不再需要将资产映射到所有者，这就是以太坊社区对汇总比以前的第 2 层扩展形式更感兴趣的关键原因：汇总<strong>是完全通用，甚至可以在 rollup 中运行 EVM，从而允许现有的以太坊应用程序迁移到 rollup，几乎不需要编写任何新代码</strong>。</p><h2 id="好的，那么汇总到底是如何工作的呢？"><a href="#好的，那么汇总到底是如何工作的呢？" class="headerlink" title="好的，那么汇总到底是如何工作的呢？"></a>好的，那么汇总到底是如何工作的呢？</h2><p>链上有一个智能合约，它维护一个<strong>状态根</strong>：rollup 状态的 Merkle 根（意思是，在 rollup“内部”的账户余额、合约代码等）。</p><p><img src="https://vitalik.ca/images/rollup-files/diag1.png" alt="img"></p><p>任何人都可以发布一批<strong>，</strong>即高度压缩形式的交易集合以及先前的状态根和新的状态根（处理交易<em>后的Merkle 根）。</em>合约检查批次中的先前状态根是否与其当前状态根匹配；如果是，它将状态根切换到新的状态根。</p><p><img src="https://vitalik.ca/images/rollup-files/diag2.png" alt="img"></p><p>为了支持存款和取款，我们添加了输入或输出位于汇总状态“外部”的交易的功能。如果一个批次有来自外部的输入，则提交该批次的交易也需要将这些资产转移到汇总合约中。如果一个批次有输出到外部，那么在处理该批次时，智能合约将启动这些提款。</p><p>就是这样！除了一个主要细节：<strong>如何知道批次中的后状态根是否正确？</strong>如果有人可以提交具有任何后状态根的批次而不产生任何后果，他们可以将汇总内的所有代币转移给自己。这个问题很关键，因为该问题有两种截然不同的解决方案，而这两种解决方案导致了两种风格的汇总。</p><h3 id="乐观汇总-vs-ZK-汇总"><a href="#乐观汇总-vs-ZK-汇总" class="headerlink" title="乐观汇总 vs ZK 汇总"></a>乐观汇总 vs ZK 汇总</h3><p>两种类型的汇总是：</p><ol><li><strong>乐观汇总</strong>，使用<strong>欺诈证明</strong>：汇总合约跟踪其状态根的整个历史和每个批次的哈希值。如果有人发现某个批次的后状态根不正确，他们可以向链发布一个证明，证明该批次的计算不正确。合约验证证明，并恢复该批次及其之后的所有批次。</li><li><strong>ZK rollups</strong>，使用<strong>有效性证明</strong>：每个批次都包含一个称为 ZK-SNARK 的加密证明（例如使用<a href="https://vitalik.ca/general/2019/09/22/plonk.html">PLONK</a>协议），它证明后状态根是执行该批次的正确结果。无论计算量有多大，证明都可以在链上很快得到验证。</li></ol><p>两种类型的汇总之间存在复杂的权衡：</p><div class="table-container"><table><thead><tr><th style="text-align:left">财产</th><th style="text-align:left">乐观汇总</th><th style="text-align:left">ZK 汇总</th></tr></thead><tbody><tr><td style="text-align:left">每批次固定气体成本</td><td style="text-align:left"><strong>~40,000</strong>（轻量级交易，主要只是改变状态根的值）</td><td style="text-align:left">~500,000（ZK-SNARK 的验证需要大量计算）</td></tr><tr><td style="text-align:left">停药期</td><td style="text-align:left">〜1周（提款需要延迟，以便有人有时间发布欺诈证明并在存在欺诈的情况下取消提款）</td><td style="text-align:left"><strong>非常快</strong>（只需等待下一批）</td></tr><tr><td style="text-align:left">技术的复杂性</td><td style="text-align:left"><strong>低的</strong></td><td style="text-align:left">高（ZK-SNARK 是非常新且数学复杂的技术）</td></tr><tr><td style="text-align:left">普遍性</td><td style="text-align:left"><strong>更容易</strong>（通用 EVM 汇总已经接近主网）</td><td style="text-align:left">更难（ZK-SNARK 证明通用 EVM 执行比证明简单计算要困难得多，尽管有一些努力（例如<a href="https://medium.com/starkware/hello-cairo-3cb43b13b209">Cairo</a>）正在努力改进这一点）</td></tr><tr><td style="text-align:left">每笔交易的链上 Gas 成本</td><td style="text-align:left">更高</td><td style="text-align:left"><strong>较低</strong>（如果交易中的数据仅用于验证，而不是导致状态更改，则可以忽略该数据，而在乐观汇总中，需要将其发布，以防需要在欺诈证明中进行检查）</td></tr><tr><td style="text-align:left">链下计算成本</td><td style="text-align:left"><strong>更低</strong>（虽然更需要很多全节点重做计算）</td><td style="text-align:left">更高（ZK-SNARK 证明特别针对通用计算可能会很昂贵，可能比直接运行计算贵数千倍）</td></tr></tbody></table></div><p>总的来说，我自己的观点是，在短期内，乐观汇总可能会在通用 EVM 计算中胜出，而 ZK 汇总可能会在简单支付、交换和其他特定于应用程序的用例中胜出，但在随着 ZK-SNARK 技术的改进，中长期 ZK rollups 将在所有用例中胜出。</p><h3 id="欺诈证明剖析"><a href="#欺诈证明剖析" class="headerlink" title="欺诈证明剖析"></a>欺诈证明剖析</h3><p>乐观汇总的安全性取决于这样的想法：如果有人将无效批次发布到汇总中，那么<em>任何</em>跟上链并检测到欺诈行为的其他人都可以发布欺诈证明，向合约证明该批次是无效的，并且应该恢复。</p><p><img src="https://vitalik.ca/images/rollup-files/tree.png" alt="img"></p><p>声称批次无效的欺诈证据将包含绿色数据：批次本身（可以根据链上存储的哈希进行检查）以及 Merkle 树的部分需要证明仅读取的特定帐户和/或按批次修改。树中黄色的节点可以从绿色的节点重建，因此不需要提供。<a href="https://ethresear.ch/t/the-stateless-client-concept/172">这些数据足以执行批处理并计算后状态根（请注意，这与无状态客户端</a>验证各个块的方式完全相同）。如果批次中计算的后状态根和提供的后状态根不相同，则该批次是欺诈的。</p><p>可以保证，如果一个批次构建不正确，<em>并且所有先前批次构建正确</em>，则可以创建一个欺诈证明，显示该批次构建不正确。请注意有关先前批次的声明：如果有多个无效批次发布到汇总，那么最好尝试证明最早的一批无效。当然，还可以保证，如果批次构建正确，则永远不可能创建表明该批次无效的欺诈证明。</p><h3 id="压缩是如何工作的？"><a href="#压缩是如何工作的？" class="headerlink" title="压缩是如何工作的？"></a>压缩是如何工作的？</h3><p>一个简单的以太坊交易（发送 ETH）大约需要 110 个字节。然而，一次 ETH 的汇总传输只需要大约 12 个字节：</p><div class="table-container"><table><thead><tr><th style="text-align:left">范围</th><th style="text-align:left">以太坊</th><th style="text-align:left">卷起</th></tr></thead><tbody><tr><td style="text-align:left">随机数</td><td style="text-align:left">〜3</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">天然气价格</td><td style="text-align:left">〜8</td><td style="text-align:left">0-0.5</td></tr><tr><td style="text-align:left">气体</td><td style="text-align:left">3</td><td style="text-align:left">0-0.5</td></tr><tr><td style="text-align:left">到</td><td style="text-align:left">21</td><td style="text-align:left">4</td></tr><tr><td style="text-align:left">价值</td><td style="text-align:left">〜9</td><td style="text-align:left">〜3</td></tr><tr><td style="text-align:left">签名</td><td style="text-align:left">~68 (2 + 33 + 33)</td><td style="text-align:left">～0.5</td></tr><tr><td style="text-align:left">从</td><td style="text-align:left">0（从 sig 恢复）</td><td style="text-align:left">4</td></tr><tr><td style="text-align:left">全部的</td><td style="text-align:left">〜112</td><td style="text-align:left">〜12</td></tr></tbody></table></div><p>部分原因在于卓越的编码：以太坊的 RLP 在每个值的长度上浪费了 1 个字节。但也有一些非常聪明的压缩技巧正在发生：</p><ul><li><strong>Nonce</strong>：该参数的目的是防止重放。如果帐户当前的随机数为 5，则该帐户的下一笔交易必须具有随机数 5，但一旦交易被处理，帐户中的随机数将增加到 6，因此无法再次处理该交易。在汇总中，我们可以完全省略随机数，因为我们只是从预状态恢复随机数；如果有人尝试使用较早的随机数重播交易，则签名将无法验证，因为将根据包含新的更高随机数的数据检查签名。</li><li><strong>Gasprice</strong>：我们可以允许用户以固定范围的gasprice 进行支付，例如。16 个连续的 2 的幂的选择。或者，我们可以在每个批次中设置固定的费用水平，甚至可以将天然气支付完全移出汇总协议，并让交易者通过通道向批次创建者支付费用。</li><li><strong>Gas</strong>：我们可以类似地将总 Gas 限制为 2 的连续幂的选择。或者，我们可以只在批次级别设置气体限制。</li><li><strong>To ：我们可以用*</strong>索引*替换 20 字节地址（例如，如果一个地址是添加到树中的第 4527 个地址，我们只需使用索引 4527 来引用它。我们会向状态添加一个子树来存储索引到地址的映射）。</li><li><strong>值</strong>：我们可以用科学记数法存储值。大多数情况下，传输只需要 1-3 位有效数字。</li><li><strong>签名</strong>：我们可以使用<a href="https://ethresear.ch/t/pragmatic-signature-aggregation-with-bls/2105">BLS 聚合签名</a>，它允许将许多签名聚合为单个约 32-96 字节（取决于协议）的签名。然后可以一次性对照整组消息和发件人检查该签名。表中的 ~0.5 表示这样一个事实，即可以在单个块中验证的聚合中可以组合的签名数量是有限的，因此大批次每 ~100 个交易需要一个签名。</li></ul><p>ZK rollups 特有的一个重要压缩技巧是，如果交易的一部分仅用于验证，与计算状态更新无关，那么该部分可以留在链外。这无法在乐观汇总中完成，因为该数据仍然需要包含在链上，以防稍后需要在欺诈证明中进行检查，而在 ZK 汇总中，证明批次正确性的 SNARK 已经证明了任何数据提供了验证所需的信息。一个重要的例子是隐私保护汇总：在乐观汇总中，每笔交易中用于隐私的约 500 字节 ZK-SNARK 需要上链，而在 ZK 汇总中，覆盖整个批次的 ZK-SNARK 已经没有留下任何痕迹。怀疑“内部”ZK-SNARK 是否有效。</p><p>这些压缩技巧是汇总可扩展性的关键；如果没有它们，汇总可能只会使基础链的可扩展性提高约 10 倍（尽管有一些特定的计算量大的应用程序，即使简单的汇总也很强大），而使用压缩技巧，缩放因子几乎可以超过 100 倍所有应用程序。</p><h3 id="谁可以提交一批？"><a href="#谁可以提交一批？" class="headerlink" title="谁可以提交一批？"></a>谁可以提交一批？</h3><p>对于谁可以在 optimistic 或 ZK rollup 中提交批次，有很多想法。一般来说，大家都同意，为了能够提交一批，用户必须缴纳大量押金；如果该用户提交了欺诈性批次（例如，具有无效的状态根），则该存款将被部分销毁，部分作为欺诈证明者的奖励。但除此之外，还有很多可能性：</p><ul><li><strong>完全无政府状态</strong>：任何人都可以随时提交批次。这是最简单的方法，但它有一些重要的缺点。特别是，存在这样的风险：多个参与者将生成并尝试并行提交批次，并且只有其中一个批次可以成功包含在内。这会导致在生成证明方面浪费大量精力和/或在将批次发布到链上时浪费气体。</li><li><strong>集中式排序器</strong>：有一个参与者，<strong>排序器</strong>，可以提交批次（提款除外：通常的技术是用户可以首先提交提款请求，然后如果排序器在下一个中不处理该提款请求批量，则用户可以自己提交单操作批量）。这是最“高效”的，但它依赖于中心参与者的活跃度。</li><li><strong>定序器拍卖</strong>：举行拍卖（例如每天）以确定谁有权成为第二天的定序器。该技术的优点是它筹集了可以通过例如分配的资金。由 rollup 控制的 DAO（参见：<a href="https://ethresear.ch/t/mev-auction-auctioning-transaction-ordering-rights-as-a-solution-to-miner-extractable-value/6788">MEV 拍卖</a>）</li><li><strong>PoS 集合中的随机选择</strong>：任何人都可以将 ETH（或者可能是 rollup 自己的协议代币）存入 rollup 合约中，每一批的排序者都是从存款人中随机选择的，被选中的概率与金额成正比存入。这种技术的主要缺点是它会导致大量不必要的资金锁定。</li><li><strong>DPoS 投票</strong>：通过拍卖选择一个排序器，但如果它们表现不佳，代币持有者可以投票将其踢出并举行新的拍卖来取代它们。</li></ul><h4 id="拆分批处理和状态根提供"><a href="#拆分批处理和状态根提供" class="headerlink" title="拆分批处理和状态根提供"></a>拆分批处理和状态根提供</h4><p>目前正在开发的一些汇总正在使用“拆分批次”范例，其中提交一批第 2 层交易的操作和提交状态根的操作是分开完成的。这有一些关键的优点：</p><ol><li>您可以允许许多定序器并行发布批次，以提高审查阻力，而不必担心某些批次会因为其他批次首先被包含而无效。</li><li>如果状态根是欺诈性的，您不需要恢复整个批次；您可以仅恢复状态根，然后等待某人为同一批提供新的状态根。这为交易发送者提供了更好的保证，他们的交易不会被还原。</li></ol><p>总而言之，有一个相当复杂的技术动物园，试图在涉及效率、简单性、审查制度阻力和其他目标的复杂权衡之间取得平衡。现在说这些想法的哪种组合最有效还为时过早。时间会证明一切。</p><h2 id="汇总可以为您提供多少缩放？"><a href="#汇总可以为您提供多少缩放？" class="headerlink" title="汇总可以为您提供多少缩放？"></a>汇总可以为您提供多少缩放？</h2><p>在现有的以太坊链上，Gas上限为1250万，一笔交易中的每个字节数据需要花费16个Gas。这意味着，如果一个块只包含单个批次（我们会说使用了 ZK rollup，在证明验证上花费了 500k 气体），则该批次可以包含 (1200 万 / 16) = 750,000 字节的数据。如上所示，ETH 传输的汇总每个用户操作仅需要 12 个字节，这意味着该批次最多可以包含 62,500 个交易。<a href="https://etherscan.io/chart/blocktime">以13 秒</a>的平均出块时间计算，这相当于约 4807 TPS（相比之下，直接在以太坊本身上进行 ETH 传输的 1250 万/21000 / 13 ~= 45 TPS）。</p><p>下面是一些其他示例用例的图表：</p><div class="table-container"><table><thead><tr><th style="text-align:left">应用</th><th style="text-align:left">汇总中的字节数</th><th style="text-align:left">第 1 层的 Gas 成本</th><th style="text-align:left">最大可扩展性增益</th></tr></thead><tbody><tr><td style="text-align:left">以太坊转账</td><td style="text-align:left"><strong>12</strong></td><td style="text-align:left">21,000</td><td style="text-align:left">105倍</td></tr><tr><td style="text-align:left">ERC20转账</td><td style="text-align:left"><strong>16</strong>（另外 4 个字节来指定哪个令牌）</td><td style="text-align:left">〜50,000</td><td style="text-align:left">187x</td></tr><tr><td style="text-align:left">Uniswap 交易</td><td style="text-align:left"><strong>~14</strong>（4 字节发送者 + 4 字节接收者 + 3 字节值 + 1 字节最高价格 + 1 字节杂项）</td><td style="text-align:left">〜100,000</td><td style="text-align:left">428x</td></tr><tr><td style="text-align:left">隐私保护提现（乐观汇总）</td><td style="text-align:left"><strong>296</strong>（4字节根索引+32字节无效符+4字节接收者+256字节ZK-SNARK证明）</td><td style="text-align:left"><a href="https://etherscan.io/tx/0x6e311f84655af72614966705584569b52d6e314f2d61b965db91db41fd01b1e1">〜380,000</a></td><td style="text-align:left">77x</td></tr><tr><td style="text-align:left">隐私保护提现（ZK rollup）</td><td style="text-align:left"><strong>40</strong>（4字节根索引+32字节无效符+4字节接收者）</td><td style="text-align:left"><a href="https://etherscan.io/tx/0x6e311f84655af72614966705584569b52d6e314f2d61b965db91db41fd01b1e1">〜380,000</a></td><td style="text-align:left">570x</td></tr></tbody></table></div><p><em>最大可扩展性增益的计算公式为（L1 Gas 成本）/（汇总字节数 \</em> 16）* 1200 万/1250 万。*</p><p>现在，值得记住的是，由于一些原因，这些数字过于乐观。最重要的是，一个块几乎永远不会只包含一批，至少因为存在并且将会有多个汇总。其次，存款和取款将继续存在。第三，<em>短期内</em>使用率较低，因此固定成本将占主导地位。但即使考虑到这些因素，超过 100 倍的可扩展性增益预计也将成为常态。</p><p>现在，如果我们想要超过 ~1000-4000 TPS（取决于具体用例）怎么办？这就是<a href="https://hackmd.io/@HWeNw8hNRimMm2m2GH56Cw/sharding_proposal">eth2数据分片</a>的用武之地。分片提案每12秒开辟一个16MB的空间，可以填充任何数据，并且系统保证对该数据的可用性达成共识。该数据空间可供汇总使用。每秒约 1398k 字节是现有以太坊链约 60 kB/秒的 23 倍，从长远来看，数据容量预计将进一步增长。因此，使用 eth2 分片数据的汇总可以总共处理高达约 100k TPS，并且在未来甚至更多。</p><h2 id="Rollup-中还有哪些尚未完全解决的挑战？"><a href="#Rollup-中还有哪些尚未完全解决的挑战？" class="headerlink" title="Rollup 中还有哪些尚未完全解决的挑战？"></a>Rollup 中还有哪些尚未完全解决的挑战？</h2><p>虽然 Rollup 的基本概念现在已经很好理解，但我们非常确定它们从根本上来说是可行和安全的，并且多个 Rollup 已经部署到主网上，但仍有许多 Rollup 设计领域尚未得到很好的探索，将以太坊生态系统的大部分内容完全引入 Rollups 以利用其可扩展性方面面临着相当多的挑战。一些关键挑战包括：</p><ul><li><strong>用户和生态系统入门</strong>——没有多少应用程序使用 Rollup，用户对 Rollup 不熟悉，并且很少有钱包开始集成 Rollup。商家和慈善机构尚未接受它们付款。</li><li><strong>交叉汇总交易</strong>——有效地将资产和数据（例如预言机输出）从一个汇总转移到另一个汇总，而不会产生通过基础层的费用。</li><li><strong>审计激励措施</strong>- 如何最大限度地提高至少一个诚实节点实际上完全验证乐观汇总的机会，以便在出现问题时他们可以发布欺诈证明？对于小规模的汇总（最多几百 TPS），这不是一个重要问题，人们可以简单地依赖利他主义，但对于更大规模的汇总，需要对此进行更明确的推理。</li><li><strong>探索等离子和汇总之间的设计空间</strong>- 是否有技术可以将<em>一些</em>与状态更新相关的数据放在链上，但不是<em>全部</em>，以及从中可以得出什么有用的东西？</li><li><strong>最大限度地提高预确认的安全性</strong>- 许多汇总提供了“预确认”的概念以实现更快的用户体验，其中定序器立即提供交易将包含在下一批中的承诺，并且如果定序器违反了其保证金，则定序器的押金将被销毁。单词。但该方案的经济安全性是有限的，因为有可能同时向很多参与者做出许多承诺。这个机制可以改进吗？</li><li><strong>提高对缺失定序器的响应速度</strong>- 如果汇总的定序器突然离线，则尽可能快速且廉价地从该情况中恢复是有价值的，要么快速且廉价地批量退出到不同的汇总，要么更换定序器。</li><li><strong>高效的 ZK-VM</strong> - 生成 ZK-SNARK 证明，证明通用 EVM 代码（或现有智能合约可以编译到的某些不同 VM）已正确执行并具有给定结果。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Rollup 是一种强大的新的第 2 层扩展范例，预计将成为以太坊在短期和中期（也可能是长期）扩展的基石。他们看到了以太坊社区的大量兴奋，因为与之前的第 2 层扩展尝试不同，它们可以支持通用 EVM 代码，允许现有应用程序轻松迁移。他们通过做出一个关键的妥协来做到这一点：不尝试完全脱离链，而是将每笔交易的少量数据留在链上。</p><p>汇总有很多种，设计空间也有多种选择：可以使用欺诈证明进行乐观汇总，也可以使用有效性证明进行 ZK 汇总（又名 ZK-SNARK）。定序器（可以将交易批次发布到链上的用户）可以是中心化参与者，也可以是混战者，或者介于两者之间的许多其他选择。Rollup 仍然是一项早期技术，开发仍在快速进行，但它们确实有效，其中一些（特别是<a href="https://loopring.io/">Loopring</a>、<a href="https://wallet.zksync.io/">ZKSync</a>和<a href="https://www.deversifi.com/">DeversiFi</a>）已经运行了几个月。预计未来几年将会有更多令人兴奋的工作从汇总空间中诞生。</p>]]></content>
    
    
    <categories>
      
      <category>blockchain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>summary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ethereum</title>
    <link href="/2023/04/24/Ethereum/"/>
    <url>/2023/04/24/Ethereum/</url>
    
    <content type="html"><![CDATA[<h2 id="以太坊的树"><a href="#以太坊的树" class="headerlink" title="以太坊的树"></a>以太坊的树</h2><p>以太坊区块数据有三棵树，分别为状态树，交易树和收据树。整个以太坊系统中只有—<strong>—</strong>棵状态树，记录整个以太坊系统的所有账户状态。每个区块保存着一棵交易树，记录该区块的交易情况，一棵收据树用来记录该区块的交易收据。<br><strong>状态树采用Merkel-Patrica(MPT)树，而交易树和收据树采用Merkel树。</strong></p><p>账户存储树是保存与账户相关联数据的结构。该项只有合约账户才有，而在 EOA 中， storageRoot 留空、 codeHash 则是一串空字符串的哈希值。所有智能合约的数据都以 32 字节映射的形式保存在账户存储树中。</p><p><a href="https://learnblockchain.cn/article/472">https://learnblockchain.cn/article/472</a></p><p><a href="https://blog.csdn.net/wxudong1991/article/details/109311822">https://blog.csdn.net/wxudong1991/article/details/109311822</a></p><p><a href="https://www.bcskill.com/index.php/archives/1253.html">区块链架构</a></p><p><img src="images/Ethereum/BC_datastructrue.png" alt="img"></p><p><img src="https://img.learnblockchain.cn/pics/20230302185957.png" alt="img"></p><h2 id="两个用户同时调用某一智能合约？-以太坊是顺序的"><a href="#两个用户同时调用某一智能合约？-以太坊是顺序的" class="headerlink" title="两个用户同时调用某一智能合约？- 以太坊是顺序的"></a>两个用户同时调用某一智能合约？- 以太坊是顺序的</h2><blockquote><p><strong>区块链智能合约交易并行执行模型综述</strong></p></blockquote><p><strong>It is also worth noting that smart contracts are not executed “in parallel” in any sense—the Ethereum world computer can be considered to be a single-threaded machine.</strong></p><p><a href="https://github.com/ethereumbook/ethereumbook/blob/develop/07smart-contracts-solidity.asciidoc#what-is-a-smart-contract">参考以太坊book</a></p><h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><p><a href="https://github.com/chaseSpace/learn_blockchain/blob/main/smart_contract.md">https://github.com/chaseSpace/learn_blockchain/blob/main/smart_contract.md</a></p><p><a href="https://solidity-cn.readthedocs.io/zh/develop/introduction-to-smart-contracts.html">智能合约概述solidity</a></p><p>Internal transaction (also “message”)</p><p>A transaction sent from a contract account to another contract account or an EOA.</p><p><a href="https://github.com/ethereumbook/ethereumbook/blob/c5ddebd3dbec804463c86d0ae2de9f28fbafb83a/glossary.asciidoc#L160">https://github.com/ethereumbook/ethereumbook/blob/c5ddebd3dbec804463c86d0ae2de9f28fbafb83a/glossary.asciidoc#L160</a></p><p><a href="https://docs.soliditylang.org/en/v0.8.22/abi-spec.html#function-selector"><strong>Function</strong> Selector and Argument Encoding</a></p><blockquote><p><img src="/images/Ethereum/image-20231107102909599.png" alt="image-20231107102909599"></p></blockquote><p><a href="https://goodgid.github.io/BlockChain-Transaction,-Message,-Call/">Transaction, Message, Call</a></p><p>合约之间相互调用</p><p><img src="/images/Ethereum/image-20231105205651566.png" alt="image-20231105205651566"></p><p><a href="https://docs.chainmaker.org.cn/instructions/%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E8%B7%A8%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8.html">跨合约调用</a></p><blockquote><p><strong>动态调用示例</strong></p><p>合约dynamic_call.sol。部署Caller合约后，可以调用任意solidity合约及其方法，不限定接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: GPL-3.0<br><br>pragma solidity &gt;= 0.8.0;<br><br>contract Caller &#123;<br>    string[10] x;<br>    string[8] params;<br><br>    function cross_call(address callee, string calldata method, string calldata key, int256 value) public &#123;<br>//注意，method必须为方法签名格式,且方法签名的参数间不能有空格，例如&quot;save(string,int256)&quot;<br>    callee.call((abi.encodeWithSignature(method, key, value));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如示例所示，调用者合约Caller可以调用任意合约的任意方法，只需要将被调用合约的地址、方法签名和参数传给调用者合约即可。</p><p>注意，被调合约的方法必须是方法签名样式，且方法签名的参数间不能有空格，如示例中注释所示，否则无法编译为准确的ABI类型的calldata，evm将无法识别。</p></blockquote><p><a href="https://juejin.cn/post/7219567168316063804">https://juejin.cn/post/7219567168316063804</a></p><blockquote><p>所谓动态调用，是指调用者合约不需要提前知道被调用合约的接口，只需要在调用时，告诉调用者被调合约的方法签名即可。调用者合约不需要事前绑定被调者的接口，可以在调用时，指定任意被调用合约及其方法，更加灵活。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs solidity">https://github.com/WeBankBlockchain/WeCross-BCOS2-Stub/blob/master/src/main/resources/WeCrossHub.sol<br>// internal call<br>    function callContract(address _contractAddress, string memory _sig, bytes memory _args) internal<br>    returns(bytes memory result)<br>    &#123;<br>        bytes memory sig = abi.encodeWithSignature(_sig);<br>        bool success;<br>        (success, result) = address(_contractAddress).call(abi.encodePacked(sig, _args));<br>        if(!success) &#123;<br>            revert(string(result));<br>        &#125;<br>    &#125;<br><br>    // internal call<br>    function callContract(address _contractAddress, bytes memory _argsWithMethodId) internal<br>    returns(bytes memory result)<br>    &#123;<br>        bool success;<br>        (success, result) = address(_contractAddress).call(_argsWithMethodId);<br>        if(!success) &#123;<br>            //(string memory error) = abi.decode(result, (string));<br>            revert(string(result));<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="区块链事件"><a href="#区块链事件" class="headerlink" title="区块链事件"></a>区块链事件</h2><p><a href="https://hackernoon.com/zh/solidity-%E4%BA%8B%E4%BB%B6%E5%85%A8%E9%9D%A2%E6%A6%82%E8%BF%B0"><strong>Solidity 事件：全面概述</strong></a></p><blockquote><p><strong>以太坊不提供一种机制来获取智能合约的所有交易，但它确实提供了一种机制来从智能合约中获取所有事件。</strong></p></blockquote><h2 id="区块链可扩展性的限制"><a href="#区块链可扩展性的限制" class="headerlink" title="区块链可扩展性的限制"></a>区块链可扩展性的限制</h2><p>（强推）<a href="https://vitalik.ca/general/2021/05/23/scaling.html">https://vitalik.ca/general/2021/05/23/scaling.html</a></p><p>以太坊扩容综述 <a href="https://www.odaily.news/post/5182589">https://www.odaily.news/post/5182589</a></p><h2 id="以太坊交易速度受哪些因素限制"><a href="#以太坊交易速度受哪些因素限制" class="headerlink" title="以太坊交易速度受哪些因素限制"></a>以太坊交易速度受哪些因素限制</h2><p>以太坊现状：网络拥堵、磁盘空间（运行一个全节点很困难）</p><h3 id="scalability、security、decentralization"><a href="#scalability、security、decentralization" class="headerlink" title="scalability、security、decentralization"></a>scalability、security、decentralization</h3><p>Ethereum needs to be able to handle more transactions per second without increasing the size of the nodes in the network. </p><p>不提高单个节点能力的情况下每秒处理更多交易</p><p><strong>The main goal of scalability</strong> is to increase transaction speed (faster finality) and transaction throughput (higher transactions per second) without sacrificing decentralization or security.</p><p>解决存储问题：无状态设计？快照同步</p><p><strong>The only solution to storage size problems is <a href="https://hackmd.io/@vbuterin/state_expiry_paths">statelessness and state expiry</a>. </strong> <strong>Statelessness</strong> allows for a class of nodes that verify the chain <em>without</em> maintaining permanent storage. <strong>State expiry</strong> pushes out state that has not been recently accessed, forcing users to manually provide proofs to renew it. Both of these paths have been worked at for a long time, and proof-of-concept implementation on statelessness has already started.</p><p>快照同步</p><blockquote><p><img src="images/Ethereum/image-20230430152206219.png" alt="image-20230430152206219"><img src="images/Ethereum/image-20230430151717120.png" alt="image-20230430151717120"></p></blockquote><h2 id="以太坊上的DAPP"><a href="#以太坊上的DAPP" class="headerlink" title="以太坊上的DAPP"></a>以太坊上的DAPP</h2><blockquote><p>一个分布式的App不用将所有状态都存储在区块链上，或者在链上进行所有计算（译者注：比如图形渲染），这样就太花gas了。所以一个分布式App把需要大家共同信任的状态存在区块链上就好了。许多的分布式应用使用后面提到的技术，如IPFS和Gelem，在链下进行分布式存储和计算。虽然没在以太坊上，但仍使用的是区块链技术。</p></blockquote><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="https://www.echenshe.com/tut/bc/3-3.html">以太坊原理</a></p><p><a href="https://github.com/ethereumbook/ethereumbook/tree/develop">以太坊书</a></p><h2 id="区块链中balance和payouts，deposit具体是指什么操作？它们三个有什么关系？"><a href="#区块链中balance和payouts，deposit具体是指什么操作？它们三个有什么关系？" class="headerlink" title="区块链中balance和payouts，deposit具体是指什么操作？它们三个有什么关系？"></a>区块链中balance和payouts，deposit具体是指什么操作？它们三个有什么关系？</h2><blockquote><p>在区块链中，balance指的是一个地址（或账户）的当前余额，即该地址当前拥有的数字货币数量。这个余额可以通过各种操作进行更改，例如通过转账、挖矿、收到交易等等。</p><p>Payouts是指向某个地址发送数字货币的过程，通常是由一个智能合约触发的。智能合约会从一个地址的余额中扣除一定数量的数字货币，并将这些数字货币发送到另一个地址。</p><p>Deposit是指将数字货币存入一个地址的过程。这通常涉及将数字货币从一个地址发送到另一个地址，其中目标地址是正在存款的地址。在存款完成后，该地址的余额将增加相应的数量。</p><p>这三个概念之间有密切的关系。当一个地址接收到一笔Payouts时，它的余额会增加。当一个地址发送一笔Deposit时，它的余额会减少。因此，一个地址的余额可以看作是从过去的Payouts和Deposit操作的结果。</p></blockquote><h2 id="区块链中withdrawals是啥意思"><a href="#区块链中withdrawals是啥意思" class="headerlink" title="区块链中withdrawals是啥意思?"></a>区块链中withdrawals是啥意思?</h2><blockquote><p>在区块链中，withdrawals指的是从一个地址中取出数字货币的过程。这个过程通常是由持有该地址的用户发起的，用户可以通过发送一笔交易，将数字货币从该地址发送到另一个地址，从而完成取款的过程。</p><p>Withdrawals和balance、payouts和deposit之间存在紧密的关系。一个地址的余额（balance）是由过去所有的收款（deposit）和支出（withdrawals）操作的结果计算得出的。当一个用户发起一笔withdrawals时，它会从该地址的余额中扣除相应的数字货币数量，并将这些数字货币发送到另一个地址。因此，withdrawals可以被视为支出（payouts）的一种形式，因为它是将数字货币从一个地址发送到另一个地址的过程。</p></blockquote><h2 id="区块链中的clogging攻击指的是什么？"><a href="#区块链中的clogging攻击指的是什么？" class="headerlink" title="区块链中的clogging攻击指的是什么？"></a>区块链中的clogging攻击指的是什么？</h2><blockquote><p>Clogging攻击，又称拥塞攻击，是指在区块链网络中通过发送大量无效的交易来占用网络带宽和节点资源的攻击行为。攻击者会发送一些特意构造的无效交易，这些交易会在网络中传播和验证，占用大量的带宽和节点资源，从而导致网络拥堵，让正常的交易无法及时得到验证和处理。这种攻击可以导致交易的延迟和费用的增加，甚至可以完全阻塞网络，让区块链系统失去可用性。</p><p>Clogging攻击是一种分布式拒绝服务（DDoS）攻击的变种，它的目的是通过消耗网络资源来影响区块链的性能和可用性。攻击者可能会利用这种攻击手段来进行勒索或者敲诈，向网络用户和矿工勒索比特币或其他加密货币。对于区块链网络而言，防范这种攻击需要提高网络的抗DDoS能力，采取一些技术措施来限制无效交易的传播和验证，以及加强节点的监管和管理。</p></blockquote><h2 id="无状态区块链"><a href="#无状态区块链" class="headerlink" title="无状态区块链"></a>无状态区块链</h2><p><a href="https://ethereum.org/zh/roadmap/statelessness/">https://ethereum.org/zh/roadmap/statelessness/</a></p><blockquote><p><strong>In weak statelessness proposing blocks requires access to full state data but verifying blocks requires no state data</strong></p><p>提议方需要存储完整状态，但是验证方反而不要储存，因为安全性是通过验证方确定的，但是不存储完整状态怎么验证提议方的提议？</p></blockquote><h2 id="以太坊3难困境"><a href="#以太坊3难困境" class="headerlink" title="以太坊3难困境"></a>以太坊3难困境</h2><p><a href="https://www.ledger.com/academy/what-is-the-blockchain-trilemma">什么是以太坊3难困境？</a></p><h2 id="OPTIMISTIC-ROLLUPS-如何与以太坊交互？"><a href="#OPTIMISTIC-ROLLUPS-如何与以太坊交互？" class="headerlink" title="OPTIMISTIC ROLLUPS 如何与以太坊交互？"></a>OPTIMISTIC ROLLUPS 如何与以太坊交互？</h2><p><a href="https://ethereum.org/en/developers/docs/scaling/optimistic-rollups/">https://ethereum.org/en/developers/docs/scaling/optimistic-rollups/</a></p><p>Optimistic rollups 是在以太坊之上运行的<a href="https://ethereum.org/en/developers/docs/scaling/#off-chain-scaling">链下扩展解决方案。</a>每个 optimistic rollup 都由一组部署在以太坊网络上的智能合约管理。Optimistic rollups 处理主以太坊链外的交易，但将链下交易（批量）发布到链上 rollup 合约。和以太坊区块链一样，这个交易记录是不可变的，形成了“乐观汇总链”。</p><p>optimistic rollup 的架构包括以下部分：</p><p><strong>链上合约</strong>：optimistic rollups 的操作由运行在以太坊上的智能合约控制。这包括存储汇总块、监控汇总状态更新以及跟踪用户存款的合约。从这个意义上说，以太坊是 optimistic rollups 的基础层或“第 1 层”。</p><p><strong>链下虚拟机（VM）</strong>：虽然管理 optimistic rollup 协议的合约在以太坊上运行，但 rollup 协议在与以太坊虚拟机分开的另一个虚拟机上执行计算和状态<a href="https://ethereum.org/en/developers/docs/evm/">存储</a>。链下虚拟机是应用程序运行和执行状态更改的地方；它作为 optimistic rollup 的上层或“第 2 层”。</p><p>由于 optimistic rollups 旨在运行为 EVM 编写或编译的程序，因此链下 VM 包含许多 EVM 设计规范。此外，在链上计算的欺诈证明允许以太坊网络强制执行在链下 VM 中计算的状态更改的有效性。</p><p>Optimistic rollups 被描述为“混合扩展解决方案”，因为虽然它们作为单独的协议存在，但它们的安全属性源自以太坊。除其他事项外，以太坊保证汇总的链下计算的正确性以及计算背后数据的可用性。这使得 optimistic rollups 比不依赖以太坊安全的纯链下扩展协议（例如，<a href="https://ethereum.org/en/developers/docs/scaling/sidechains/">侧链）更安全。</a></p><h2 id="Trust-Zone"><a href="#Trust-Zone" class="headerlink" title="Trust Zone"></a>Trust Zone</h2><p><a href="https://blog.csdn.net/guyongqiangx/article/details/78020257">什么是TrustZone</a></p><h2 id="理解以太坊"><a href="#理解以太坊" class="headerlink" title="理解以太坊"></a>理解以太坊</h2><p><a href="https://zhuanlan.zhihu.com/p/56151995">https://zhuanlan.zhihu.com/p/56151995</a></p><h2 id="预言机-智能合约如何可信的与外部世界交互"><a href="#预言机-智能合约如何可信的与外部世界交互" class="headerlink" title="预言机,智能合约如何可信的与外部世界交互"></a>预言机,智能合约如何可信的与外部世界交互</h2><blockquote><p><a href="https://blog.csdn.net/sportshark/article/details/77477842">智能合约如何可信的与外部世界交互</a></p><p><a href="https://ethereum.org/zh/developers/docs/oracles/">预言机-以太坊</a></p><p>因此如果智能合约从外部服务获取数据的话，这个数据获取过程是由各节点重复和独立完成的，假设这个区块链有100个节点，那么就会有100条获取数据的请求从每个节点发送到期货交易场所，但是因为这个数据来源于区块链外部，价格是实时波动的，由于网络延迟、节点处理速度等各种原因，每个节点获取的并不是同一时刻的价格，输入到智能合约的价格数据也就不同，因此对应的各节点智能合约输出也会不同，在这种情况下，整个区块链的信任基础就会崩溃，无法达成共识。</p><p>预言机解决了这一问题，它从链下来源获取信息并存储在区块链上供智能合约使用。 由于存储在链上的信息是不可更改和公开可用的，以太坊节点可以安全地使用预言机导入的链下数据计算状态变化，且不会打破共识。</p><p>为此，预言机通常由链上运行的智能合约和一些链下组件构成。 链上合约接收其他智能合约的数据请求，并将这些请求传送给链下组件（称为预言机节点）。 这类预言机节点可以查询数据源—例如使用应用程序接口 (API)—<strong>并发送交易将请求的数据存储在智能合约的存储中。</strong></p></blockquote><h2 id="双花攻击？50-算力？比特币白皮书第11章"><a href="#双花攻击？50-算力？比特币白皮书第11章" class="headerlink" title="双花攻击？50%算力？比特币白皮书第11章"></a>双花攻击？50%算力？比特币白皮书第11章</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzkzNjI5NDE0MA==&amp;mid=2247507730&amp;idx=3&amp;sn=59650e738ccf194c4ca1f95c050f02ce&amp;source=41#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzkzNjI5NDE0MA==&amp;mid=2247507730&amp;idx=3&amp;sn=59650e738ccf194c4ca1f95c050f02ce&amp;source=41#wechat_redirect</a></p><h2 id="GHOST协议"><a href="#GHOST协议" class="headerlink" title="GHOST协议"></a>GHOST协议</h2><blockquote><p>为了确定哪个路径才是最有效的以及防止多条链的产生，以太坊使用了一个叫做“GHOST协议(GHOST protocol.)”的数学机制。</p></blockquote><p><a href="https://blog.csdn.net/itchosen/article/details/78655903">以太坊详解</a></p><h2 id="checkpoint-block"><a href="#checkpoint-block" class="headerlink" title="checkpoint block"></a>checkpoint block</h2><h2 id="矿工执行并验证交易需要什么？"><a href="#矿工执行并验证交易需要什么？" class="headerlink" title="矿工执行并验证交易需要什么？"></a>矿工执行并验证交易需要什么？</h2><p><a href="https://ethereum.org/zh/roadmap/verkle-trees/">https://ethereum.org/zh/roadmap/verkle-trees/</a></p><h3 id="Why-do-we-want-stateless-clients"><a href="#Why-do-we-want-stateless-clients" class="headerlink" title="Why do we want stateless clients?"></a>Why do we want stateless clients?</h3><p>Ethereum clients currently use a data structure known as a Patricia Merkle Trie to store its state data. Information about individual accounts are stored as leaves on the trie and pairs of leaves are hashed repeatedly until only a single hash remains. This final hash is known as the “root”. <strong>To verify blocks, Ethereum clients execute all the transactions in a block and update their local state trie. </strong>The block is considered valid if the root of the local tree is identical to the one provided by the block proposer, because any differences in the computation done by the block proposer and the validating node would cause the root hash to be completely different. <strong>The problem with this is that verifying the blockchain requires each client to store the whole state trie for the head block and several historical blocks (the default in Geth is to keep state data for 128 blocks behind the head).</strong> This requires clients to have access to a large amount of disk space, which is a barrier to running full nodes on cheap, low power hardware. A solution to this is to update the state trie to a more efficient structure (Verkle tree) that can be summarized using a small “witness” to the data that can be shared instead of the full state data. Reformatting the state data into a Verkle tree is a stepping stone for moving to stateless clients.</p><h3 id="What-is-a-witness-and-why-do-we-need-them"><a href="#What-is-a-witness-and-why-do-we-need-them" class="headerlink" title="What is a witness and why do we need them?"></a>What is a witness and why do we need them?</h3><p>Verifying a block means re-executing the transactions contained in the block, applying the changes to Ethereum’s state trie, and calculating the new root hash.<strong>A verified block is one whose computed state root hash is the same as the one provided with the block (because this means the block proposer really did the computation they say they did).</strong> In today’s Ethereum clients, updating the state requires access to the entire state trie, which is a large data structure that must be stored locally. A witness only contains the fragments of the state data that are required to execute the transactions in the block. A validator can then only use those fragments to verify that the block proposer has executed the block transactions and updated the state correctly. However, this means that the witness needs to be transferred between peers on the Ethereum network rapidly enough to be received and processed by each node safely within a 12 second slot. If the witness is too large, it might take some nodes too long to download it and keep up with the chain. This is a centralizing force because it means only nodes with fast internet connections can participate in validating blocks. With Verkle trees there is no need to have the state stored on your hard drive; <em>everything</em> you need to verify a block is contained within the block itself. Unfortunately, the witnesses that can be produced from Merkle tries are too large to support stateless clients.</p><h3 id="承诺向量"><a href="#承诺向量" class="headerlink" title="承诺向量"></a>承诺向量</h3><p><a href="https://www.youtube.com/watch?v=RGJOQHzg3UQ">https://www.youtube.com/watch?v=RGJOQHzg3UQ</a></p><p><img src="images/Ethereum/image-20230716142041732.png" alt="image-20230716142041732"></p><p><img src="images/Ethereum/image-20230716142114469.png" alt="image-20230716142114469"></p><h2 id="无状态设计，不需要账本就能记账"><a href="#无状态设计，不需要账本就能记账" class="headerlink" title="无状态设计，不需要账本就能记账"></a>无状态设计，不需要账本就能记账</h2><p><a href="http://www.tucaod.com/6696.html">http://www.tucaod.com/6696.html</a></p><h2 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h2><p><a href="https://learnblockchain.cn/article/2238">https://learnblockchain.cn/article/2238</a></p><p>黄皮书：<a href="https://github.com/ethereum/yellowpaper">https://github.com/ethereum/yellowpaper</a></p><p>白皮书：<a href="https://ethereum.org/zh/whitepaper/">https://ethereum.org/zh/whitepaper/</a></p><h2 id="witness设计"><a href="#witness设计" class="headerlink" title="witness设计"></a>witness设计</h2><p>承诺方案</p><p>witness</p><p>verkle树</p><blockquote><p>将TEE想象成一个无状态的验证者，Instead of using their own local copy of Ethereum’s state to verify blocks, stateless clients use a “witness” to the state data that arrives with the block.无状态的验证者可以用 “witness”去验证与交易相关的账户状态。那反过来，TEE如果生成这种 “witness”，就可供其他人验证TEE在执行过程中涉及到的状态。</p><p> “witness”是什么：A witness is a collection of individual pieces of the state data that are required to execute a particular set of transactions, and a cryptographic proof that the witness is really part of the full data. the witnesses need to be very small, so that they can be safely broadcast across the network in time for validators to process them within a 12 second slot. 如果用merkle树来描述，merkle树他验证某一个值是否在某个位置的方法是生成merkle proof，整个merkle proof就是一个“witness”，但是merkle proof太庞大了，它需要所有的兄弟节点的hash,需要有一种改进的数据结构来传递这种”witness”，要求是越小越好，但是能被高效验证。</p><p>可以用多项式承诺</p></blockquote><p>KZG承诺实现verkle 树</p><blockquote><p>The <a href="https://dankradfeist.de/ethereum/2020/06/16/kate-polynomial-commitments.html">KZG (Kate) polynomial commitment scheme</a> is a polynomial commitment scheme. Its primary functionality is the ability to commit to a polynomial f(x) via an elliptic curve group element C=[f(s)]1</p></blockquote><h5 id="通过椭圆曲线群元素-C-f-s-1-来承诺于多项式-f-x"><a href="#通过椭圆曲线群元素-C-f-s-1-来承诺于多项式-f-x" class="headerlink" title="通过椭圆曲线群元素 C = [f(s)]1 来承诺于多项式 f(x)"></a>通过椭圆曲线群元素 C = [f(s)]1 来承诺于多项式 f(x)</h5><blockquote><p>这个表达式中，C = [f(s)]1 表示通过将多项式 f(x) 在特定点 s 处的求值结果 f(s) 进行椭圆曲线群操作，得到的椭圆曲线群元素 C。</p><p>椭圆曲线群元素是椭圆曲线上的点，可以用于在密码学中进行各种操作和计算。在这种多项式承诺方案中，通过将多项式在特定点的求值结果转换为椭圆曲线群元素，实现对多项式的承诺。</p><p>方括号 [ ] 表示椭圆曲线群操作，1 是群操作的指数。具体来说，[f(s)]1 表示将 f(s) 作为椭圆曲线群的元素进行群操作。</p><p>这个承诺形式的好处是，它将多项式 f(x) 的信息转换为椭圆曲线群上的元素，使得对多项式的承诺具有密码学的安全性和验证的可行性。通过这种方式，可以实现对多项式的承诺和验证，同时保护了多项式的隐私和完整性。</p><p><img src="images/Ethereum/image-20230717153706606.png" alt="image-20230717153706606"></p><p>这个描述中，我们引入了一个符号 ω 来表示一个复数，它具有特定的性质。在数学中，单位根是一个复数的幂，当这个复数的幂达到某个特定的值时，结果等于 1。</p><p>在这种情况下，我们假设 ω 是一个复数，它的幂等于 1，即 ω^d = 1。这意味着 ω 是一个阶为 d 的单位根，其中 d 是一个正整数。换句话说，当我们将 ω 自乘 d 次时，结果等于 1。</p><p>此外，我们还要求 ω 的幂在 0 到 d-1 的范围内都不等于 1，即 ω^i ≠ 1，其中 0 ≤ i &lt; d。这个条件确保了 ω 是一个原根，也就是说，它的幂覆盖了从 0 到 d-1 的所有可能值，并且不会重复。</p><p>这个性质在许多数学和密码学的应用中很重要，尤其是在离散傅里叶变换、多项式插值、多项式承诺等领域。通过引入 ω 这样一个原根，我们可以利用它的性质来进行复杂的数学运算和密码学操作。</p></blockquote><h5 id="什么是原根"><a href="#什么是原根" class="headerlink" title="什么是原根"></a>什么是原根</h5><blockquote><p>在数论中，给定一个正整数 n，如果存在一个整数 g，使得 g 的幂可以生成模 n的所有非零剩余类，则 g 被称为模 n的原根。</p><p>具体来说，如果对于模 n，存在一个整数 g，使得 g^k ≡ 1 (mod n) 当且仅当 k 是 n-1 的倍数，那么 g 就是模 n的原根。</p><p>原根具有以下性质：</p><ol><li>它的幂可以覆盖模 n的所有非零剩余类，即 {g^0, g^1, g^2, …, g^(n-2)} 对模 n取余的结果都不相同。</li><li>它的幂可以生成模 n的所有非零剩余类，即 {g^0, g^1, g^2, …, g^(n-2)} 对模 n取余的结果包含了 1 到 n-1 之间的所有非零剩余类。</li></ol><p>原根在数论和密码学中具有广泛的应用。它们在离散对数问题、离散对数算法、加密算法（如Diffie-Hellman密钥交换）和其他相关领域中起着重要作用。通过利用原根的性质，我们可以进行模运算、生成随机数、构造密码学协议等操作。</p></blockquote><p><strong>In a Verkle tree, on the other hand, you do not need to provide sister nodes; instead, you just provide the path, with a little bit extra as a proof.</strong></p><p>So <strong>what is this little extra that we need as a proof ? </strong>To understand that, we first need to circle back to one key detail: the hash function used to compute an inner node from its children is not a regular hash. Instead, it’s a <strong>vector commitment</strong>.</p><p>KZG承诺</p><p><a href="https://foresightnews.pro/article/detail/17988">https://foresightnews.pro/article/detail/17988</a></p><p><img src="/images/Ethereum/image-20230827203115042.png" alt="image-20230827203115042"></p><h2 id="智能合约执行模型"><a href="#智能合约执行模型" class="headerlink" title="智能合约执行模型"></a>智能合约执行模型</h2><p>来自 <a href="https://github.com/chaseSpace/learn_blockchain/blob/main/smart_contract.md">https://github.com/chaseSpace/learn_blockchain/blob/main/smart_contract.md</a></p><p>合约执行引擎还为合约执行提供上下文环境，包括账本数据的访问、外部数据的获取，最终将执行结果交由区块链共识模块进行全网一致性验证。</p><blockquote><p><img src="/images/Ethereum/image-20230823151225071.png" alt="image-20230823151225071"></p></blockquote><p><img src="/images/Ethereum/image-20230823165127227.png" alt="image-20230823165127227"></p><p><img src="/images/Ethereum/image-20230824095845585.png" alt="image-20230824095845585"></p><blockquote><p>EVM 可以获得完整世界状态，但看不见历史</p></blockquote><p><img src="/images/Ethereum/image-20230824095948635.png" alt="image-20230824095948635"></p><blockquote><p>（重要，以太坊书）<a href="https://github.com/ethereumbook/ethereumbook/tree/develop">https://github.com/ethereumbook/ethereumbook/tree/develop</a></p></blockquote><p><img src="https://github.com/ethereumbook/ethereumbook/blob/develop/images/evm-architecture.png?raw=true" alt="evm-架构.png"></p><h2 id="智能合约执行所需数据"><a href="#智能合约执行所需数据" class="headerlink" title="智能合约执行所需数据"></a>智能合约执行所需数据</h2><blockquote><p><img src="/images/Ethereum/image-20231030185756893.png" alt="image-20231030185756893"></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Phala_network</title>
    <link href="/2023/04/23/Phala-network/"/>
    <url>/2023/04/23/Phala-network/</url>
    
    <content type="html"><![CDATA[<h1 id="Phala-Network"><a href="#Phala-Network" class="headerlink" title="Phala Network"></a>Phala Network</h1><p><a href="http://www.lianchaguan.com/tag/phala">Phala</a></p><blockquote><p>Phala Network是一个基于Substrate开发的去中心化隐私计算平台，旨在为Web3.0提供高效、隐私安全、易扩展的计算支持。Phala Network的目标是为个人和企业提供具有隐私性、安全性和可扩展性的计算资源，并通过安全可靠的计算保护数据隐私。Phala Network采用TEE（Trusted Execution Environment）技术保证计算的隐私安全，采用PoC（Proof of Capacity）共识算法实现共识，同时结合了Substrate和Polkadot等区块链底层技术，具有高度的可扩展性。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arbitrum</title>
    <link href="/2023/04/21/Arbitrum/"/>
    <url>/2023/04/21/Arbitrum/</url>
    
    <content type="html"><![CDATA[<h1 id="Arbitrum-Scalable-private-smart-contracts"><a href="#Arbitrum-Scalable-private-smart-contracts" class="headerlink" title="Arbitrum: Scalable, private smart contracts"></a>Arbitrum: Scalable, private smart contracts</h1><p>Arbitrum官方写的<a href="https://github.com/OffchainLabs/arbitrum/blob/master/docs/Rollup_basics.md">Rollup_basics </a></p><p><a href="https://www.theblockbeats.info/news/36157">从白宫到Web3：扒一扒Arbitrum创始人Ed Felten的过往</a></p><p>[<a href="https://www.smartcontractresearch.org/t/research-summary-arbitrum-fast-scalable-private-smart-contracts/885">研究摘要：Arbitrum：快速、可扩展、私有的智能合约</a></p><h5 id><a href="#" class="headerlink" title></a><img src="/images/Arbitrum/image-20230423195431956.png" alt="image-20230423195431956" style="zoom:50%;"></h5><blockquote><p>在两个互不信任的个体之间处理事务，借助VM（其上运行智能合约），智能合约是该系统中的最主要的执行手段</p></blockquote><p><img src="/images/Arbitrum/image-20230423200020687.png" alt="image-20230423200020687" style="zoom:50%;"></p><blockquote><p>以太坊有严重的不可扩展性</p></blockquote><h3 id="Can-we-scale-smart-contracts"><a href="#Can-we-scale-smart-contracts" class="headerlink" title="Can we  scale smart contracts?"></a>Can we  scale smart contracts?</h3><blockquote><p>不在共识层，而是在智能合约层扩展</p></blockquote><p><img src="/images/Arbitrum/image-20230423200343624.png" alt="image-20230423200343624" style="zoom:50%;"></p><blockquote><p> 已有的解决的方案</p><p>snarks: 减少链上验证合约的cost</p></blockquote><p><img src="/images/Arbitrum/image-20230423201147818.png" alt="image-20230423201147818" style="zoom:50%;"></p><blockquote><p>Arbitrum 中两类角色 verifier /  Mangers</p><p>Verifier : 能取得共识的参与者统称为验证者，比如挖矿节点、中心可信方、BFT共识协议</p></blockquote><p><img src="/images/Arbitrum/image-20230423201329793.png" alt="image-20230423201329793" style="zoom:50%;"></p><p><img src="/images/Arbitrum/image-20230423201628883.png" alt="image-20230423201628883" style="zoom:50%;"></p><blockquote><p>举例子，两方下棋，Alice 和 Bob 都信任合约里设置好的关于棋局的规则代码。VM的任务是接收每一方的输入然后验证获胜的一方是谁，输出对局结果。这个例子中，底层区块链节点是verifier,参与者是Alice 和 Bob，manager也是 Alice 和 Bob，他们自己要负责跟踪这个合约是否正确执行以及决定之后要怎么进行下一步行动。如果他们俩不想当manager也可以找一个信任的第三方来当这个合约的管理者。</p></blockquote><h4 id="Manager到底对VM进行了哪些操作？"><a href="#Manager到底对VM进行了哪些操作？" class="headerlink" title="Manager到底对VM进行了哪些操作？"></a>Manager到底对VM进行了哪些操作？</h4><p><img src="/images/Arbitrum/image-20230423203110774.png" alt="image-20230423203110774" style="zoom:50%;"></p><h4 id="unanimous-assertion-一致性断言"><a href="#unanimous-assertion-一致性断言" class="headerlink" title="unanimous  assertion 一致性断言"></a>unanimous  assertion 一致性断言</h4><blockquote><ul><li>当前机器的状态</li><li>执行的步骤</li><li>执行后的结果的状态</li></ul><p>assertion 只知道外部执行结果但是不知道执行细节。执行完成后将其传递给blockchain,所有的manager对其进行签名，如果任务所有的先决条件正确，则该次状态改变将会被接受。</p></blockquote><p><img src="/images/Arbitrum/image-20230423204403811.png" alt="image-20230423204403811" style="zoom:50%;"></p><h4 id="disputable-assertion"><a href="#disputable-assertion" class="headerlink" title="disputable assertion"></a>disputable assertion</h4><blockquote><p>每个manager对VM都可以对做出自己的assertion。但是要存入资金？？？？、</p><p>如果有个manager 的结果被其他manager质询，如果确实该manager是错误的，他将会失去他的资金。</p></blockquote><p><img src="/images/Arbitrum/image-20230423205019413.png" alt="image-20230423205019413" style="zoom:50%;"></p><blockquote><p>一开始，某个断言仅仅被单个manager签名然后广播到区块链系统，开始质询阶段。其他所有的manager都能提供质询。</p><p>如果出现了质询，说明这个assertion出现了错误。最初的创建这个assertion的manager将会把这个断言分为两个部分，第一部分包含断言的第一步到结束阶段，二分法找错误（没有细看）</p></blockquote><p><img src="/images/Arbitrum/image-20230423210733179.png" alt="image-20230423210733179" style="zoom:50%;"></p><p><img src="/images/Arbitrum/image-20230423211004547.png" alt="image-20230423211004547" style="zoom:50%;"></p><blockquote><p>没看懂</p></blockquote><p><img src="/images/Arbitrum/image-20230423211141348.png" alt="image-20230423211141348" style="zoom:50%;"></p><p><img src="/images/Arbitrum/image-20230423211235876.png" alt="image-20230423211235876" style="zoom:50%;"></p><p>中间一段构建树没有听懂…..</p><p><img src="/images/Arbitrum/image-20230423211838112.png" alt="image-20230423211838112" style="zoom:50%;"></p><p><img src="/images/Arbitrum/image-20230423211944994.png" alt="image-20230423211944994" style="zoom:50%;"></p><p><img src="/images/Arbitrum/image-20230423212040551.png" alt="image-20230423212040551" style="zoom:50%;"></p><h2 id="其他论文的评价："><a href="#其他论文的评价：" class="headerlink" title="其他论文的评价："></a>其他论文的评价：</h2><ol><li><p>来自fastkitten</p><blockquote><p>Arbitrum The disadvantage of state channels, i.e., the potentially heavy on-chain execution in case of dispute, is being addressed by the work Arbitrum [34]. Every smart contract, which Arbitrum models as a virtual machine (VM), to be executed off-chain has a set of “manager” parties responsible for correct VM execution. As long as managers reach consensus on the VM state transitions, execution progresses off-chain similarly as in state channels. In case of dispute, managers do not perform the VM state transition on-chain as in state channel. Instead, one manager can propose the next VM state which other managers can challenge. If the newly posted state is challenged, the proposer and the challenger run an interactive protocol via the blockchain, so-called “bisection” protocol, in which one disputable computation step is eventually identified and whose correct execution is verified on-chain. Hence, instead of executing the entire state transition on-chain (which might potentially require a lot of time/space), only one computation step of the state transition has to be performed on-chain in addition to the bisection protocol (which might require O(log(s)) blockchain transactions, where s is the number of computations steps in the state transition). The Arbitrum protocol works under the assumption that at least one manager of the VM is honest and challenges false states if they are posted by other managers. Since the blockchain interaction during the bisection protocol is rather expensive, Arbitrum uses monetary incentives to motivate managers to behave honestly and follow the protocol.</p><p>Arbitrum 工作 Arbitrum [34] 正在解决状态通道的缺点，即在发生争议时可能会在链上执行大量任务。 Arbitrum 将其建模为虚拟机 (VM) 并在链下执行的每个智能合约都有一组“管理”方负责正确执行 VM。只要管理人员就 VM 状态转换达成共识，执行就会像在状态通道中一样在链外进行。在有争议的情况下，管理者不会像在状态通道中那样在链上执行 VM 状态转换。相反，一个管理器可以提议其他管理器可以挑战的下一个 VM 状态。如果新发布的状态受到挑战，提议者和挑战者通过区块链运行一个交互协议，即所谓的“二分法”协议，其中一个有争议的计算步骤最终被识别出来，并在链上验证其正确执行。因此，不是在链上执行整个状态转换（这可能需要大量的时间/空间），除了二分协议（这可能需要O(log(s)) 区块链事务，其中 s 是状态转换中的计算步骤数）。 Arbitrum 协议的工作假设是，至少有一名 VM 管理员是诚实的，如果其他管理员发布错误状态，则挑战这些错误状态。由于二分协议期间的区块链交互相当昂贵，Arbitrum 使用货币激励来激励管理者诚实行事并遵守协议。</p></blockquote></li><li><p>来自ACE</p><blockquote><p>Arbitrum [17] suggests a model where the contract creator appoints a small set of verifiers who should check execution integrity off-chain. Thus, Arbitrum replaces the sequential and globally-replicated execution model of Ethereum with one where different contracts can be executed (and thus verified) asynchronously by only few parties who may have an interest in the contract’s integrity.</p><p>Arbitrum [17]提出了一种模型，其中合约创建者指定一小组验证者，他们应该检查链下执行的完整性。因此，Arbitrum 取代了以太坊的顺序和全局复制的执行模型，其中不同的合约可以由可能对合约完整性感兴趣的少数方异步执行（从而验证）。</p></blockquote></li></ol><p>3.来自sok</p><blockquote><p>Arbitrum [44] takes this approach further by introducing a new virtual machine and a state channel. This lets a distributed set of parties execute a program in a custom virtual machine and unanimously agree to a commitment (i.e. state assertion) of the program’s new state. If co-operation in the state channel breaks down, then any party in the channel can compute a state transition and post a commitment to the new state to the blockchain (i.e. a disputable assertion). This triggers a similar dispute process to that used in Truebit, where any other party can challenge the assertion and participate in a bi-section protocol.</p><p>Arbitrum [44] 通过引入新的虚拟机和状态通道进一步采用了这种方法。这使得分布式各方可以在自定义虚拟机中执行程序，并一致同意程序新状态的承诺（即状态断言）。如果状态通道中的合作失败，则通道中的任何一方都可以计算状态转换并向区块链发布对新状态的承诺（即有争议的断言）。这会引发与 Truebit 中使用的类似争议流程，任何其他方都可以质疑该主张并参与二分协议。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fastkitten</title>
    <link href="/2023/04/12/fastkitten/"/>
    <url>/2023/04/12/fastkitten/</url>
    
    <content type="html"><![CDATA[<h1 id="FASTKITTEN-Practical-Smart-Contracts-on-Bitcoin"><a href="#FASTKITTEN-Practical-Smart-Contracts-on-Bitcoin" class="headerlink" title="FASTKITTEN: Practical Smart Contracts on Bitcoin"></a>FASTKITTEN: Practical Smart Contracts on Bitcoin</h1><h2 id="提及的资料"><a href="#提及的资料" class="headerlink" title="提及的资料"></a>提及的资料</h2><ol><li><p>和Ekiden对比</p><blockquote><p>Ekiden aims at moving heavy smart contract execution off the chain in order to reduce the cost of executing complex contract functions. In contrast, FASTKITTEN focuses on efficient off-chain execution of multi-round contracts between a set of parties. Importantly, we require our system to natively handle coins of the underlying blockchain.</p><p>Ekiden 旨在将繁重的智能合约执行移出链，以降低执行复杂合约功能的成本。相比之下，FASTKITTEN 侧重于在一组参与方之间高效地执行多轮合约。重要的是，我们要求我们的系统本地处理底层区块链的代币。</p></blockquote></li><li><p>前向加密forward secrecy</p></li><li><p>时间锁交易（Time-locked transactions）</p><blockquote><p>FASTKITTEN的主要目标是通过利用时间锁定交易的功能，允许用户在不直接支持复杂智能合约的加密货币上执行这些合约。它通过一种巧妙的方式，利用时间延迟，使得用户可以在一段时间后再提交交易，从而实现更复杂的合约逻辑。这种方式可以看作是一种“骗过”了加密货币的简单脚本限制，允许用户实现更高级的功能。</p><p>通过引入时间锁定交易和一些智能合约协议，FASTKITTEN能够在这些简单加密货币的基础上构建出更复杂的智能合约系统。这为用户提供了更大的灵活性和功能性，使得他们能够进行更多种类的交易和合约操作。</p></blockquote></li></ol><p><img src="/images/fastkitten/image-20230524195314317.png" alt="image-20230524195314317"></p><blockquote><p>向智能合约输入，就是创建一个交易，要等待打包、验证、确认，是很慢的，而且，不支持隐私输入</p></blockquote><p><img src="/images/fastkitten/image-20230524195504429.png" alt="image-20230524195504429"></p><blockquote><p>将智能合约运用到比特币上，核心想法是，不让智能合约在区块链上运行，但由区块链保证安全</p></blockquote><p><img src="/images/fastkitten/image-20230524195613060.png" alt="image-20230524195613060"></p><blockquote><p>涉及到的两个模块 TEE 和 blockchain</p></blockquote><p><img src="/images/fastkitten/image-20230524195754420.png" alt="image-20230524195754420"></p><p><img src="/images/fastkitten/image-20230524195919372.png" alt="image-20230524195919372"></p><p><img src="/images/fastkitten/image-20230524195927081.png" alt="image-20230524195927081"></p><blockquote><p>需要更特别的交易类型，比如，需要证明我们在特定时间知道区块链上的特定信息，第二个是时间锁</p></blockquote><p><img src="/images/fastkitten/image-20230524200135191.png" alt="image-20230524200135191"></p><h2 id="FASTKITTEN"><a href="#FASTKITTEN" class="headerlink" title="FASTKITTEN"></a>FASTKITTEN</h2><p><img src="/images/fastkitten/image-20230524200258318.png" alt="image-20230524200258318"></p><blockquote><ol><li><p>operator将罚金存到飞地中，飞地输出罚金存储的交易，但是有时间锁所以暂时不会验证</p><p><img src="/images/fastkitten/image-20230524200534907.png" alt="image-20230524200534907"></p></li><li><p>远程认证TEE是否初始完成，是否 真的运行正确的程序</p><p><img src="/images/fastkitten/image-20230524200734147.png" alt="image-20230524200734147"></p></li><li><p>将钱发送给TEE中的合约</p><p><img src="/images/fastkitten/image-20230524201602028.png" alt="image-20230524201602028"></p></li></ol></blockquote><p><img src="/images/fastkitten/image-20230524201807769.png" alt="image-20230524201807769"></p><p><img src="/images/fastkitten/image-20230524202032920.png" alt="image-20230524202032920"></p><blockquote><p>玩家向合约发送输入，因为加密所以operator无法知道输入，合约计算结果，再次输入，往复，直到有赢家。整个过程不产生去往区块链的交易数据，完全链下。</p></blockquote><p><img src="/images/fastkitten/image-20230524202139681.png" alt="image-20230524202139681"></p><blockquote><p>链下合约生成对局结果的转账交易，发送给区块链完成转账，拿回自己之前的押金</p></blockquote><h2 id="出现恶意的情况"><a href="#出现恶意的情况" class="headerlink" title="出现恶意的情况"></a>出现恶意的情况</h2><p><img src="/images/fastkitten/image-20230524202334225.png" alt="image-20230524202334225"></p><h2 id="恶意operator"><a href="#恶意operator" class="headerlink" title="恶意operator"></a>恶意operator</h2><p><img src="/images/fastkitten/image-20230524202616080.png" alt="image-20230524202616080"></p><h2 id="恶意用户"><a href="#恶意用户" class="headerlink" title="恶意用户"></a>恶意用户</h2><blockquote><p>开启链上质询，检查质询和回复的情况，要是有质询有回复则继续，否则开始惩罚，（检查哪一方是表现不对的一方</p><p>当alice不回复时，operator需要证明确实是Alice不回复了，开启质询。</p></blockquote><p><img src="/images/fastkitten/image-20230524203147044.png" alt="image-20230524203147044"></p><blockquote><p>operator将相关的区块发送给TEE，TEE判断后生成最终的交易，在这个场景中Alice就拿不回钱了</p></blockquote><p><img src="/images/fastkitten/image-20230524203522546.png" alt="image-20230524203522546"></p><p><img src="/images/fastkitten/image-20230524203752321.png" alt="image-20230524203752321"></p><h2 id="对operator有抵押的要求"><a href="#对operator有抵押的要求" class="headerlink" title="对operator有抵押的要求"></a>对operator有抵押的要求</h2><blockquote><p>抵押的数量至少等于参与方的抵押总数</p></blockquote><p><img src="/images/fastkitten/image-20230524204157295.png" alt="image-20230524204157295"></p><h2 id="与现有方案对比"><a href="#与现有方案对比" class="headerlink" title="与现有方案对比"></a>与现有方案对比</h2><p><img src="/images/fastkitten/image-20230524204351058.png" alt="image-20230524204351058"></p><p><img src="/images/fastkitten/image-20230524204521541.png" alt="image-20230524204521541"></p><p>论文分享：<a href="https://zhuanlan.zhihu.com/p/89090472">https://zhuanlan.zhihu.com/p/89090472</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Plasma</title>
    <link href="/2023/04/12/Plasma/"/>
    <url>/2023/04/12/Plasma/</url>
    
    <content type="html"><![CDATA[<hr><p>其他论文对其评价</p><ol><li><p>来自Arbitrum</p><blockquote><p>Plasma [28] attempts to achieve scaling on top of Ethereum by introducing the concept of childchains. Child-chains use their own consensus mechanism to choose which transactions to publish. This consensus mechanism enforces rules which are encoded in a smart contract placed in Ethereum. If a user on the child-chain believes that the child-chain has behaved incorrectly or maliciously, they can submit a fraud proof to the contract on the main chain in order to exit the childchain with their funds. This approach suffers from a number of problems. Firstly, similarly to sharding, Plasma child-chains each exist in their own isolated world, so interaction between people on different child-chains is cumbersome. Secondly, the details of how complex fraud proofs could actually be constructed inside a Plasma contract are lacking. Plasma contracts need to somehow specify all of the consensus rules and ways to prove fraud on a newly defined blockchain which is a complex and currently unsolved problem inside an Ethereum contract. Finally, moving data out of the main blockchain creates data availability challenges since in order to generate a fraud proof you must have access to the data in a Plasma block and there is no guaranteed mechanism for accessing this data. Because of this issue, Plasma includes many mitigations which involve users exiting a Plasma blockchain if anything goes wrong.</p><p>Plasma [28] 试图通过引入子链的概念在以太坊之上实现扩展。子链使用自己的共识机制来选择要发布的交易。这种共识机制执行编码在以太坊智能合约中的规则。如果子链上的用户认为子链行为不当或恶意，他们可以向主链上的合约提交欺诈证明，以便用他们的资金退出子链。这种方法存在许多问题。首先，与分片类似，Plasma 子链各自存在于自己的孤立世界中，因此不同子链上的人之间的交互很麻烦。其次，缺乏关于如何在 Plasma 合约中实际构建复杂欺诈证明的细节。 Plasma 合约需要以某种方式指定所有共识规则和方法来证明新定义的区块链上的欺诈，这是以太坊合约中一个复杂且目前尚未解决的问题。最后，将数据移出主区块链会带来数据可用性挑战，因为为了生成欺诈证明，您必须能够访问 Plasma 块中的数据，并且没有保证访问此数据的机制。由于这个问题，Plasma 包含许多缓解措施，如果出现任何问题，用户将退出 Plasma 区块链。</p><p>Due to the complexities of implementing Plasma child-chains with smart contract capabilities like Ethereum, all current efforts to implement Plasma use simple UTxO based systems without scripting in order allow simple proofs. Plasma proposes using TrueBit as a sub-component for efficient fraud proofs in child chains with smart contracts, but as mentioned TrueBit uses an off-the-shelf VM which does not give guarantees on proof size or efficiency. Indeed, Plasma may benefit from using the Arbitrum Virtual Machine.</p><p>由于实施具有智能合约功能的 Plasma 子链（如以太坊）的复杂性，目前实施 Plasma 的所有努力都使用简单的基于 UTxO 的系统，而无需编写脚本以允许简单的证明。 Plasma 提议使用 TrueBit 作为子组件，在具有智能合约的子链中进行有效的欺诈证明，但如前所述，TrueBit 使用现成的 VM，它不能保证证明的大小或效率。事实上，Plasma 可能会受益于使用 Arbitrum 虚拟机。</p></blockquote></li><li><p>来自fastkitten</p><blockquote><p>Plasma Another promising second-layer scaling solution is Plasma, first introduced by Poon and Buterin [55]. The main idea of Plasma is to build new chains (Plasma chains) on top of the Ethereum blockchain. Each Plasma chain has its own operator that is responsible for validating transactions and regularly posting a short commitment about the current state of the Plasma chain to a smart contract on the Ethereum blockchain. The regular commitments guarantee to the participants of the Plasma chain that in case the operator cheats, his misbehavior can be proven to the Ethereum smart contract and parties can exit the Plasma chain with all their funds. While the original goal of Plasma [55] was to support arbitrary complex smart contracts, to the best of our knowledge, there is no concrete protocol that would achieve this goal (the existing Plasma designs support only payment transactions). Moreover, the plasma research community currently conjectures that Plasma with general smart contracts might be impossible to construct [8].</p><p>Plasma 另一个有前途的第二层扩展解决方案是 Plasma，它首先由 Poon 和 Buterin [55] 提出。 Plasma 的主要思想是在以太坊区块链之上构建新链（Plasma 链）。每个 Plasma 链都有自己的运营商，负责验证交易并定期向以太坊区块链上的智能合约发布关于 Plasma 链当前状态的简短承诺。定期承诺向 Plasma 链的参与者保证，如果运营商作弊，他的不当行为可以向以太坊智能合约证明，并且各方可以用他们所有的资金退出 Plasma 链。虽然 Plasma [55] 的最初目标是支持任意复杂的智能合约，但据我们所知，没有具体的协议可以实现这一目标<strong>（现有的 Plasma 设计仅支持支付交易）</strong>。此外，Plasma 研究界目前推测，具有通用智能合约的 Plasma 可能无法构建 [8]。</p></blockquote></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ekiden</title>
    <link href="/2023/04/10/Ekiden/"/>
    <url>/2023/04/10/Ekiden/</url>
    
    <content type="html"><![CDATA[<h4 id="Ekiden"><a href="#Ekiden" class="headerlink" title="Ekiden"></a>Ekiden</h4><blockquote><p>用 Tendermint as the consensus layer</p></blockquote><p>团队推文：<a href="https://medium.com/phala-network/ekiden-an-oasis-of-scalability-experiment-5a6bee3a65c8">https://medium.com/phala-network/ekiden-an-oasis-of-scalability-experiment-5a6bee3a65c8</a></p><p>团队主页：<a href="https://oasisprotocol.org/technology#papers">https://oasisprotocol.org/technology#papers</a></p><blockquote><p>以太坊之所以效率低下，是因为它把共识、存储和计算放在了同一层，这也是 Ekiden 的结构分为 4 层的原因：</p><ul><li>应用层</li><li>计算层</li><li>存储层</li><li>共识层</li></ul><p>计算、存储和一致性的解耦对于实现高性能和安全性至关重要。</p><p>任何基于以太坊的 Dapps 都可以应用 Ekiden 作为扩容解决方案。由于 Ekiden 与 Rust 和 EVM 的兼容性，开发者可以更方便地在 Ekiden 上进行开发。这就是为什么 Ekiden 在开发者和用户的数量上比其他高吞吐量区块链具有明显的优势。</p><p>我们知道，在传统链中，每个节点都会依次执行区块中的所有交易。共识协议确保每个节点可以轻松地相互调用，因为它们共享一个完整且一致的数据库；<strong>Ekiden 高效、安全、健壮，但其合约之间不允许相互调用或访问。</strong>?????</p><p><strong>It results in an increase of scalability as consensus layer focusing on results. </strong> ==链下执行系统核心思路。==</p><p>Still, A flaw exists: application value is reduced due to weakened composability. While emphasizing independent execution of contracts, Ekiden sacrifices mutual operation, for their confidential contracts can only be performed by local computation.</p><p>==Take Ethereum as an example (again). As we know, in traditional chains, each node will sequentially execute all transactions in the block. Consensus protocol ensures each node could easily call each other for they share a complete and consistent database; Ekiden is efficient, secure, and robust, but its contracts are not allowed to call or access to each other.==</p></blockquote><p>其他论文对Ekiden的评价：</p><ol><li><p>来自POSE</p><blockquote><p>Ekiden [20] is also an off-chain execution system that leverages TEE-enabled compute nodes to perform computation and regular consensus nodes that interact with a blockchain. The major drawback of Ekiden is that it requires every computation step to retrieve its initial status from the blockchain, and it only supports input from one client at a time. Moreover, the atomic delivery of the output of each step requires to wait for publication of the updated state before the output is made available to the client. Hence, any highly interactive protocol with multiple participants (like a card game, for instance) would incur significant delays between turns just to wait for the blockchain. The paper evaluates Ekiden on a fast blockchain, Tendermint, but it does not quantify its latency for interactive protocols on mainstream blockchains like Ethereum or Bitcoin. The Oasis Network uses an updated version of Ekiden [30]; yet, this version still requires to store state on the blockchain after each call.</p><p>Ekiden [20] 也是一个链下执行系统，它利用支持 TEE 的计算节点来执行与区块链交互的计算和常规共识节点。 Ekiden 的主要缺点是它需要每个计算步骤都从区块链中检索其初始状态，并且它一次只支持来自一个客户端的输入。 此外，每个步骤输出的原子交付需要等待更新状态的发布，然后才能将输出提供给客户端。 因此，任何具有多个参与者的高度交互协议（例如纸牌游戏）都会在轮次之间产生明显的延迟，只是为了等待区块链。 该论文在快速区块链 Tendermint 上评估了 Ekiden，但它没有量化其在主流区块链（如以太坊或比特币）上的交互协议的延迟。 Oasis Network 使用更新版本的 Ekiden [30]； 然而，这个版本仍然需要在每次调用后将状态存储在区块链上。</p></blockquote></li><li><p>来自Astraea</p><blockquote><p>To take advantage of the two techniques, Cheng et al. proposed Ekiden, a system for highly performant and confidentialitypreserving SCs [37]. Ekiden is enabled by a delicate and secure integration of blockchains and trusted hardware that separates computation from consensus. Compute nodes are used to execute SC computation over private data off chain in TEEs, then attest to their correct execution on chain. The blockchain is maintained by consensus nodes which are not equipped with trusted hardware. </p><p>为了利用这两种技术，Cheng等人提出了Ekiden，一种高性能和保密SC的系统[37]。Ekiden是通过区块链和可信硬件的微妙和安全集成实现的，该集成将计算与共识分开。计算节点用于在TEE中对私有数据链下执行SC计算，然后证明它们在链上的正确执行。区块链由未配备可信硬件的共识节点维护。,</p></blockquote></li><li><p>来自 Arbitrum</p><blockquote><p>Ekiden hides the state from external parties and also allows parties of a contract to hide private inputs from one another. The drawback of Ekiden and systems that rely on TEEs more generally is the additional trust required for both privacy as well as the correctness of contract execution. This includes both trusting that the hardware is executing correctly and privately as well as trusting the issuer of the attestation keys (e.g., Intel).</p><p>Ekiden 对外部各方隐藏状态，还允许合同各方对彼此隐藏私人输入。 Ekiden 和更普遍地依赖 TEE 的系统的缺点是隐私和合约执行的正确性需要额外的信任。这包括相信硬件正在正确和私密地执行，以及相信证明密钥的发行者（例如，英特尔）。</p></blockquote></li><li><p>来自 FastKitten</p><blockquote><p>比较多</p></blockquote></li><li><p>来自ACE</p><blockquote><p>Ekiden [8] uses Trusted Execution Environments (TEEs), namely SGX enclaves, to execute smart contracts. The main motivation of Ekiden is to enable confidential contracts, rather than complex ones, but since execution is decoupled from consensus, Ekiden can serve this purpose as well.</p><p>Ekiden [8] 使用可信执行环境（TEE），即 SGX enclaves，来执行智能合约。 Ekiden 的主要动机是实现机密合约，而不是复杂的合约，但由于执行与共识脱钩，Ekiden 也可以达到此目的。</p></blockquote></li></ol><p>提及的资料：</p><ol><li><p>安全协议威胁分析范式</p><p>Universally Composable Security: A New Paradigm for Cryptographic Protocols</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>blockchain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mess</title>
    <link href="/2023/04/03/mess/"/>
    <url>/2023/04/03/mess/</url>
    
    <content type="html"><![CDATA[<hr><ul><li><p>分布式共识协议 </p><p><a href="http://www.calvinneo.com/2017/09/20/distributed-system-consistency-and-consensus/">http://www.calvinneo.com/2017/09/20/distributed-system-consistency-and-consensus/</a></p><blockquote><p><img src="/images/mess/image-20230403212321366.png" alt="image-20230403212321366"></p></blockquote></li></ul><h4 id="分布式共识"><a href="#分布式共识" class="headerlink" title="分布式共识"></a>分布式共识</h4><p><a href="https://yeasy.gitbook.io/blockchain_guide/04_distributed_system/algorithms">https://yeasy.gitbook.io/blockchain_guide/04_distributed_system/algorithms</a></p><h1 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h1><p>共识（Consensus）这个术语很多时候会与一致性（Consistency）术语放在一起讨论。严谨地讲，两者的含义并不完全相同。</p><p>一致性的含义比共识宽泛，在不同场景（基于事务的数据库、分布式系统等）下意义不同。具体到分布式系统场景下，一致性指的是多个副本对外呈现的状态。如前面提到的顺序一致性、线性一致性，描述了多节点对数据状态的共同维护能力。而共识，则特指在分布式系统中多个节点之间对某个事情（例如多个事务请求，先执行谁？）达成一致看法的过程。因此，达成某种共识并不意味着就保障了一致性。</p><p>实践中，要保障系统满足不同程度的一致性，往往需要通过共识算法来达成。</p><p>共识算法解决的是分布式系统对某个提案（Proposal），大部分节点达成一致意见的过程。提案的含义在分布式系统中十分宽泛，如多个事件发生的顺序、某个键对应的值、谁是主节点……等等。可以认为任何可以达成一致的信息都是一个提案。</p><p>对于分布式系统来讲，各个节点通常都是相同的确定性状态机模型（又称为状态机复制问题，State-Machine Replication），从相同初始状态开始接收相同顺序的指令，则可以保证相同的结果状态。因此，系统中多个节点最关键的是对多个事件的顺序进行共识，即排序。</p><p><em>注：计算机世界里采用的是典型的“多数人暴政”，足够简单、高效。</em></p><h2 id="问题与挑战"><a href="#问题与挑战" class="headerlink" title="问题与挑战"></a>问题与挑战</h2><p>无论是在现实生活中，还是计算机世界里，达成共识都要解决两个基本的问题：</p><ul><li><p>首先，如何提出一个待共识的提案？如通过令牌传递、随机选取、权重比较、求解难题等；</p></li><li><p>其次，如何让多个节点对该提案达成共识（同意或拒绝），如投票、规则验证等。</p></li></ul><p>理论上，如果分布式系统中各节点都能以十分“理想”的性能（瞬间响应、超高吞吐）稳定运行，节点之间通信瞬时送达（如量子纠缠），则实现共识过程并不十分困难，简单地通过广播进行瞬时投票和应答即可。</p><p>可惜的是，现实中这样的“理想”系统并不存在。不同节点之间通信存在延迟（光速物理限制、通信处理延迟），并且任意环节都可能存在故障（系统规模越大，发生故障可能性越高）。如通信网络会发生中断、节点会发生故障、甚至存在被入侵的节点故意伪造消息，破坏正常的共识过程。</p><p>一般地，把出现故障（Crash 或 Fail-stop，即不响应）但不会伪造信息的情况称为“非拜占庭错误（Non-Byzantine Fault）”或“故障错误（Crash Fault）”；伪造信息恶意响应的情况称为“拜占庭错误”（Byzantine Fault），对应节点为拜占庭节点。显然，后者场景中因为存在“捣乱者”更难达成共识。</p><p>此外，任何处理都需要成本，共识也是如此。当存在一定信任前提（如接入节点都经过验证、节点性能稳定、安全保障很高）时，达成共识相对容易，共识性能也较高；反之在不可信的场景下，达成共识很难，需要付出较大成本（如时间、经济、安全等），而且性能往往较差（如工作量证明算法）。</p><p><em>注：非拜占庭场景的典型例子是通过报数来统计人数，即便偶有冲突（如两人同时报一个数）也能很快解决；拜占庭场景的一个常见例子是“杀人游戏”，当参与者众多时很难快速达成共识。</em></p><h2 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h2><p>根据解决的场景是否允许拜占庭错误情况，共识算法可以分为 Crash Fault Tolerance (CFT) 和 Byzantine Fault Tolerance（BFT）两类。</p><p>对于非拜占庭错误的情况，已经存在不少经典的算法，包括 Paxos（1990 年）、Raft（2014 年）及其变种等。这类容错算法往往性能比较好，处理较快，容忍不超过一半的故障节点。</p><p>对于要能容忍拜占庭错误的情况，包括 PBFT（Practical Byzantine Fault Tolerance，1999 年）为代表的确定性系列算法、PoW（1997 年）为代表的概率算法等。确定性算法一旦达成共识就不可逆转，即共识是最终结果；而概率类算法的共识结果则是临时的，随着时间推移或某种强化，共识结果被推翻的概率越来越小，最终成为事实上结果。拜占庭类容错算法往往性能较差，容忍不超过 1/3 的故障节点。</p><p>此外，XFT（Cross Fault Tolerance，2015 年）等最近提出的改进算法可以提供类似 CFT 的处理响应速度，并能在大多数节点正常工作时提供 BFT 保障。</p><p>Algorand 算法（2017 年）基于 PBFT 进行改进，通过引入可验证随机函数解决了提案选择的问题，理论上可以在容忍拜占庭错误的前提下实现更好的性能（1000+ TPS）。</p><p><em>注：实践中，对客户端来说要拿到共识结果需要自行验证，典型地，可访问足够多个服务节点来比对结果，确保获取结果的准确性。</em></p><h2 id="理论界限"><a href="#理论界限" class="headerlink" title="理论界限"></a>理论界限</h2><p>科学家都喜欢探寻问题最坏情况的理论界限。那么，共识问题的最坏界限在哪里呢？很不幸，在推广到任意情况时，分布式系统的共识问题无通用解。</p><p>这似乎很容易理解，当多个节点之间的通信网络自身不可靠情况下，很显然，无法确保实现共识（例如，所有涉及共识的消息都丢失）。那么，对于一个设计得当，可以大概率保证消息正确送达的网络，是不是一定能获得共识呢？</p><p>理论证明告诉我们，<strong>即便在网络通信可靠情况下，一个可扩展的分布式系统的共识问题通用解法的下限是——没有下限（无解）。</strong></p><p>这个结论，被称为“FLP 不可能原理”。该原理极其重要，可以看做是分布式领域里的“测不准原理”。</p><p><em>注：不光分布式系统领域，实际上很多领域都存在类似测不准原理的约束，或许说明世界本源就存在限制。</em></p><h2 id="raft-paxos动画演示"><a href="#raft-paxos动画演示" class="headerlink" title="raft/paxos动画演示"></a>raft/paxos动画演示</h2><p><a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p><p><a href="http://harry.me/blog/2014/12/27/neat-algorithms-paxos/">http://harry.me/blog/2014/12/27/neat-algorithms-paxos/</a></p><h2 id="TEE"><a href="#TEE" class="headerlink" title="TEE"></a>TEE</h2><p><a href="https://github.com/Tencent/soter/wiki/%E5%8E%9F%E7%90%86">https://github.com/Tencent/soter/wiki/%E5%8E%9F%E7%90%86</a></p><p>TENCENT SOTER之所以能实现支付级别的指纹授权安全性，主要原因有三：</p><ul><li>所有关键数据存储与操作均根本依赖TEE</li><li>厂商在设备出厂之前安全环境会专门生成TENCENT SOTER设备根密钥</li><li>生物授权的实质是密钥签名，TEE级别保证“无授权，不签名”。</li></ul><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="https://github.com/WeMobileDev/article/raw/master/assets/soter/SoterFramework.png" alt="FD5DC4F4-B49B-4502-B2DE-836BB33B5627" style="zoom:50%;"></p><p>TENCENT SOTER中，一共有三个级别的密钥：ATTK，App Secure Key(ASK)以及AuthKey。这些密钥都是RSA-2048的非对称密钥。</p><p>所有的密钥都由<a href="https://en.wikipedia.org/wiki/Trusted_execution_environment">TEE</a>（一个独立于Android系统的安全环境，这也是TENCENT SOTER能解决root下手机认证的关键所在）保护安全保存。这也就意味着除了数据所有者之外，没有人可以使用私钥。更重要的是，如果密钥是在TEE中生成的，所有人——包括微信、厂商等——都无法得到密钥私钥。一句话总结，TENCENT SOTER中所有非对称密钥均是在TEE内部生成的，即使设备被root，私钥也不会泄露。</p><p>除了密钥之外，TENCENT SOTER所有关键流程，如签名等，均在TEE中进行，这也保证了核心流程不会被恶意应用篡改。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul><li>ATTK（设备密钥）私钥在设备出厂之前就已经在TEE中生成，公钥被被厂商安全得传输到腾讯的TAM服务器，私钥则在TEE中安全存储。 <img src="https://github.com/WeMobileDev/article/raw/master/assets/soter/%E5%87%86%E5%A4%87%E6%A0%B9%E5%AF%86%E9%92%A5.gif" alt="prepare_attk"></li><li>第三方应用能且只能在TEE中生成唯一ASK（应用密钥）。一旦ASK被成功生成，私钥被存储在TEE中（或者更加准确地说，被TEE中安全密钥加密存储在手机sfs中，等同于存储在TEE中，即使手机被root了也是安全的）。公钥结构体（包含公钥信息以及其他辅助信息）导出的时候会自动带上ATTK对公钥数据的签名。应用开发者将公钥结构体以及ATTK对该结构体的签名通过微信开放平台接口（见接口文档）发送到TAM服务器认证公钥结构体合法性。如果合法，则第三方保存该结构体备用。 <img src="https://github.com/WeMobileDev/article/raw/master/assets/soter/%E5%87%86%E5%A4%87%E5%BA%94%E7%94%A8%E5%AF%86%E9%92%A5.gif" alt="prepare_ask"></li><li>对于每一个业务场景，你应该生成一对AuthKey（业务密钥）用于该场景指纹认证。AuthKey的生成过程与ASK类似——在TEE中生成，私钥在TEE中保存，公钥上传到服务器。不同的是，第三方应用应该自己检查AuthKey的合法性（实际上，我们真的不想知道你们的用户做了多少笔支付）。同时，生成AuthKey的时候，需要标记私钥只有在用户指纹授权之后才可以使用（正如Google在标准接口中定义的那样）。 <img src="https://github.com/WeMobileDev/article/raw/master/assets/soter/%E5%87%86%E5%A4%87%E4%B8%9A%E5%8A%A1%E5%AF%86%E9%92%A5.gif" alt="prepare_authkey"></li><li>在认证之前，应用需要先向自己的服务器请求一个挑战因子（通常是一个随机串）作为用于签名的对象。用户指纹授权之后，你将可以导出一个JSON结果，其中包含了你刚刚请求的挑战因子、用户使用了哪个手指（fid）以及其他设备信息，和这个JSON结果对应AuthKey的签名。之后，将他们发送到自己的服务器，自己使用之前存储的AuthKey公钥验签就好。其中，fid也是在TEE中自动读取并连同结果一起被签名的，也就是说，黑客是无法伪造。 <img src="https://github.com/WeMobileDev/article/raw/master/assets/soter/%E8%AE%A4%E8%AF%81%E6%88%96%E5%BC%80%E9%80%9A.gif" alt="auth"></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>op_git</title>
    <link href="/2023/03/25/op-git/"/>
    <url>/2023/03/25/op-git/</url>
    
    <content type="html"><![CDATA[<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>复制已有GitHub仓库地址/新建后复制</p><p>``</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>进入想要上传的项目根目录，git bash</p><p>输入 <code>git init</code></p><p>输入 <code>git add</code> . 添加所有文件</p><p>输入 <code>git commit -m &#39;init&#39;</code> 添加到本地仓库</p><p>输入 <code>git remote add origin 你的仓库地址</code> 添加一个远程主机名，主机名为origin</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git push -u origin <span class="hljs-keyword">master</span> <span class="hljs-title">将本地的代码上传到远程仓库</span><br><span class="hljs-title">查看远程仓库现有  git</span> remote -v<br><br></code></pre></td></tr></table></figure><p><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html">http://www.ruanyifeng.com/blog/2014/06/git_remote.html</a></p><p><a href="https://backlog.com/git-tutorial/cn/stepup/stepup1_3.html">https://backlog.com/git-tutorial/cn/stepup/stepup1_3.html</a></p>]]></content>
    
    
    <categories>
      
      <category>tool</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POSE</title>
    <link href="/2023/03/15/POSE/"/>
    <url>/2023/03/15/POSE/</url>
    
    <content type="html"><![CDATA[<h4 id="POSE-Practical-Off-chain-Smart-Contract-Execution"><a href="#POSE-Practical-Off-chain-Smart-Contract-Execution" class="headerlink" title="POSE: Practical Off-chain Smart Contract Execution"></a>POSE: Practical Off-chain Smart Contract Execution</h4><blockquote><p>传统链上智能合约执行代价高，限制了区块链的性能。</p><p>A prominent solution to address this problem is to <strong>execute code off-chain and only use the blockchain as a trust anchor</strong>.</p></blockquote><p>motivation</p><blockquote><p>链下系统迅速发展，但是目前的链下系统有以下缺点：costly blockchain interactions, lack of data privacy, huge capital costs from locked collateral, or supporting only a restricted set of applications.</p></blockquote><p>提出POSE——a practical off-chain protocol for smart contracts that addresses the aforementioned shortcomings of existing solutions.</p><p>POSE——面向permissionless区块链的新型的链下智能合约执行框架。每个智能合约都在注册后的TEE池中随机选取TEE来执行。</p><p>假设：</p><ol><li>TEE是安全的，论文中提到了TEE侧信道攻击的缓解措施。</li><li>TEE能够提供安全的远程认证技术</li></ol><p>POSE协议包括：</p><ol><li>users:提供输入，与智能合约交互，获得输出</li><li>operators:拥有并管理基于TEE的系统，通过使用TEE向POSE网络提供计算能力，飞地中来执行用户所触发的状态转换</li><li>manager——a simple on-chain smart contract ：管理链下的飞地执行单元</li></ol><p><strong>本文不限制TEE具体实现，但用ARM TrustZone做本文的实验</strong></p><p>workflow:</p><blockquote><p> 在智能合约创建之前，TEE已经利用manager进行了注册 ——详细见V-E1</p><p><img src="/images/POSE/image-20230317101317721.png" alt="image-20230317101317721"></p><ol><li>用户调用manager 初始化合约创建，以创建POSE合约，该过程包括在注册集合中选择飞地，执行之后创建的链下合约</li><li>选择好的creator飞地将对给定的智能合约建立execution pool(pool size is set to 3)</li><li>creator 随机选择已经在系统中注册好的3个飞地</li><li>creator  将提交最终的智能合约信息给manager，信息包括：选择出的负责执行POSE合约的飞地的信息，watchdog 保证可用性</li><li>其他用户可以调用这个新的合约，调用方式是直接联系executor</li><li>executor 将执行用户的智能合约，调用并广播最终结果的状态给watchdog enclaves(确定状态更新) V-E3</li></ol><p>在这个过程中，如果某个飞地崩溃了，依赖方可以在 the dependent parties can challenge the enclave on the blockchain（不懂，见V-E4），依赖方可以是等待执行者响应的用户，也可以是等待看门狗确认的执行者。</p><p>举个:hamburger:：如果executor停止执行合约，该executor将受到用户的质询，这种及时的响应A timely response constitutes a successful state transition as requested by the user.（这句在说啥）。否则，如果当前的executor不响应，watchdog将填补executor的位置。这种机制让POSE具有高可用性，前提是至少有一个watchdog是可靠的。</p><p>; thus, avoiding the need for collateral to incentivize correct behavior. Further, POSE supports private state, as the state is only securely shared with other enclaves.</p></blockquote><p>安全挑战</p><p>恶意操作：执行器，看门狗，飞地都能被硬件操作者恶意攻击，比如提供恶意输入，修改用户信息，重入攻击，阻止消息进入等。其中恶意输入和修改用户信息可以用安全签名等标准的措施来防范。</p><p>强可用性：让依赖方可以通过区块链质询无反应的操作者，受到质询的操作者要么立刻提供有效的回应让依赖方可以完成状态转移，要么将被从执行池中删除</p><p>与区块链同步：</p><p>参考：飞地执行智能合约，但飞地不能直接获取区块链的数据，需要通过operator,但operator可修改数据或者延迟提供数据（不提供最新数据），要保证飞地能够拿到正确的最新的数据而不用存储整条链，而设计一种同步机制。</p><p>降低与区块链的交互：减少链上计算。在乐观的情况下，唯一必要的链上交易是合约创建和代币转移。（？？）</p><p>支持私有状态：状态只输出给所有执行池都承认的状态</p><p>POSE设计：</p><p>The POSE protocol considers four different roles: <strong>a manager smart contract deployed to the blockchain, operators that run TEEs, enclaves that are installed within TEEs, and users that create and interact with POSE contracts.</strong></p><p>尝试找出workflow:</p><p>每次调用飞地时，它将自己与区块链网络同步并获取最新的数据。</p><p>运行POSE程序的飞地只接收已签名的消息作为输入</p><p>POSE 支持任意智能合约但必须实现特定接口</p><p>我们设计了一种同步机制，允许 E注册过的飞地同步自身而无需验证整个块。、</p><p>1）飞地注册</p><blockquote><p>某个operator拥有一些TEE单元可用于POSE系统。为了构建适用于POSE系统的飞地，这些TEE首先要被POSE程序初始化。</p><p>初始化过程中：生成不对称密钥对（PK，SK），SK保存在飞地内部，仅可被飞地内的POSE程序获得。PK作为输出传递给operator,operator用TEE生成远程证明，表面已经生成了适用于POSE系统的飞地并控制了相应的密钥PK，最后operator将最新的$\gamma + 1$ 个区块头以及相关的区块数据发送给POSE飞地，飞地将验证区块完整性并返回区块证明（包含块hash以及飞地所知道的最新区块信息的签名的元组）</p><p>operator 创建了新的飞地后，将发送消息m给manager,manager验证相关信息正确性。</p></blockquote><p>2）创建合约</p><blockquote><p>user选择任意注册过的飞地，发送一个创建初始化请求给manager,请求包括hash(code)以及飞地信息。manager分配一个新的合约元组，并给定标识符。用户的请求信息被分发给所有的池中的飞地，它们可以给出确定，最后，新注册的飞地签署一个注册确认信息，提交给manager，表明合约注册了。如果改过程中合约超时未发送确认，user将发出一个创建质询，如果飞地池中没有及时响应新注册的飞地。新注册的飞地将会发出pool质询</p></blockquote><p>3）合约执行</p><blockquote><p>user发送执行合约请求给控制飞地E的operator,飞地E执行请求并将新状态传递到飞地pool中所有成员，称为watchdog,如果watchdog没有及时确认，就会被飞地E质询。最终飞地E收到所有watchdog的确认，要么没回复的被踢出pool.飞地E输出最新的public state给user,在所有成员都同意更新之前，该状态不会被广播。飞地E若被踢出后，会有一个$E’$代替</p><p>POSE系统确保在下一次成功执行之前，所有的合约的状态都保持一致</p></blockquote><p>4）质询</p><blockquote><p>如果任何一方在链下执行期间没有收到对其消息的及时响应，它就会挑战链上的接收者。</p></blockquote><p><a href="https://www.semanticscholar.org/paper/POSE%3A-Practical-Off-chain-Smart-Contract-Execution-Frassetto-Jauernig/c6e55929207c9e91475aeb1a6407db2eb39443d8#related-papers">https://www.semanticscholar.org/paper/POSE%3A-Practical-Off-chain-Smart-Contract-Execution-Frassetto-Jauernig/c6e55929207c9e91475aeb1a6407db2eb39443d8#related-papers</a></p><p>类似利用TEE 的链下系统：</p><ol><li><p>POSE和Ekiden的区别是POSE支持更多的智能合约，在不需要预定义参与者和保证金的情况下，能够支持未知数量的参与者和长寿命的智能合约，且POSE能在拜占庭敌手的存在下实现强活性保证。相比之下，Ekiden在执行智能合约时需要从区块链检索其初始状态，仅支持来自一个客户端的输入，并需要等待更新状态的发布才能公开输出，针对互动性较强的协议如卡牌游戏会引起显著的延迟。FastKitten假设理性攻击者模型，并要求合同有预定义参与者和有限的生命周期，TEE运营者需要作为抵押向每个参与者存款。而POSE通过随机分配TEE来降低中心化风险。</p></li></ol><p>根据论文中提到的参数选择公式，当$L=300$，$\tau_p=25\cdot L$时，可以计算出$\tau_p=7500$。同时，根据平均出块时间约为$13$秒的信息，$L=300$个区块需要的时间为$13\cdot300=3900$秒。因此，整个过程需要的时间为$\tau_p+L$，即$7500+3900=11400$秒。</p><p>假设有一半的计算能力是恶意的，则攻击者在$11400$秒内可以挖出$\frac{1}{2}\cdot11400\div13\approx4400$个块，而诚实的矿工只能挖出$300$个块。因此，攻击者在相同时间内比诚实的矿工多出大约$15$倍的块数，即$\frac{4400}{300}\approx14.7$。</p><p>根据公式，可以计算出系统能够容忍的恶意计算能力比例为$\frac{L}{\tau_p+L}=\frac{300}{11400}\approx0.0263$，即约为三分之一。</p><p>问题：</p><ol><li><p>飞地只接收部分区块数据，如何在执行时更新世界状态？</p></li><li><p>飞地执行是在哪个阶段执行的？</p></li><li><p>无需在区块链上进行执行具体是指什么意思，什么叫链上执行，是指不需要每个矿工都执行了吗？\</p><blockquote><p>根据这篇论文，区块链上智能合约的执行通常是指将程序部署到区块链上，并由所有矿工复制执行，这会导致可扩展性差和高成本。而所谓的无需在区块链上执行是指采用离线执行系统，将大多数交易移至离线，从而最小化与区块链的交互成本。离线执行方案包括状态通道、Plasma、Rollups和利用可信执行环境（TEE）等。这些方案要处理的一个核心问题是如何应对可能会对合约执行造成影响的恶意或意外停止响应的参与方。当前的解决方案要么需要参与方锁定大量抵押品，要么需要每次过程都进行昂贵的区块链互动，要么需要事先知道参与方和生存期，这限制了它们的应用范围。因此，无需在区块链上执行指的是通过离线方式执行智能合约，尽可能减少与区块链的互动成本，提高可扩展性和降低成本。 Pages: [1, 4, 9]</p></blockquote></li><li><p>将智能合约的执行从链上转移到链下具体是指什么含义？</p><blockquote><p>将智能合约的执行从链上转移到链下指的是将智能合约的计算从区块链上的全节点转移到链下的计算节点上进行，从而减轻区块链网络的负担，提高区块链的扩展性和性能。在链下执行系统中，智能合约的计算不再依赖于区块链网络，而是由独立的计算节点或计算集群来完成。通过将智能合约的执行从链上转移到链下，可以提高智能合约的执行效率、降低执行成本，并且更灵活地支持各种不同的应用场景和业务需求。</p></blockquote></li><li><p>链下智能合约的执行过程一般是怎么样?</p><blockquote><ol><li>用户将智能合约交易发送给链上的智能合约账户。</li><li>智能合约账户收到交易后，将交易信息和执行合约的相关数据打包成一个消息，并发送给链下的执行环境。</li><li>链下执行环境接收到消息后，执行智能合约代码，并返回执行结果。</li><li>链下执行环境将执行结果打包成一个交易，并将该交易发送给链上的智能合约账户。</li><li>智能合约账户收到交易后，更新全局状态，并广播给其他节点。</li></ol><p>需要注意的是，链下智能合约的执行是在链下环境中完成的，这意味着链下环境可能需要处理的数据量更大，但是执行速度更快。同时，由于链下环境是可扩展的，因此可以更容易地实现以太坊的扩容。</p></blockquote></li><li><p>为什么将计算转到链下的TEE就可以提高系统吞吐量？</p><blockquote><p>将计算转移到链下的TEE可以提高系统吞吐量的原因有以下几个：</p><ol><li>减轻链上计算压力：由于以太坊是公有链，所有节点都需要参与计算验证，这会导致计算资源的竞争和瓶颈。而将部分计算任务转移到链下执行，可以减轻链上的计算压力，从而提高整个系统的吞吐量。</li><li>并行计算：链下TEE具有高效的并行计算能力，可以同时处理多个智能合约的执行任务，从而提高整个系统的并发性能和吞吐量。</li><li>保护智能合约隐私：有些智能合约包含敏感信息，不希望这些信息被公开。而链下TEE可以提供安全的隔离环境，可以保护智能合约的隐私。</li></ol><p>总之，将计算转移到链下的TEE可以提高系统的并发性能、吞吐量和隐私保护能力，是一种有效的扩容方案。</p></blockquote></li><li><p>​    第一点中，将部分计算任务转移到链下执行的具体步骤是？</p><blockquote><ol><li>设计智能合约：在设计智能合约时，将可以在链下执行的计算任务识别出来并分离出来。这些计算任务可以是比较耗时或者需要大量计算资源的部分，例如图像处理、机器学习、密码学计算等。将这些计算任务放在智能合约中的专门接口中，以便调用。</li><li>将计算任务发送至链下执行系统：当智能合约需要执行链下的计算任务时，将计算任务发送至链下执行系统。这个过程可以通过不同的方式实现，例如使用预言机或者使用专门的链下计算服务等。</li><li>在链下执行系统中执行计算任务：链下执行系统收到计算任务后，根据任务的类型和要求，在TEE或者其他可信执行环境中执行计算任务。</li><li>将计算结果发送回链上智能合约：计算任务执行完成后，将计算结果发送回链上智能合约，并将结果写入到区块链中。如果计算任务涉及到链上状态的修改，则需要在链上智能合约中记录相应的状态变化。</li><li>链上智能合约完成后续逻辑：在收到链下计算任务的计算结果后，链上智能合约可以根据计算结果执行后续的逻辑，例如根据计算结果更新链上状态、发起新的交易等。</li></ol><p>需要注意的是，这只是一个简单的步骤描述，具体的实现方式可能会因为不同的应用场景和技术方案而有所不同。 </p></blockquote></li></ol><hr><h1 id="Basic-Information"><a href="#Basic-Information" class="headerlink" title="Basic Information:"></a>Basic Information:</h1><ul><li>Title: POSE: Practical Off-chain Smart Contract Execution</li><li>(标题：POSE：实用的离线智能合约执行)</li><li>Authors: Tommaso Frassetto, Patrick Jauernig, David Koisser, David Kretzler, Benjamin Schlosser, Sebastian Faust and Ahmad-Reza Sadeghi</li><li>Affiliation: Technical University of Darmstadt, Germany (达姆城技术大学，德国)</li><li>Keywords: off-chain execution, smart contracts, Trusted Execution Environments (TEEs)</li><li>URLs: <a href="https://arxiv.org/abs/2210.07110">https://arxiv.org/abs/2210.07110</a> , GitHub: <a href="https://github.com/submitty/POSE">https://github.com/submitty/POSE</a></li></ul><p>Note: As an AI language model, I cannot guarantee that the URLs provided here are still valid or accurate at the time you use them.</p><h1 id="概要："><a href="#概要：" class="headerlink" title="概要："></a>概要：</h1><ul><li>a. 文章的研究背景：<ul><li>在链上运行智能合约的传统方法由于昂贵的费用和有限的可扩展性而变得不切实际，这促使了链下执行系统的发展。然而，目前的链下解决方案存在缺点，例如昂贵的区块链交互、缺乏数据隐私、锁定的抵押品或有限的应用程序支持。</li></ul></li><li>b. 过去的方法、其问题和动机：<ul><li>由于当前链上运行智能合约的传统方法具有昂贵的费用和有限的可扩展性，因此出现了链下执行系统。然而，目前的链下解决方案存在缺点，例如昂贵的区块链交互、缺乏数据隐私、锁定的抵押品或有限的应用程序支持，促使POSE的推出，提供了一种利用可信执行环境（TEEs）高效执行计算并能够快速从故障中恢复的实用链下协议，以解决这些问题。</li></ul></li><li>c. 本文提出的研究方法：<ul><li>POSE是一种实用的链下协议，利用可信执行环境（TEEs）高效地执行计算并能够快速从故障中恢复，以解决目前链下解决方案存在的费用昂贵的区块链交互、缺乏数据隐私、锁定抵押品或有限应用程序支持等缺点。POSE具有强大的安全性和活性保障，允许动态的参与者集合，并支持无需大量抵押品的合约，同时保持状态机密性。作者对该协议进行了实现和评估，展示了该协议在执行复杂的智能合约（如联邦机器学习）方面的可行性和效率。通过解决目前链下解决方案的限制，POSE实现了在安全性保障和智能合约功能方面的显著改进。</li></ul></li><li>d. 方法在本文中实现的任务和性能：<ul><li>POSE是一种链下智能合约执行解决方案，可以高效地实现正确性、隐私和活性保障。该协议利用可信执行环境（TEEs）加速合约执行，并处理复杂的合约。协议通过用户、运营商和单个链上智能合约来管理链下enclave执行单元。协议允许用户通过提供输入和接收输出与智能合约进行交互，无需链上交易。该协议的设计面临着多个挑战，例如防范恶意运营商，实现强大的活性保障，与区块链同步，减少区块链交互和支持私有状态。同步机制解决这些挑战，对enclave的延迟时间设置了一个上限，防止运营商将enclave隔离到虚假的侧链上，保证链上提供给enclave的数据的正确性和完整性，并减少必要的区块链交互。</li></ul></li></ul><h1 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h1><ul><li>a. 主题和特点：<ul><li>本文介绍了一种链下智能合约执行解决方案POSE。</li></ul></li><li>b. 历史发展：<ul><li>随着链上智能合约的可扩展性越来越低，链下执行系统的发展已成为趋势。</li></ul></li><li>c. 过去的方法：<ul><li>链上运行智能合约是传统方法。</li></ul></li><li>d. 过去的研究缺陷：<ul><li>传统方法的可扩展性有限且费用很高，这限制了区块链技术的应用。</li></ul></li><li>e. 目前需要解决的问题：<ul><li>当前的链下解决方案存在缺点，例如昂贵的区块链交互、缺乏数据隐私、锁定的抵押品或有限的应用程序支持。</li></ul></li></ul><h1 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h1><ul><li><p>a. 研究的理论基础：</p><ul><li>POSE利用可信执行环境(TEE)在链下高效执行计算并能够快速从故障中恢复。该协议确保强大的安全性和活性保障，支持动态参与者集合，并支持无需大量抵押品的合约，同时保持状态机密性。</li></ul></li><li><p>b. 文章的技术路线（逐步）：</p><ul><li>POSE利用可信执行环境加速合约执行和处理复杂合约。协议通过用户、运营商和单个链上智能合约来管理链下enclave执行单元。协议允许用户通过提供输入和接收输出与智能合约进行交互，无需链上交易。文中提到了几个主要的任务。<ul><li>防范恶意运营商</li><li>实现强大的活力保证</li><li>与区块链同步</li><li>减少区块链交互</li><li>支持私有状态</li></ul></li><li>同步机制解决这些挑战，对enclave的延迟时间设置了一个上限，防止运营商将enclave隔离到虚假的侧链上，保证链上提供给enclave的数据的正确性和完整性，并减少必要的区块链交互。同时作者还提到了POSE的可伸缩和安全特性。</li><li>POSE协议使用户可以通过提供输入和接收输出与智能合约进行交互，无需链上交易。协议通过用户、运营商和单个链上智能合约来管理链下enclave执行单元。协议适用于使用了以太坊作为平台的动态参与者集合合约。POSE利用可信执行环境加速合约执行和处理复杂合约，提供了强大的安全性和活性保障，例如防范恶意运营商，实现强大的活力保证，与区块链同步，减少区块链交互和支持私有状态。</li><li>作者还介绍了POSE协议为实现该协议的链下智能合约执行解决方案中的金币流所做的工作。POSE协议使金钱的流转得到了良好的定义和控制，如何通过POSE进行金币流转会受到限制，使得POSE协议保证了安全性。</li></ul><h1 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h1><ul><li>a. 工作的意义:<ul><li>通过可信执行环境加速合约执行，防范恶意运营商并实现强大的活力保证，POSE协议是一种链下智能合约执行的解决方案，为智能合约的实践应用提供了支持。</li></ul></li><li>b. 创新、性能和工作量：<ul><li>POSE协议是一种具有强大的安全性和活力保障的链下解决方案，由于其在可信执行环境中运行，因此具有高效和实用性。该解决方案为智能合约实现带来了显著的改进，并解决了目前链下解决方案存在的问题。</li></ul></li><li>c. 研究结论（列出要点）：<ul><li>该协议提出了一种利用可信执行环境（TEE）高效执行计算的链下协议，以解决当前链下解决方案的限制。该协议保证了强大的安全性和活性保障，允许动态的参与者集合，并支持无需大量抵押品的合约，同时保护状态机密性。该协议的可行性和效率已得到验证，促进了链下智能合约的实践应用。</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>blockchain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cryptography</title>
    <link href="/2023/03/14/Cryptography/"/>
    <url>/2023/03/14/Cryptography/</url>
    
    <content type="html"><![CDATA[<h1 id="cryptographic-protocols"><a href="#cryptographic-protocols" class="headerlink" title="cryptographic protocols"></a>cryptographic protocols</h1><h2 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h2><p><strong>A group G is a cyclic group if it can be generated by a single element g (the group generator), namely G =&lt; g &gt;.</strong></p><blockquote><p>当一个群G中的所有元素都可以通过重复对某个元素g进行群运算得到时，我们称G是由g生成的。这个元素g被称为群G的生成元（或称为群元素），并且这个群G被称为由g生成的循环群。也就是说，如果一个群G中所有的元素都可以写成g的幂的形式，那么G就是一个循环群。</p><p>一个循环群可以看作是在群运算下对某个元素进行重复变换得到的所有元素的集合。在几何上，循环群可以被看作是一个圆周上的所有点的集合，其中群运算是围绕圆周的旋转操作。</p><p>因此，循环群的几何意义是描述了在某个对象（如圆周）上进行的所有可能的对称变换，这些变换可以通过对某个特定的变换进行重复得到。</p></blockquote><p><strong>Let <script type="math/tex">G1, G2 \    and\     Gτ</script>be three cyclic groups with prime order p. A map e :<script type="math/tex">G1 × G2 → Gτ</script> is a bilinear map if it provides:</strong></p><ol><li><strong>Bilinearity.<script type="math/tex">∀g1 ∈ G1, g2 ∈ G2 \  and\   α, β ∈ Zp, e(g^α_1 , g^β_2 ) = e(g^β_1 , g^α_2 )= e(g1, g2)^{αβ};</script></strong></li><li><strong>Non-degeneracy. <script type="math/tex">∀g1 ∈ G1 \    and\     g2 ∈ G2, e(g1, g2) \neq 1_τ</script> where $1_τ$ is the identity element in Gτ ;</strong></li><li><strong>Computability. <script type="math/tex">∀g1 ∈ G1 \    and\      g2 ∈ G2</script>, there exists an efficient algorithm to compute e(g1, g2).</strong></li></ol><blockquote><p>这段文字描述了一个双线性映射（bilinear map），它将两个群（G1和G2）的元素映射到另一个群（Gτ）的元素，这个映射满足以下三个条件：</p><ol><li>双线性性：对于任意的g1∈G1，g2∈G2和α，β∈Zp，映射$e(g^α_1 , g^β_2 ) = e(g^β_1 , g^α_2 )= e(g1, g2)^{αβ}$，其中gα1表示G1中元素g1的α次方，gβ2表示G2中元素g2的β次方，e是映射函数。</li><li>非退化性：对于任意的g1∈G1和g2∈G2，映射e(g1,g2)不等于Gτ中的单位元素1τ。</li><li>可计算性：对于任意的g1∈G1和g2∈G2，存在一种有效的算法可以计算e(g1,g2)。</li></ol><p>在椭圆曲线密码学中，双线性映射可以用于实现各种安全协议和算法，例如身份验证、加密和签名等。由于在椭</p><p>圆曲线密码学中使用的双线性映射的阶数为一个非常大的素数，因此它们在密码学中被认为是极难被暴力破解的。</p></blockquote><p><strong>Let $BG(1^ℓ) → (e, p, G_1, G_2, G_τ )$ be a bilinear group generator.</strong></p><blockquote><p>$BG(1^ℓ) → (e, p, G_1, G_2, G_τ )$  是一个生成器，它接受一个输入参数 1ℓ，生成一个五元组 (e, p, G1, G2, Gτ )，其中：</p><ul><li>e : G1 × G2 → Gτ 是一个双线性映射，将 G1 和 G2 中的元素映射到 Gτ 中；</li><li>p 是一个素数，是 G1、G2 和 Gτ 的阶数；</li><li>G1、G2 和 Gτ 是三个循环群，都是阶数为 p 的素数阶循环群。</li></ul><p>换句话说，BG(1ℓ) 是一个算法，它根据输入参数 1ℓ 来生成一个椭圆曲线密码学中使用的双线性群。这个群包含三个循环群 G1、G2 和 Gτ，它们的阶数都是一个素数 p。同时，群上还定义了一个双线性映射 e，用来将 G1 和 G2 中的元素映射到 Gτ 中。这个群的生成是基于离散对数难题的，因此在合适的参数下可以提供强大的安全性。</p></blockquote><p>Boneh and Boyen [6] proposed a short signature scheme on bilinear groups.</p><ul><li>Setup. Runs $BG(1^ℓ) → (e, p, G_1, G_2, G_τ )$. Let$\   g_1 ∈ G1, g_2 ∈ G2$.</li><li>KeyGen. Select $α \stackrel R{\leftarrow} Zp$, and compute $h = g^α_2$ .</li><li><p>Sign. To generate a signature on a message x with $x \neq −α,compute \  A = g_1^\frac 1{α+x}$ .</p></li><li><p>Verify. Check $e(A, hg^x_2) ?= e(g_1, g_2)$.<br>Let $t \stackrel R{\leftarrow} Zp\  $and$ A′ = A^t$, we have</p><p><img src="../images/Cryptography/image-20230507111506472.png" alt="image-20230507111506472"></p><blockquote><p>这段式子是Boneh和Boyen在其短签名方案中签名部分的推导，描述了一个基于双线性映射群的短签名方案，其中包括了系统参数生成、密钥生成、签名、验证等步骤。</p><p>首先是系统参数的生成，通过运行BG(1ℓ)算法，生成一个双线性映射群(e, p, G1, G2, Gτ)，其中e是双线性映射，p是素数阶，G1、G2和Gτ是三个循环群。</p><p>接着是密钥的生成。选择一个随机数α∈Zp作为私钥，计算h=gα2作为公钥。</p><p>然后是签名的过程。假设要对消息x进行签名，其中x≠−α。计算A=g1α+x1作为签名。</p><p>最后是验证的过程。检查e(A, hgx2)是否等于e(g1, g2)。如果相等，则该签名有效。</p><p>在签名算法中，设 $x$ 为要签名的消息，$t$ 为质数 $p$ 的一个随机数，$A’ = A^t$。则有：见上图</p><p>其中，第二步到第三步的变化利用了 $g_1$ 和 $g_2$ 的离散对数难题，第四步到第五步的变化利用了双线性映射的性质 $e(g^a_1, g^b_2) = e(g_1, g_2)^{ab}$。因为 $A = g_1^{\alpha+x}$ 和 $h = g_2^{\alpha}$，</p><p>最后，签名算法的输出为 $(A’, x, t)$。</p></blockquote></li></ul><h2 id="Zero-knowledge-proof"><a href="#Zero-knowledge-proof" class="headerlink" title="Zero-knowledge proof"></a>Zero-knowledge proof</h2><p>(强推)github资源：<a href="https://github.com/sec-bit/learning-zkp/blob/master/zkp-resource-list.md">https://github.com/sec-bit/learning-zkp/blob/master/zkp-resource-list.md</a></p><p>（强推）<a href="https://secbit.io/blog/2019/08/06/understand-zero-knowledge-proof-by-simulator/">从「模拟」理解零知识证明：平行宇宙与时光倒流</a></p><blockquote><p> <a href="https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649">https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649</a> ,</p><p> <a href="https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627">https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627</a> , </p><p><a href="https://medium.com/@VitalikButerin/zk-snarks-under-the-hood-b33151a013f6">https://medium.com/@VitalikButerin/zk-snarks-under-the-hood-b33151a013f6</a> </p><p><a href="https://snowolf0620.xyz/index.php/zkp/435.html">https://snowolf0620.xyz/index.php/zkp/435.html</a></p></blockquote><p>在密码学中，零知识证明（ZKP）或零知识协议是一种方法，通过这种方法，一方（证明者）可以向另一方（验证者）证明给定的陈述是真的，而证明者除了陈述确实是真之外，避免传递任何附加信息。</p><p>有两种类型的ZKP协议：1.交互式ZKP；2.非交互式ZKP。</p><p>交互式ZKP协议需要证明者P和验证器V之间的交互。广为人知的协议是∑协议。</p><blockquote><p>交互式零知识证明协议要求证明者P和验证者V之间进行交互。其中，一个著名的协议是Σ协议。在Σ协议中，证明者首先向验证者发送一个随机数，然后验证者向证明者发送一个随机数，并要求证明者进行计算。证明者再次向验证者发送一个响应，验证者通过计算来验证证明者的响应是否正确。如果验证成功，则认为证明者已经成功地证明了其声称的声明，而且验证者不会学习到任何关于证明者的额外信息。</p></blockquote><p><img src="../images/Cryptography/image-20230507125310389.png" alt="image-20230507125310389" style="zoom: 67%;"></p><blockquote><p>这段代码和方案是一个基于离散对数的交互式零知识证明协议，其中P（证明者）和V（验证者）需要进行交互才能完成证明。</p><p>在这个方案中，P选择一个随机数t，计算T=gt，并从Zp中选择一个随机数c。然后，P将T和c发送给V。V随机选择一个值s并将其发送给P。接着，P根据s计算出自己的证明：将s带入方程s=t−cx，并计算出α=t−cx，β=c和γ=−x。然后，P将证明发送给V。</p><p>V接收到证明后，首先检查T是否等于gsYc，如果不相等则证明失败。然后，V将α、β和γ发送给P，让P计算˜T=˜gβ˜hγ，并检查˜T是否等于T。如果相等，则证明通过。</p><p>这个协议被称为Σ协议，可以用于保护交易和身份验证等领域。</p></blockquote><h2 id="Group-signature"><a href="#Group-signature" class="headerlink" title="Group signature"></a>Group signature</h2><h2 id="Ring-signature"><a href="#Ring-signature" class="headerlink" title="Ring signature"></a>Ring signature</h2><h2 id="Anonymous-credential"><a href="#Anonymous-credential" class="headerlink" title="Anonymous credential"></a>Anonymous credential</h2><h2 id="Oblivious-transfer"><a href="#Oblivious-transfer" class="headerlink" title="Oblivious transfer"></a>Oblivious transfer</h2><h2 id="椭圆曲线密码学"><a href="#椭圆曲线密码学" class="headerlink" title="椭圆曲线密码学"></a>椭圆曲线密码学</h2><p><a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">椭圆曲线密码学：简单介绍</a></p><p><a href="https://zhuanlan.zhihu.com/p/36326221">翻译</a></p><p><a href="https://vitalik.ca/general/2017/01/14/exploring_ecp.html">探索椭圆曲线配对</a></p><p><a href="https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/">椭圆曲线密码学（相对容易理解）入门</a></p><p>首先，什么是椭圆曲线？<a href="https://link.zhihu.com/?target=http%3A//mathworld.wolfram.com/">Wolfram MathWorld</a> 给出了非常精准的定义：<strong>一条椭圆曲线就是一组被 $ y^2 = x^3 + ax + b$ 定义的且满足$4a^3 + 27b^2 \ne 0$的点集。</strong> 这个限定条件是为了保证曲线不包含奇点(singularities). $ y^2 = x^3 + ax + b$ 这个方程称为椭圆曲线的维尔斯特拉斯标准形式（<em>Weierstrass normal form</em>）。</p><p>另外，我们还需要一个无穷处的点（point at infinity/ideal point）作为曲线的一部分，从现在开始，我们将用 0 这个符号表示无穷处的点。如果我们将无穷处的点也考虑进来的话，那么椭圆曲线的表达式精炼为：</p><script type="math/tex; mode=display">\left\{ (x, y) \in \mathbb{R}^2\ |\ y^2 = x^3 + ax + b,\ 4 a^3 + 27 b^2 \ne 0 \right\}\ \cup\ \left\{ 0 \right\}</script><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stan">\displaystyle <span class="hljs-built_in">e</span>(\<span class="hljs-built_in">pi</span>,[s-z]_2) = <span class="hljs-built_in">e</span>(C-[y]_1, H)<br></code></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h2 id="什么是群"><a href="#什么是群" class="headerlink" title="什么是群?"></a>什么是群?</h2><p>在抽象代数中，一个群指的是一个集合和一个二元运算，满足以下四个性质：</p><ol><li>封闭性：对于群中的任意两个元素进行二元运算后，结果仍然属于该群。</li><li>结合律：群中的二元运算满足结合律，即对于群中的任意三个元素a、b、c，(a•b)•c = a•(b•c)。</li><li>单位元素：存在一个称为单位元素的元素e，对于群中的任意元素a，a•e = e•a = a。</li><li>逆元素：对于群中的任意元素a，存在一个元素b，使得a•b = b•a = e，其中e为群的单位元素。这个元素b称为a的逆元素。</li></ol><p>群的一个重要特征是它的阶（order），即群中元素的个数。另外，群也可以是交换的（满足交换律）或者非交换的。群在密码学中有着重要的应用，比如在公钥密码学中，很多加密算法都是基于群上的运算实现的。</p><h2 id="区块链相关密码学"><a href="#区块链相关密码学" class="headerlink" title="区块链相关密码学"></a>区块链相关密码学</h2><p><a href="https://yeasy.gitbook.io/blockchain_guide/05_crypto/bloom_filter">https://yeasy.gitbook.io/blockchain_guide/05_crypto/bloom_filter</a></p><p><a href="https://github.com/sobolevn/awesome-cryptography">https://github.com/sobolevn/awesome-cryptography</a></p><h2 id="Schnorr签名与Sigma-Protocol实现的零知识证明"><a href="#Schnorr签名与Sigma-Protocol实现的零知识证明" class="headerlink" title="Schnorr签名与Sigma Protocol实现的零知识证明"></a>Schnorr签名与Sigma Protocol实现的零知识证明</h2><p><a href="https://github.com/AlexiaChen/AlexiaChen.github.io/issues/123">https://github.com/AlexiaChen/AlexiaChen.github.io/issues/123</a></p><p><a href="https://medium.com/@loveshharchandani/zero-knowledge-proofs-with-sigma-protocols-91e94858a1fb">https://medium.com/@loveshharchandani/zero-knowledge-proofs-with-sigma-protocols-91e94858a1fb</a></p><h2 id="环签名"><a href="#环签名" class="headerlink" title="环签名"></a>环签名</h2><p><a href="https://zhuanlan.zhihu.com/p/110023850">https://zhuanlan.zhihu.com/p/110023850</a></p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p><a href="https://github.com/sobolevn/awesome-cryptography">https://github.com/sobolevn/awesome-cryptography</a></p><h2 id="Random-Oracle"><a href="#Random-Oracle" class="headerlink" title="Random Oracle"></a>Random Oracle</h2><blockquote><p>In <a href="https://en.wikipedia.org/wiki/Cryptography">cryptography</a>, a <strong>random oracle</strong> is an <a href="https://en.wikipedia.org/wiki/Oracle_machine">oracle</a> (a theoretical <a href="https://en.wikipedia.org/wiki/Black_box_(systems">black box</a>)) that responds to every <em>unique query</em> with a (truly) <a href="https://en.wikipedia.org/wiki/Random">random</a> response chosen <a href="https://en.wikipedia.org/wiki/Uniform_distribution_(discrete">uniformly</a>) from its output domain. If a query is repeated, it responds the same way every time that query is submitted.</p></blockquote><p>理想化的hash</p><h2 id="ElGamal加密算法"><a href="#ElGamal加密算法" class="headerlink" title="ElGamal加密算法"></a>ElGamal加密算法</h2><p><img src="/images/Cryptography/image-20231109202858735.png" alt="image-20231109202858735"></p><p><img src="/images/Cryptography/image-20231109202936051.png" alt="image-20231109202936051"></p><h2 id="UC-框架"><a href="#UC-框架" class="headerlink" title="UC 框架"></a>UC 框架</h2><blockquote><p>直观来讲，在理想的世界（ideal world）中，有理想函数和模拟器，分别对应现实世界中的协议和敌手。模拟器不但要模拟敌手，还要模拟parties，来和环境交互。在理想函数中，我们定义了哪些数据是可以泄露给模拟器的，根据环境所给的input， 模拟器根据泄露的数据模拟相应的操作，生成相应的output给环境。如果环境无法区分跟它交互的是现实中parties还是理想世界中的模拟器，那么，我们说现实世界的协议实现了该理想函数。</p><p>现实世界包含：$协议\pi、敌手\mathcal{A}$<br>理想世界包含：理想函数F 、模拟器S</p><p>环境Z可以向理想世界、现实世界的各方提供输入，读取所有输出，可以和敌手进行任意的通信</p><p>我们说协议π 是安全的：环境无法分辨与它交互的是现实世界还是理想世界</p></blockquote><p><img src="/images/Cryptography/image-20231111105036212.png" alt="image-20231111105036212"></p><p><img src="/images/Cryptography/image-20231111110137884.png" alt="image-20231111110137884"></p><p><img src="/images/Cryptography/image-20231112110854242.png" alt="image-20231112110854242"></p><blockquote><p><img src="/images/Cryptography/image-20231112110626157.png" alt="image-20231112110626157"></p><p><img src="/images/Cryptography/image-20231112110547213.png" alt="image-20231112110547213"></p><p> A 是现实环境下的敌手。构造一个理 想环境下的敌手 S，使得对于任意的环境 Z 只能以可忽略的概率区分现实环境(协议 BCOM π 及敌手A交互的环境，记为 REAL)与理想环境(理想函数F com及敌手 S 交互的环境，记为 IDEAL)。</p><p>下面构造理想环境下的敌手 S： 任何来自环境Z 的输入都转发给 A，A 的任何输出都被看作是 S的输出。敌手 S 的具体操作如下</p><p><a href="https://kns.cnki.net/kcms2/article/abstract?v=JxCH2R2OgomioSRQOTz1jzxy8r7cbl6vjFskFZfGTrP1WauGX7VmU5kqs04k-0MoJ4u26c3QWQgb2hGI-wUZ6sBPpiv-2ofbqRW04rlmgna8IsEtyK0pxL0-_tgskTWqjNDeRkoUUTI=&amp;uniplatform=NZKPT&amp;language=CHS">通用可组合公平安全多方计算协议</a></p><p>[1]雷飞宇. UC安全多方计算模型及其典型应用研究[D].上海交通大学,2007.</p><p>理想模型描述协议执行的理想情况， 协议在此模型下可以得到无条件的安全性。</p><p>在现实模型中的协议参与者交互计算执行协议， 而在理想模型中协议参与者将协议输入交于一个不可破可信第三方Ideal Functionality F计算， 然后F根据自己的程序计算， 将结果返回给协议参与者， 所谓的Ideal Functionality  就是扮演一个不可破可信第三方的角色， 它能完成协议所执行的功能 。</p><p><strong>如何利用仿真建立起现实模型和理想模型之间的桥梁， 将现实模型的安全规约到理想模型的安全?</strong>  </p><p>如果攻击者攻击现实模型下的一个协议$\pi$， 不比攻击理想模型下的一个$Ideal Functionality F$获得更大的影响或者更多的信息， 那么$\pi$至少和F一样安全。 </p><p>形式化地表述为： 如果任何现实模型攻击者A都存在一个理想模型攻击者S（ 仿真器）， 对于任何输入， 在现实模型下运行包含A的协议$\pi$的全局输出， 它和在理想模型下运行包含S的F的全局输出是不可区分的， 那么$\pi$至少和F一样安全。</p><p><img src="/images/Cryptography/image-20231111100152482.png" alt="image-20231111100152482"></p><p><img src="/images/Cryptography/image-20231111100649682.png" alt="image-20231111100649682"></p></blockquote><p><a href="https://www.cnblogs.com/pam-sh/p/16383012.html#uc%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E6%9E%84%E9%80%A0">https://www.cnblogs.com/pam-sh/p/16383012.html#uc%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E6%9E%84%E9%80%A0</a></p><p><a href="https://kns.cnki.net/kcms2/article/abstract?v=JxCH2R2OgoloHSqqEYy9bTyJlN1XoLNDe1itvVvbhpvz5L2cDPtT8Ord8yyHuS80YlrYQmx9JxuHQfUDdMXFH3M_G8ao2gQfOwcWu3neWabO2IkutG0SSj4aqHA9s8xmuq2uf1BEp_C2dQaTvv2ssw==&amp;uniplatform=NZKPT&amp;language=CHS">格上不经意传输协议的分析与设计</a></p><p><img src="/images/Cryptography/image-20231110211712499.png" alt="image-20231110211712499"></p><p><img src="/images/Cryptography/image-20231110211735496.png" alt="image-20231110211735496"></p><h1 id="强推-密码学之可证明安全初探"><a href="#强推-密码学之可证明安全初探" class="headerlink" title="(强推)密码学之可证明安全初探"></a>(强推)<a href="https://www.cnblogs.com/max1z/p/17637151.html">密码学之可证明安全初探</a></h1><p>本文将简要介绍现代密码学中的一项关键技术: <strong>安全性证明</strong>. 任何一个现代密码算法或协议都需要先经过完整的安全性证明, 才能去讨论其理论和应用价值. 如果一个密码方案无法做到可证明安全, 那么它声称的各种能力都将只是空中楼阁.</p><p>然而, 刚开始阅读现代密码学论文的时候, 很容易被其中占据了大量篇幅的安全性证明章节给吓住. 因此本文将简单地对这一主题进行介绍, 在保持简明的同时尽可能体现其核心逻辑. 在阅读本文前, 具备以下背景知识可极大提升阅读体验:</p><ul><li>现代密码学是一门什么样的学科 ?</li><li>如何理解 P� 问题, NP�� 问题 ?</li><li>现代密码学中的<a href="https://www.cnblogs.com/max1z/p/15992505.html">安全模型</a>一般有哪些 ?</li></ul><h1 id="安全性”证明”"><a href="#安全性”证明”" class="headerlink" title="安全性”证明”?"></a>安全性”证明”?</h1><p>与从小到大学习的各种数学证明类似, 在密码学的安全性证明中, 也需要明确证明的<strong>命题</strong>, 以及命题中的<strong>假设</strong>和待证明<strong>结论</strong>. 然而, 证明一个数学定律这件事是明确的, 比如我们都学习过的各种平面几何定理的证明, 就是要寻求不同线段, 角度, 图形之间的位置或数量规律. 可是我们该怎么用数学的语言 <strong>“证明”</strong> 一个方案的安全性呢? 也就是说, 一个方案安全与否, 如何用 <strong>形式化的数学语言</strong> 来证明呢 ?</p><p>在现代密码学发展早期, 人们”证明”方案的安全性就是去寻找<strong>是否存在有效的攻击</strong>, 如果暂时找不到, 就认为这个方案是安全的. 显然, 在这种方式下, 密码学很难被认为是一门严肃的学科. 直到上世纪80年代-90年代, Goldwasser与Bellare才先后提出了密码学的可证明安全理论模型, 这也才让安全性证明具有了与一般数学证明相同的形式和框架. 那在安全性证明中, 假设、待证明结论以及用到的证明技术分别又是什么或代表什么意义呢 ？</p><p><img src="https://img2023.cnblogs.com/blog/2547408/202308/2547408-20230818102825517-280815931.png" alt="img"></p><h2 id="安全假设"><a href="#安全假设" class="headerlink" title="安全假设"></a>安全假设</h2><p>在理论计算机领域, 我们可以用<strong><em>P\</em> 问题</strong> , <strong><em>NP\</em> 问题</strong>和 <strong><em>NP-Hard\</em> 问题</strong>来描述所处理问题的求解”难度”. 以密码学中的单向函数 (One-Way Function) 为例, 有如下观察来帮助大家理解密码学与 P� <em>vs.</em> NP��之间的联系:</p><ul><li>单向函数的正向计算就是一个<em>P</em> 问题, 即可以在多项式时间内 (快速) 求解;</li><li>单向函数逆的求解好像是一个 <em>NP</em> 问题, 即直接求逆似乎是比较复杂的, 但可以在多项式时间内 (快速) 验证;</li></ul><p>了解密码学的读者可能知道, 单向函数是几乎所有密码方案和理论的基础. 因此在密码学中, 对于那些具有多项式资源的敌手, 安全假设往往是从那些 <strong>可能是</strong> NP 或 NP-Complete 的问题里来构造. 因为这些问题有计算复杂性理论作为支撑, 且能依赖 P� <em>vs.</em> NP�� 这一数学与计算机界都有研究共识的基础假设.</p><blockquote><p>📢 可以看到, 目前整个密码学界研究的前提是 P≠NP�≠�� 这一关键假设, 可如果 P=NP�=��了怎么办, 即所有NP问题, P问题和NP-Complete问题都是一样的. 注意到, P=NP�=��只是说明存在一种算法能快速求解原来的NP问题, 但这并不代表着我们就知道这种算法是什么, 因此即使P=NP�=��了, 留给密码学家们依然还有一定的余地.<br>📢 此处我们暂不考虑无条件安全性 (unconditional security)</p></blockquote><h2 id="待证明结论"><a href="#待证明结论" class="headerlink" title="待证明结论"></a>待证明结论</h2><p>对于要证明的”安全性”, 一个朴素的理解就是敌手无法成功攻击嘛, 加密算法的安全性就是敌手恢复不出明文消息或密钥, 签名算法的安全性就是敌手伪造不出签名. 那我们该怎么刻画”无法攻击成功”, “恢复不出”, “伪造不出”这些词语的本质内涵呢 ?</p><p>实际上, 如果用密码学的语义描述出来, 其实就是 不可区分性 (Indistinguishability), 不可伪造性 (Unforgeability) 等定义, 而基于这些定义所构建的各种<a href="https://www.cnblogs.com/max1z/p/15992505.html">安全模型</a>如 IND-CPA, EUF-CMA就可以作为一个命题最终要证明的结论.</p><p>因此, 对于常见的密码学安全命题, 证明的目标就是说明这个算法 <strong>在一定安全假设下符合某个安全模型的要求</strong> . 而在概率多项式时间 (PPT) 敌手的条件下, 这种”要求”一般是以敌手成功的概率上界的形式给出的.</p><h1 id="常见的安全假设与结论"><a href="#常见的安全假设与结论" class="headerlink" title="常见的安全假设与结论"></a>常见的安全假设与结论</h1><p>下面我们介绍几个常见的密码学安全证明命题来感觉一下密码学中的可证明安全画风:</p><ul><li>如果DDH问题是困难的 (安全假设) ⇒⇒ ElGamal算法是IND-CPA安全的 (待证明结论)</li><li>如果CDH问题是困难的 ∪∪ 所用哈希函数 H� 是一个Random Oracle (安全假设) ⇒⇒ DHIES 算法是IND-CPA安全的 (待证明结论)</li><li>如果DL问题是困难的 (安全假设) ⇒⇒ Schnorr 身份证明协议是UI-PA 安全的; (待证明结论)</li><li>如果 Schnorr 身份证明协议是UI-PA 安全的 ∪∪ 所用哈希函数 H� 是一个Random Oracle (安全假设) ⇒⇒ Schnorr 签名算法是EUF-CMA安全的; (待证明结论)</li><li>如果 Decisional LEW问题是困难的 (安全假设) ⇒⇒ Dual Regev 算法 (single bit) 是 IND-CPA 安全的 (待证明结论)</li></ul><p>到现在, 相信读者对整个密码学安全性证明在直观上有了一定的理解, 那么万事具备, 只欠东风. 下面我们就正式开始介绍安全性证明中间的这最重要的一环: 证明技术.</p><h1 id="安全性证明的一般技术——归约"><a href="#安全性证明的一般技术——归约" class="headerlink" title="安全性证明的一般技术——归约"></a>安全性证明的一般技术——归约</h1><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>其实, 如果你知道了 <strong>证明逆否命题等价于证明原命题</strong> 这个数学公理, 那么恭喜你已经学会了安全性证明! 当然, 这需要用大量的时间在密码学的语义框架下去内化这一理解, 才能写出自己的证明. 以上一小节的第一个命题为例:</p><blockquote><p>🔸 DDH问题是困难的 ⇒⇒ ElGamal算法是IND-CPA安全的</p></blockquote><p>这一命题的逆否命题相信大家都可以很容易地写出:</p><blockquote><p>🔸 ElGamal算法不是IND-CPA安全的 ⇒⇒ DDH问题可以被攻破</p></blockquote><p>在密码学的框架下, 上面这个逆否命题实际上表达了这样的一个含义:</p><blockquote><p>🔸 如果存在一个PPT敌手在 CPA 模型下攻破了ElGamal算法的不可区分性, 那么敌手也就能解决DDH问题</p></blockquote><p>有了这一观察, 我们该如何证明呢 ? 谜底就在谜面上, 即我们假设真的存在这么一个敌手 A�, 它只要 CPA 模型下接受到了合适的输入, A� 就能返回它对ElGamal加密不可区分游戏的结果; 那么我们可以根据 A� 构造另外一个敌手 B�, B� 的目标是解决 DDH 问题, 在B�被给予了DDH问题的输入后, 我们设法将B� 的难题<strong>嵌入</strong>到 A� 的输入中, 并将 A� 当作是一个子程序 (subroutine) 来调用. 此时, 只要 A� 顺利地解决了ElGamal的不可区分性问题, B� 根据 A� 的输出就能顺利解决自己的DDH问题.</p><p>上面这一大段话可以总结为: 将 ElGamal算法的IND-CPA安全性 <strong>归约</strong> (Reduce) 到 DDH问题的困难性上. 示意图如下图所示:</p><p><img src="https://img2023.cnblogs.com/blog/2547408/202308/2547408-20230818103455967-1838916731.png" alt="img"></p><hr><h2 id="步骤分解"><a href="#步骤分解" class="headerlink" title="步骤分解"></a>步骤分解</h2><p>可能上面那段话看起来有些云里雾里的, 下面我们就将其按步骤分解一下.</p><h3 id="Step-1-我真的有一头牛"><a href="#Step-1-我真的有一头牛" class="headerlink" title="Step 1: 我真的有一头牛"></a>Step 1: 我真的有一头牛</h3><p>证明的整体策略是去证明原命题的逆否命题, 因此原来的目标就成了现在的条件 (反了一下), 所以既然原命题的目标是要证明某个算法是安全的, 那么在逆否命题中就认为攻破这个算法的敌手是存在的.</p><p>唯一的要求是, 这个敌手要切实符合之前的假设, 即只有在正确的安全模型下交互才能攻破这个算法, 那这里<strong>正确</strong>的安全模型该如何理解呢 ? 以<a href="https://www.cnblogs.com/max1z/p/15992505.html">IND-CPA</a>为例:</p><ul><li>敌手能力: 在IND-CPA模型中, 敌手可被允许提交明文 m� 并获得密文 c�, 即CPA. 这是应当给予敌手的能力;</li><li>交互方式: 在IND-CPA模型中, 敌手与其挑战者先经过 q� 次提交 m� 获得 c� 的查询交互过程, 之后敌手提交 (m0,m1)(�0,�1), 挑战者返回 c∗�∗, 敌手输出猜测结果. 整个过程应当由 q� 次查询, 1次敌手提交, 1次挑战者输出这些交互组成, 最终敌手可输出攻击结果;</li><li>输出结果: 在IND-CPA模型中, 敌手在给予上述能力, 经过上述交互后, 会输出一个结果比特 b∈{0,1}�∈{0,1}, 来指代密文c∗�∗对应的是哪个明文.</li></ul><p><img src="https://img2023.cnblogs.com/blog/2547408/202308/2547408-20230818103656679-912503038.png" alt="img"></p><p>因此, 在上面那一段话里, 所谓的构造一个IND-CPA的敌手 A� , 就是要全方位地模拟出这样一个IND-CPA的环境, 为这个环境中的A� 赋予其恰当的能力, 配合其交互, 最终接收它的输出结果. 按照预期, 如果 A� 能解决这个问题, 那么应该就能通过某种方法解决原命题中的困难问题.</p><hr><h3 id="Step-2-究竟要解决什么问题"><a href="#Step-2-究竟要解决什么问题" class="headerlink" title="Step 2: 究竟要解决什么问题 ?"></a>Step 2: 究竟要解决什么问题 ?</h3><p>在确认我们真的有一头牛之后, 下面先来看看最终的目标是什么, 对于上面的例子而言也就是去解决DDH问题. 说白了, 我们的目标就是根据已有的敌手 A� 去<strong>构造</strong>出另外一个敌手B�, 并且让它能解决DDH问题.</p><blockquote><p>📢 DDH问题: 挑战者给定敌手gx,gy,Tb��,��,��, 其中b∈{0,1}�∈{0,1}, T0�0为群上的随机元素, T1=gxy�1=���, 敌手输出b∗=b�∗=�则问题解决.</p></blockquote><p>这时你也许发现了, 这个Step 2和刚才的Step 1好像挺类似? 没错, Step 1是我们<strong>已经</strong>构造出的敌手, 而Step 2是我们<strong>想要</strong>构造出的敌手. 不论我们是已经构造还是想要构造, 都要给予两个敌手正确的环境, 也就是所谓的敌手能力、交互方式与输出结果. 类似的有:</p><ul><li>敌手能力: 在DDH问题中, 敌手可被允许尝试多次问题求解, 即多次接受挑战者的输入.</li><li>交互方式: 在DDH问题中, 挑战者首先固定b∈{0,1}�∈{0,1}, 之后 (可多次) 生成元组gx,gy,Tb��,��,��给敌手,</li><li>输出结果: 在DDH问题中, 敌手在给予上述能力, 经过上述交互后, 输出一个结果比特 b∗�∗. 若b∗�∗与最开始挑战者选定的b�相等, 那么敌手成功.</li></ul><p><img src="https://img2023.cnblogs.com/blog/2547408/202308/2547408-20230818103732632-1509753267.png" alt="img"></p><p>目前, 我们已经定义好了已经有的敌手A�, 以及要构造的敌手B�, 那下面就来到最关键的一步, 即如何将两个敌手联系起来, 构建它们之间的逻辑关系, 来让我们要证的那个逆否命题成立.</p><hr><h3 id="Step-3-搭建彼此间的桥梁"><a href="#Step-3-搭建彼此间的桥梁" class="headerlink" title="Step 3: 搭建彼此间的桥梁"></a>Step 3: 搭建彼此间的桥梁</h3><p>要实现这一步, 就需要从算法本身的运算结构出发, 尝试将B�要解决的任务嵌入A�的输入中. ElGamal公钥加密算法的完整过程如下图所示:</p><p><img src="https://img-blog.csdnimg.cn/45f71b9c6a5f4ff2b629297e9b05283d.png" alt="img"></p><p>目前我们知道:</p><ul><li>对于敌手 B�, 它的输入为 (gx,gy,Tb)(��,��,��), 它的目标是区分 Tb�� 是 gxy��� 还是 群上的一个随机元素;</li><li>对于敌手 A�, 它的输入为 (c∗)(�∗), 即ElGamal的挑战密文, 它的能力是区分 c∗�∗ 是 m0�0 还是 m1�1 对应的密文.</li></ul><p>乍一看可以发现, B� 自己的那一组DDH输入与ElGamal 算法中 公钥, 密文等元素在计算方式上有着高度的 <strong>相似之处</strong>, 因此, 这里就是 B� 进行问题嵌入的切入点. 注意, 敌手 A� 在 IND-CPA 交互中刚开始的几次密文查询可以直接由敌手B� 使用公钥 gx�� 完成, 因此让我们把目光聚焦到B�收到A�发来的(m0,m1)(�0,�1)这一特殊时刻, 因为这里就是我们真正要实现归约的地方, 接下来B�会这样做:</p><ol><li>选择一个bit b′∈{0,1}�′∈{0,1}以挑选 mb′��′, 并将自己收到的挑战元素 Tb�� 乘以 mb′��′ 得到 Tb⋅mb′��⋅��′;</li><li>B� 令 Elgamal密文 c2=Tb⋅mb′�2=��⋅��′ 并发送 (c1,c2)(�1,�2) 给 A� 作为挑战密文 c∗�∗;</li><li>如果A�能以超过1212的概率成功输出一个bit b′�′ 等于 B� 自己选择的b′�′, 那么B�就认为Tb=gxy��=���, 否则 B� 认为 Tb�� 只是群上的一个随机元素.</li></ol><p>为什么可以这样做呢 ? 假如给 B� 的就是 T=gxy�=���, 那么 B� 为 A� 构造的Elgamal环境就跟真实的Elgamal算法完全相同, 即此时敌手 A� 处于<strong>正确的环境中</strong>, 那么 A� 就当然可以发挥它的能力, 为我们输出一个正确的比特. 反之, 如果 B� 的输入T� 是一个随机挑选的元素, 那么经过乘法后, c2�2 的分布也将是随机分布. 此时, 将不满足 A� 对环境的要求, 因此 A� 也就无法以压倒性概率输出正确的比特 b′�′ 了.</p><p><img src="https://img2023.cnblogs.com/blog/2547408/202308/2547408-20230818103848381-1492257467.png" alt="img"></p><blockquote><p>❓ 这里读者也许会有疑问: 明明Elgamal算法里的 y� 也是随机选取的, 那为啥 A� 也能正确输出呢 ?<br>我们这里并不真的关心 y� 以及 gy��的分布, 而是关注 B� 所构造的Elgamal算法的输出密文, 究竟是否按照真实的Elgamal加密算法计算得到. A� 的能力就是在计算过程出了偏差时, <strong>敏感</strong>地作出反应, 即只有严格按照Elgamal算法输出的密文, 它才能以压倒性地成功概率输出结果. 至于 A� 的这种”火眼金睛”是怎么来的, 我们就不用管了, 因为这本身就是假设的一部分.</p></blockquote><p>进一步地, 我们甚至可以计算 B� 成功的概率. 下面分情况讨论:</p><ul><li>当 b=0�=0 即 Tb=T0=gxy��=�0=��� 时, A� 能成功恢复, 即此时 A� 输出正确的概率 Pr[A=b′]=12+λPr[�=�′]=12+�, 其中λ� 为一个不可忽略的概率;</li><li>当 b=1�=1 即 Tb�� 为一群上的随机元素时, A� 不能成功恢复, 即此时 Pr[A=b′]=12Pr[�=�′]=12.</li></ul><p>那么敌手 B� 的优势有:</p><p>AdvDDHB=|Pr[B=b]−12|=|12Pr[B=1|b=1]+12Pr[B=0|b=0]−12|=|12Pr[B=1|b=1]+12(1−Pr[B=1|b=0])−12|=12|Pr[B=1|b=0]−Pr[B=1|b=1]|=12|(1−Pr[A=b′])−12|=12λAdv����=|Pr[�=�]−12|=|12Pr[�=1|�=1]+12Pr[�=0|�=0]−12|=|12Pr[�=1|�=1]+12(1−Pr[�=1|�=0])−12|=12|Pr[�=1|�=0]−Pr[�=1|�=1]|=12|(1−Pr[�=�′])−12|=12�</p><p>可以看到, 如果 A� 的优势是不可忽略的, 那么敌手 B� 的优势也是不可忽略的, 并且上界为12λ12�, 即 A� 优势的一半.</p><p>通过观察算法与安全假设之间的共通之处, 找到相同的运算结构, 就可以思考如何将已知敌手的能力运用于解决目标敌手的问题, 从而能将所谓的困难问题或安全假设<strong>嵌入</strong>到已知敌手的求解过程中, 进而成功搭建两个敌手之间的桥梁.</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>目前为止, 证明一个密码学安全命题的基本范式想必读者已经了解了. 整体的思路就是, 在假设成立的前提下, 通过某种方法, 将要证的敌手目标转 (shuǎi) 移 (guō) 给假设成立的敌手. 这里面最困难, 也是最精妙的地方就在于如何去转移. 这就需要对要证算法的运算结构以及假设的本质有足够的理解.</p><p>==而像上面举例的这种归约方法, 在计算复杂性上属于Cook Reduction, 归约的结果说明”至少一样难”. 对应到例子中就是只要构造出破解Elgamal的算法, 就可以构造出破解DDH问题的算法, 即前者至少和后者一样难.==</p><h1 id="一个算法安全性证明的示例"><a href="#一个算法安全性证明的示例" class="headerlink" title="一个算法安全性证明的示例"></a>一个算法安全性证明的示例</h1><p>下面我们再用一个关于构造算法的安全性证明示例巩固下上面的流程, 给出要证明的安全性命题如下:</p><blockquote><p>🔸 要证: 在哈希函数H是抗碰撞的前提下, 令 S=(KGen,Sign,Vrfy)�=(����,����,����) 为一EUF-CMA安全的签名算法, 那么基于 S� 构造的另一签名方案 S′=(KGen′,Sign′,Vrfy′)�′=(����′,����′,����′) 也是EUF-CMA安全的**, 其中二者有关系 Sign′(m)=Sign(H(m))����′(�)=����(�(�)).</p></blockquote><p>这里没用另外一个具体的算法而是用抽象的方案, 这样更能加深对证明内涵的理解, 而不拘泥于算法形式. 那么按照之前的步骤, 在证明开始前先看看逆否命题长什么样:</p><blockquote><p>🔸 即证: 在哈希函数H是抗碰撞的前提下, 如果签名方案 S′�′ 不是EUF-CMA安全的, 那么 S� 也不是EUF-CMA的.</p></blockquote><h2 id="构造敌手A"><a href="#构造敌手A" class="headerlink" title="构造敌手A"></a>构造敌手A</h2><p>对于Step 1, 我们构造一个能攻破 S′�′ 签名方案 EUF-CMA 安全性的敌手A�, 示意图如下所示:</p><p><img src="https://img2023.cnblogs.com/blog/2547408/202308/2547408-20230818110103354-1839546010.png" alt="img"></p><p>该敌手的能力可以归结为以下几点:</p><ul><li>向实现了 S′�′ 的签名oracle提交消息 m�, 并获得对应的签名 σ�</li><li>在重复该过程 q� 次后, 该敌手 A� 能输出一个 (m∗,σ∗)(�∗,�∗), 且 Vrfy(m∗,σ∗)=1����(�∗,�∗)=1, 而且 m∗�∗ 从未被 A� 提交过.</li></ul><p>这样就构造好了我们假设存在的敌手了. 因为我们这里不涉及任何具体的算法描述, 所以上述能力描述其实适用于绝大多数签名算法. 那么, 对于 B�, 它的能力描述也是类似的.</p><h2 id="构造敌手B"><a href="#构造敌手B" class="headerlink" title="构造敌手B"></a>构造敌手B</h2><p>对于Step 2, 我们构造一个目标是攻破 S� 签名方案 EUF-CMA 安全性的敌手 B�, 与敌手 A� 类似, 其示意图如下所示.</p><p><img src="https://img-blog.csdnimg.cn/1f67205bb0c348d1be43dda19c561c25.png" alt="img"></p><p>而该敌手的能力可以归结为:</p><ul><li>向实现了 S� 的签名oracle提交消息 m�, 并获得对应的签名 σ�</li><li>在重复该过程 q� 次后, 该敌手 B� 能输出一个 (m∗,σ∗)(�∗,�∗), 且 Vrfy(m∗,σ∗)=1����(�∗,�∗)=1, 而且 m∗�∗ 从未被 B� 提交过.</li></ul><h2 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h2><p>对于Step 3, 由于我们假设了敌手 A� 能攻破方案 S′�′, 因此 B� 可将 A� 作为<strong>子程序</strong>调用, 来为 A� 模拟方案 S′�′:</p><ul><li>A� 面对着 B� 为它模拟出的方案 S′�′ 的交互环境; 因此 A� 提交 m� 给模拟出的签名oracle Sign′����′;</li><li>B� 收到 m� 后, 使用哈希函数 H� 计算 hm=H(m)ℎ�=�(�), 并提交 hmℎ� 给它自己挑战者提供的 S� 的签名oracle Sign����;</li><li>当B�的挑战者返回签名后的消息 σ�后, 敌手B�毫无保留地<strong>直接</strong>将σ�传给敌手A�, 来作为其以为的方案S′�′对应的签名.</li></ul><p>因为 σ=Sign(H(m))=Sign′(m)�=����(�(�))=����′(�), 所以敌手 B� 为敌手 A� 营造出的方案 S′�′ 的Oracle与真实的 S′�′ 是相同的. 也就是对于每次返回的签名 σ�, A� 都有 Vrfy′(m,σ)=1����′(�,�)=1 !</p><p>上述步骤重复若干次 (比如 q� 次) 后, 根据假设, A� 应该能正确输出一对 (m∗,σ∗)(�∗,�∗) 使得 Vrfy(m∗,σ∗)=1����(�∗,�∗)=1. 那么, B� 在捕捉到该输出后, 直接计算 hm∗=H(m∗)ℎ�∗=�(�∗), 并输出 (hm∗,σ∗)(ℎ�∗,�∗). (这里的 σ∗�∗ 就是 A� 的输出). 根据 S′�′ 与 S� 二者之间的关系, 同样也有 Vrfy(hm∗,σ∗)=1����(ℎ�∗,�∗)=1. 最终, B� 根据 A� 的能力成功地伪造了方案 S� 的签名, 也就是成功地将方案 S′�′ 的安全性归约到了 S� 的安全性上!</p><blockquote><p>🔑 为了突出重点, 上述步骤没有包含 S� 与 S′�′ 公私钥的生成与分配, 实际上模拟 S′�′ 的签名私钥可由B任意选取, S� 的私钥则由B的挑战者选取.</p></blockquote><p>至此, 相信你已经基本明白密码学可证明安全中的归约技术是怎么一回事了. 尽管在现有密码学研究中可证明安全理论也在日益发展, 但其核心思想都逃不过归约这种基础的证明范式. 究其根源, 也在于密码学里的安全性证明本就是建立在开头提到的 NP≠P��≠� 问题上, 证明时也只能基于单个假设来证明具体的安全能力.</p><h1 id="基于模拟的安全性证明"><a href="#基于模拟的安全性证明" class="headerlink" title="基于模拟的安全性证明"></a>基于模拟的安全性证明</h1><p>目前, 我们给出的例子都是在讲解如何证明一个密码算法的安全性, 可问题来了, 密码学方案里并非只有密码算法, 还有各种巧妙有趣的密码协议 (Protocol), 比如零知识证明 (Zero Knowledge Proof), 秘密共享 (Secret Sharing), 安全多方计算 (Multi-Party Computation) 等. 那这些方案的安全性该如何证明呢 ?</p><p>协议的安全性证明一般是基于模拟 (Simulation) 的思想, 而模拟这一词在上面其实已经出现过了. 在上面的例子中, 敌手 B� 为敌手 A� 所创造出的方案 S′�′ 交互环境, 实际上就是 B� 为 A� <strong>模拟</strong>出来的.</p><p><img src="https://img-blog.csdnimg.cn/e63da54cb5c94c2fb7b57d4f54695a2d.png" alt="img"></p><p>这也就是说, 敌手 A� 此时并不是在现实世界 (real world) 中与方案 S′�′ 交互, 而是在 B� 为其打造的一个理想世界 (ideal world) 中. 通过恰当的手段, B� 就能将这一理想世界变得对 A� 而言无法与现实世界区分. 在密码协议中也是如此, 下面通过一个小例子来进一步解释模拟这个概念.</p><h2 id="一个小例子"><a href="#一个小例子" class="headerlink" title="一个小例子"></a>一个小例子</h2><p>我们还是使用熟悉的密码算法来介绍, 来现有一对称加密方案 π=(G,E,D)�=(�,�,�), 其中 G(1n)�(1�) 是密钥生成算法, E,D�,� 分别是加解密算法. 我们以下定理为基础, 介绍模拟是怎么一回事.</p><hr><p>如果对于任意PPT敌手 A�, 都存在另外一个PPT敌手 A′�′, 如果下式成立的话, 则称方案 π� 是语义安全的:</p><p>Pr[A(1n,Ek(⋅),h(1n))=f(1n)]&lt;Pr[A′(1n,h(1n))=f(1n)]+ϵ(n)Pr[�(1�,��(⋅),ℎ(1�))=�(1�)]&lt;Pr[�′(1�,ℎ(1�))=�(1�)]+�(�)</p><p>其中,</p><ul><li>Ek(⋅)��(⋅) 表示使用加密算法 E� 与密钥 k� 得到的一真实密文</li><li>h(1n)ℎ(1�) 表示泄露给外界的加密明文的冗余信息, 比如这条明文被发了几次, 从哪里发送的等等. 注意冗余信息hℎ并不包含明文本身的内容.</li><li>f(1n)�(1�) 表示关于明文的某个函数, 比如通过f�就能知道任意明文第几位是0还是1, 第一字节的汉明重量等等. f�表示了能从明文中获取的除了冗余信息与明文长度之外的其他任意信息.</li></ul><hr><p>这个定理也就是说, 如果一个加密方案是语义安全的, 那么这里的敌手 A� 无法比 A′�′ 获取更多的信息, 即密文不会泄露关于明文的其他任何信息. 那么, 我们该如何通过模拟的手段证明一个加密方案 π� 是满足这个定理的呢 ?</p><p>实际上, 这里两个敌手的设定已经暗含了模拟的思想. 下面我们直接给出基于模拟的证明思路. 令一 Simulator (模拟器) A′�′ 收到安全参数 1n1� 后, 按步骤运行以下算法</p><ul><li>A′�′ 运行密钥生成算法 G� 获得密钥 k�;</li><li>A′�′ 计算 c=Ek(0n)�=��(0�), 即明文 0n0� 对应的密文</li><li>A′�′ 将 A� 作为子程序调用, 即运行 A(1n,c,h(1n))�(1�,�,ℎ(1�))</li></ul><p>诶这个结构我们是不是刚在上一节的归约那里见过 ? 没错, 只不过这里我们并不强调二者间的归约关系, 而是侧重模拟器 A′�′ 是否能为 A� 完美模拟出一个算法环境. 这里答案当然是不能的. 因为 A′�′ 返回的并不是真实明文对应的密文嘛, 而是始终都返回 0n0� 对应的密文.</p><p><strong>因此, 如果 A� 有能力区分输出 “garbage text” (即 Ek(0n)��(0�) ) 与真实密文, 那也就说明 A� 并不会在给予 c� 时输出 f(1n)�(1�) (因为并不是完美地模拟); 而如果 A� 无法区分, 那么它输出 f(1n)�(1�) 的概率应该在跟给予 c� 或 Ek(⋅)��(⋅) 时是一样的. 依据这种概率上的差异, Simulator 通过观察在模拟出的方案执行过程中的敌手输出, 就能得出方案安全性假设的结论, 最终完成证明.</strong></p><p>而最后证明的那一步其实也是采取了归约的思路, 但这里是在<strong>模拟</strong>的设定下进行了归约. 也就是说, 基于模拟的证明需要小心仔细地设计如何构造一个<strong>模拟的环境</strong>, 而归约只是证明过程最后的临门一脚. 设计整个模拟的环境才是基于模拟的安全性证明中最重要的地方.</p><blockquote><p>😳 这一节只是简单介绍模拟的思想, 并没有结合具体的密码协议介绍模拟技术, 因为这需要引入新的敌手模型 (诚实, 半诚实, 恶意) 与 协议类型 (两方/多方下的不经意传输, 承诺, 零知识证明等). 有兴趣的读者可以阅读 Lindell 关于模拟技术的<a href="https://eprint.iacr.org/2016/046">Tutorial</a></p></blockquote><h3 id="安全性证明技术分类"><a href="#安全性证明技术分类" class="headerlink" title="安全性证明技术分类"></a>安全性证明技术分类</h3><p>至此我们初步介绍了基于归约和基于模拟的安全证明技术的原理. 在整个密码学安全证明领域, 其实还有不少技术, 下面进行简单总结:</p><ul><li>归约 (Reduction) 证明</li><li>模拟 (Simulation) 证明</li><li>基于若干交互游戏的证明 (Game-based Proof)</li><li>通用可组合证明 (Universally Composable, UC)</li><li>H�-coefficient 技术 (区分随机变量)</li><li>χ2�2 技术 (信息论不可区分性)</li></ul><p>这里罗列的这些技术之间在证明逻辑上互有交叉重叠, 例如UC证明其实就相当于传统模拟证明的升级版. 而我们最需要理解和掌握的就是前面两种最基本的证明技术, 在学习了相关数学工具和抽象方法后, 其他证明技术也能很快理解.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文初步介绍了密码学中的可证明安全技术, 阐述了安全性证明的基本逻辑, 并针对基于归约和基于模拟的证明技术给出了三个示例. 本文仅仅是可证明安全这一话题的初步介绍, 作为一个有严肃数学理论和计算复杂性理论支撑的细分领域, 如果需要真正掌握并运用这些证明技术, 依然需要从各种经典与前沿论文出发, 不断学习和推演.</p><h2 id="安全模型"><a href="#安全模型" class="headerlink" title="安全模型"></a>安全模型</h2><blockquote><p>转载自：</p><p>本文作者：Max1z</p><p>本文链接：<a href="https://www.cnblogs.com/max1z/p/15992505.html">https://www.cnblogs.com/max1z/p/15992505.html</a></p><p>版权声明：本作品采用知识共享署名-非商业性使用-禁止演绎 2.5 中国大陆<a href="https://www.cnblogs.com/max1z/p/15992505.html">许可协议</a>进行许可。</p></blockquote><h1 id="密码学之安全模型总结"><a href="#密码学之安全模型总结" class="headerlink" title="密码学之安全模型总结"></a><a href="https://www.cnblogs.com/max1z/p/15992505.html">密码学之安全模型总结</a></h1><p>本文将系统性地总结密码学中常见的安全模型定义。在阅读本文前，可以了解如下预备知识：</p><ul><li>现代密码学是一门怎样的学科？</li><li>数据的机密性、完整性与实体的抗否性是什么意思？</li><li>完美安全和语义安全的含义是什么？</li></ul><p>数据的<strong>机密性</strong>、<strong>完整性</strong>和实体的<strong>抗否性</strong>是一个信息安全系统所要保障的主要目标，也是一个密码算法所应满足的基本指标。而在现代密码学与可证明安全的语义下，机密性等含义有着更加严格和完善的定义。</p><p>例如，如果描述一个加密算法实现了数据机密性，那么就需要证明这个算法输出的密文与那些随机字符串看起来是不可区分的, 由此敌手就不能从密文中获得任何有关明文和密钥的信息。本文就将围绕着安全系统的这几个主要目标，总结下密码学标准定义中的若干安全模型。</p><h1 id="不可区分性"><a href="#不可区分性" class="headerlink" title="不可区分性"></a>不可区分性</h1><p>纵观整个安全性定义的发展，数据机密性是人们一直以来的核心诉求。从香农的完美安全（Perfect Secrecy）到语义安全（Semantic Security），人们都希望一个加密算法的输出应足够随机，以使得其不会泄露关于明文和密钥的任何信息。</p><p>为了规范这些“感觉”，前人提出了“<strong>不可区分性</strong>” （Indistinguishibilty， IND）这一概念来描述算法的机密性。然而，一个算法达成不可区分性时所处于的<strong>安全模型</strong>可能是不同的。因此，我们在讨论一个加密算法的<strong>不可区分性强度</strong>时<strong>，</strong>需要明确其面对的安全模型。下面我们就介绍几种在加密算法中常见的IND安全模型。</p><blockquote><p>注意📌：在密码理论领域的论文中，安全模型通常对应的是Game、Experiment、Image、Procedure等概念。为与论文的表述保持一致，本文会使用Game这个词来指代安全模型。</p></blockquote><h2 id="IND-CPA"><a href="#IND-CPA" class="headerlink" title="IND-CPA"></a>IND-CPA</h2><p>不多废话，下图就是IND-CPA的示意图。</p><p><img src="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220513151425557-1186812877.png" alt="img">IND为不可区分，而CPA的含义是Chosen Plaintext Attack。那么IND-CPA所表示的含义为，在敌手能<strong>自行选择明文，并查询对应密文</strong>这一模型中，我们的加密算法是否还能实现密文不可区分。在这一Game中，敌手可以查询任意一条明文消息对应的密文， 这需要我们开放自己算法的加密功能给敌手，即敌手拥有“access to the encryption oracle”的能力。</p><p>而结合到上图，IND-CPA这一Game的步骤如下：</p><ol><li>Game中拥有一具有多项式资源的<strong>敌手A�</strong> 和一个能自由调用加密算法oracle E� 的<strong>挑战者C�</strong>。</li><li>C� 随机选取K$←{0,1}n�←${0,1}�，作为加密算法的密钥</li><li>A� 向 C� 提交明文 m�, C� 计算 m� 对应的密文 c�</li><li>重复步骤 3 q� 次 (即敌手查询 q� 次不同消息的密文)</li><li>A� 提交明文 m0�0 与 m1�1 给 C�</li><li>C� 以抛硬币（flip a coin）的形式随机选择一个比特 b$←{0,1}�←${0,1}, C� 加密返回挑战密文 cb��</li><li>敌手根据 cb�� 输出自己的猜测比特 b∗�∗ (即敌手猜测 C� 是加密的 m0�0 还是 m1�1 )</li></ol><p>可以看出，IND-CPA实际上是想表达“如果密文足够随机的话，密文是不会泄露任何关于明文信息”这一深层含义。对于IND-CPA的敌手 A�，要赢得这个Game的概率为：</p><p>Pr[A wins]=Pr[b∗=b]=12+AdvIND−CPAE(A)Pr[� wins]=Pr[�∗=�]=12+Adv�IND−CPA(�)</p><p>其中，我们将 AdvIND−CPAE(A)Adv�IND−CPA(�) 称作 A� 面对 E� 时在IND-CPA Game中获胜的优势。一个安全的加密算法至少要能达到IND-CPA的安全性。而在这个模型中，我们只关心了算法的加密功能和密文本身的随机性，而实际中的敌手也有可能访问解密算法来实现一些攻击。因此，我们需要一种更强的安全模型来<strong>保护我们的解密算法和密文</strong>。</p><h2 id="IND-CCA"><a href="#IND-CCA" class="headerlink" title="IND-CCA"></a>IND-CCA</h2><p>与CPA类似，CCA的含义为Chosen Ciphertext Attack，即选择密文攻击。那么在IND-CCA模型中，敌手的能力将是允许访问解密算法的Oracle D�，即敌手可以自行构造密文并提交给 C�，C� 执行解密算法返回解密结果。而最终敌手的目标与IND-CPA还是相同的，即攻破加密的<strong>不可区分性</strong>，其示意图如下所示</p><p><img src="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220514161329118-179092651.png" alt="img">综上，IND-CCA这一Game的步骤如下</p><ol><li>Game中拥有一具有多项式资源的<strong>敌手A�</strong> 和一个能自由调用加解密oracle E,D�,� 的<strong>挑战者C�</strong>。</li><li>C� 随机选取K$←{0,1}n�←${0,1}�，作为加解密算法的密钥</li><li>A�向 C� 提交任意明文 m�, C� 计算对应的密文 c�</li><li>A� 向 C� 提交任意密文 c�, C� 计算对应的明文 m�</li><li>重复步骤3 q� 次, 步骤4 q′�′ 次 (即敌手查询 q� 次不同消息的密文, 查询q′�′ 次不同密文的解密结果)</li><li>A� 提交明文 m0�0 与 m1�1 给 C�</li><li>C� 以抛硬币（flip a coin）的形式随机选择一个比特 b$←{0,1}�←${0,1}, C� 加密返回挑战密文 cb��</li><li>A� 根据 cb�� 输出自己的猜测比特 b∗�∗ (即敌手猜测 C� 是加密的 m0�0 还是 m1�1 )</li></ol><p>在此模型中，由于敌手没有密钥, 因此它很难生成合法的密文。因此，A�每次提交的密文大概率会解密出一些无意义的结果，但开放解密Oracle的目的在于，让敌手能在拥有并篡改密文的条件下，依然做到对算法明文的保护。因为一个加密算法如果仅能支持CPA安全性，那么中间人敌手可能会<strong>截获密文</strong>并对其进行针对性的<strong>篡改</strong>，从而使这种篡改也被施加到了<strong>解密后的明文</strong>中，进而敌手能通过篡改后的明文来攻破加密的不可区分性。</p><p>因此，我们希望一个算法还能实现对其输出密文的保护，使得敌手无法通过修改密文来观测解密算法的行为，IND-CCA就是由这一需求应运而生的。类似地，IND-CCA中敌手的优势可写作：</p><p>Pr[A wins]=Pr[b∗=b]=12+AdvIND−CCAE,D(A)Pr[� wins]=Pr[�∗=�]=12+Adv�,�IND−CCA(�)</p><h2 id="IND-CCA2"><a href="#IND-CCA2" class="headerlink" title="IND-CCA2"></a>IND-CCA2</h2><p>与上面的IND-CCA相比，IND-CCA2只多了一个步骤，如下所示。</p><p><img src="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220514162841123-1240011961.png" alt="img">其步骤总结如下：</p><ol><li>Game中拥有一具有多项式资源的<strong>敌手A�</strong> 和一个能自由调用加解密oracle E,D�,� 的<strong>挑战者C�</strong>。</li><li>C� 随机选取K$←{0,1}n�←${0,1}�，作为加解密算法的密钥</li><li>A�向 C� 提交任意明文 m�, C� 计算对应的密文 c�</li><li>A� 向 C� 提交任意密文 c�, C� 计算对应的明文 m�</li><li>重复步骤3 q� 次, 步骤4 q′�′ 次 (即敌手查询 q� 次不同消息的密文, 查询q′�′ 次不同密文的解密结果)</li><li>A� 提交明文 m0�0 与 m1�1 给 C�</li><li>C� 以抛硬币（flip a coin）的形式随机选择一个比特 b$←{0,1}�←${0,1}, C� 加密返回挑战密文 cb��</li><li><strong>A� 在收到挑战密文 cb�� 后, 还可以向 C� 提交若干次解密查询</strong></li><li>A�自己的猜测比特 b∗�∗ (即敌手猜测 C� 是加密的 m0�0 还是 m1�1 )</li></ol><p>可以看到在第8步时， CCA2允许敌手在提交了自己的挑战明文后，依然能进行若干次解密查询。与CCA（或说CCA1）相比，CCA2令敌手通过最开始的若干次解密查询进行学习与观察后，即使收到了挑战密文 cb��，还能继续进行学习。</p><p>这个能力让敌手可根据 cb�� 继续去构造和猜测，而且CCA2中 C� 提供的 Oracle 相当于<strong>永久开放</strong>给敌手[1]，而CCA1在敌手最初查询后 Oracle 就不允许再访问了，因此CCA2这一定义是比CCA1更强的安全模型。</p><blockquote><p>小结📝：目前我们已介绍了三种安全模型IND-CPA、IND-CCA、IND-CCA2，这其中的敌手目的都是为了区分  mb�� 对应的密文。三者的安全要求逐渐提高，IND-CCA2也是目前标准定义下对安全性要求最高的模型，当前学术界一般认为一个新的公钥加密算法都应达到IND-CCA2的要求。</p></blockquote><h2 id="LOR-CPA"><a href="#LOR-CPA" class="headerlink" title="LOR-CPA"></a>LOR-CPA</h2><p>与IND-CPA相比，我们首先可以看到这个安全性定义的目标发生了变换，即从IND（不可区分性）变成了LOR（Left Or Right, 即左或右），但本质依旧不变。这一Game的具体示意图如下所示。</p><p><img src="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220515125648885-1832649954.png" alt="img">可以看到，在LOR-CPA中，那个随机的bit b� 一开始就选择好了，即  C� 每次加密的其实都是左边或右边的明文。基本步骤如下所示:</p><ol><li>Game中拥有一具有多项式资源的<strong>敌手A�</strong> 和一个能自由调用加密算法oracle E� 的<strong>挑战者C�</strong>。</li><li>C� 随机选取K$←{0,1}n�←${0,1}�，作为加密算法的密钥</li><li>A� 提交明文 m0�0 与 m1�1 给 C�</li><li>C� 以抛硬币（flip a coin）的形式随机选择一个比特 b$←{0,1}�←${0,1} ,计算 mb�� 对应的密文 cb��</li><li>重复步骤 3 q� 次 (即敌手和挑战者实现 q� 次对左边或右边消息的加密)</li><li>敌手输出自己的猜测比特 b∗�∗</li></ol><p>在这一安全模型中，敌手的目标是猜测C�加密的是左右哪边的明文。因此，与IND-CPA相比，LOR-CPA这个Game本身其实是相当于IND-CPA的最后敌手应答挑战密文的那一次query。诚然在LOR-CPA中，敌手其实也可以重复多次进行 m0�0 与 m1�1 的查询，但那一随机bit始终是固定的。</p><p>而在安全强度方面，LOR-CPA比IND-CPA是要稍弱一些的[2]，因为LOR-CPA并不包含有若干次的任意明文的询问学习过程，虽然它不像IND-CPA那般成为了衡量加密算法安全性的“至上公理”[3]，但还是值得我们去记住和分析的。</p><h2 id="ROR-CPA"><a href="#ROR-CPA" class="headerlink" title="ROR-CPA"></a>ROR-CPA</h2><p>此处的ROR意为Real or Random， 该Game的示意图如下所示。</p><p><img src="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220515125632396-194368939.png" alt="img">在ROR-CPA中，挑战者要么加密敌手所提供的输入，或者加密一个和敌手输入等长的随机字符串。而敌手的目标是决定C�加密的是真正的明文输入 (Real)， 还是一个随机的输入（random），这一Game的基本步骤如下所示：</p><ol><li>Game中拥有一具有多项式资源的<strong>敌手A�</strong> 和一个能自由调用加密算法oracle E� 的<strong>挑战者C�</strong>。</li><li>C� 随机选取K$←{0,1}n�←${0,1}�，作为加密算法的密钥</li><li>A� 向 C� 提交明文 m�</li><li>C� 以抛硬币（flip a coin）的形式随机选择一个比特 b$←{0,1}�←${0,1}, 令 mb=m��=� (b=0�=0) 或 mb$←{0,1}n��←${0,1}� (b=1�=1);</li><li>C� 计算并返回 mb�� 对应的密文 cb��</li><li>重复步骤 3-5 q� 次 (即敌手和挑战者实现 q� 次对左边或右边消息的加密)</li><li>敌手输出自己的猜测比特 b∗�∗</li></ol><p>ROR-CPA在安全性强度上是与LOR-CPA等价的。在介绍完ROR-CPA后，我们在<strong>不可区分性</strong>这一小节中的经典安全定义都总结完了，下面将会给大家介绍两个出现在很多实际Cyber Attack中的安全定义。</p><h2 id="Known-Plaintext-Attack"><a href="#Known-Plaintext-Attack" class="headerlink" title="Known Plaintext Attack"></a>Known Plaintext Attack</h2><p>本文一上来就为大家介绍了IND-CPA这个经典模型，而很多教材会先为读者介绍两个模型，即 Known Plaintext Attack 与 Ciphertext Only Attack。而在理解了IND-CPA及上述安全模型后，这两个安全定义就非常好理解了。</p><p>KPA的中文是”已知明文攻击”, 但其真正含义是敌手在可以获取一个加密算法的<strong>明文及对应密文</strong>之后，试图还原该算法的密钥。因此，KPA的安全定义更适用于一些主动的半侵入式攻击，即攻击者能实际获取并<strong>运行承载有这个密码算法的设备</strong>，比如智能卡，密码芯片等。</p><p>这样一来，敌手的目标就是希望通过不断调用这个设备里的密码算法，从而获取非常多的算法明密文对，进而尝试还原设备中的密钥，达到攻破甚至复制这一设备的最终目标。KPA这个安全定义常见于密码算法的能量侧信道分析中。</p><h2 id="Ciphertext-Only-Attack"><a href="#Ciphertext-Only-Attack" class="headerlink" title="Ciphertext Only Attack"></a>Ciphertext Only Attack</h2><p>同理，COA就表示唯密文攻击，即敌手仅能以中间人的状态截获一些算法的密文，他无法调用这个算法，即仅能通过眼前拿到的这一堆密文中，尝试得到与明文或者密钥有关的信息。</p><p>可以看到，唯密文攻击是几个定义中敌手能力最弱的了，敌手无法自行构造与选择要加密或解密的明密文，也无法自由地调用这个算法。KPA与COA这两种有些另类的安全模型通常会出现在一些系统安全的问题中，如一些网络攻击，物理攻击等。在密码理论领域中，前文介绍的几类模型是更为常用的。 </p><h1 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h1><h2 id="INT-CTXT"><a href="#INT-CTXT" class="headerlink" title="INT-CTXT"></a>INT-CTXT</h2><p>谈到数据完整性，我们主要考虑的是消息（明文， PlainText）完整性或算法输出（密文，CiphtText）的完整性。因此，INT（Integrity）可以理解为，敌手无法伪造一段<strong>密文</strong>或某段合法密文对应的<strong>明文</strong>，使其在接收方看来是由发送方生成且传输过程中未受到任何篡改的。</p><p>因此，INT-CTXT这一Game的主要步骤为：</p><ol><li>Game中拥有一具有多项式资源的<strong>敌手 A�</strong> 和一个能自由调用加密算法oracle E� 的<strong>挑战者C�</strong>。</li><li>C� 随机选取K$←{0,1}n�←${0,1}�，作为加密算法的密钥</li><li>A� 向 C� 提交明文 m�, C� 计算 m� 对应的密文 c�</li><li>重复步骤 3 q� 次 (即敌手查询 q� 次不同消息的密文)</li><li>A� 提交一密文 c∗�∗ 给 C�</li><li>C� 对  c∗�∗ 执行解密操作, 返回解密后的消息 m∗�∗;</li></ol><p>其示意图如下图所示:</p><p><img src="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220516145308412-1148001009.png" alt="img"></p><p>这一安全模型中，敌手可以多次访问加密Oracle，而最终进行挑战时，需提交一个密文 c∗�∗, 其目的是使 c∗�∗ 能正常通过解密算法得到一个明文 m∗�∗。如果 m∗�∗ 非空 （即真的完成了解密过程）且 c∗�∗ 没有在查询阶段出现过，那么就称 A� 赢得这个Game。此时大家就会想到，岂不是任何一个对称加解密算法都做不到INT-CTXT吗？</p><p>没错，一个<strong>不加任何防护</strong>的对称密码算法，如AES，就是不能做到INT-CTXT安全性，因为任何人可以随便拿一条数据输入到解密算法里，只要数据的格式是正确的，虽然解密输出的内容可能是一些杂乱的无意义字符，但依然是有效的明文。</p><p>因此，如果要达到INT-CTXT安全性，就必须对原有算法<strong>输出的密文加以防护</strong>，例如增加一消息认证算法（MAC）等。看到这里，可能很多读者会联想这一安全性与上文中IND-CCA的联系。其实，当一个算法同时具备IND-CPA与INT-CTXT安全性时，该算法就有潜力是IND-CCA安全的；这一结论通常被用于<strong>认证加密算法</strong>的安全性证明中。</p><h2 id="INT-PTXT"><a href="#INT-PTXT" class="headerlink" title="INT-PTXT"></a>INT-PTXT</h2><p>与密文完整性相对应，PTXT指的是明文的完整性，而这一Game的步骤与INT-CTXT完全相同。唯一的区别在于，INT-PTXT中的敌手 A� 获胜的条件是：解密后的 m∗�∗ 非空且 m∗�∗ 没有在之前的查询过程中提交过。注意INT-CTXT要求的则是 c∗�∗ 没有出现过。</p><p>通常, INT-CTXT中这一安全性是稍强于INT-PTXT的，即对于一个方案而言，如果是INT-CTXT安全的，那么也一定是INT-PTXT安全的。这也不难理解，因为在解密算法为<strong>确定的</strong>、<strong>无碰撞</strong>的条件下，如果一个明文 m∗�∗ 没有提交过，那么加密后的密文必然也没有出现过；否则如果密文 c∗�∗ 出现过的话，由加解密置换的唯一性可知  c∗�∗ 对应的明文必然也出现过。因此一般情况下，我们希望能够证明某个算法是INT-CTXT安全的。</p><blockquote><p>💡 在数据完整性中，有些读者可能会想到密码学哈希函数的三个安全性质: 单向性、弱碰撞性、强碰撞性；而本文主要聚焦一个密码算法数据完整性的通用模型，哈希函数可以作为一种实现上述数据完整性的工具。 </p></blockquote><h1 id="抗否性与身份认证"><a href="#抗否性与身份认证" class="headerlink" title="抗否性与身份认证"></a>抗否性与身份认证</h1><p>介绍完了数据完整性后，我们该介绍最后一部分常见的安全需求与安全模型了，即抗否性（Non-repudiation），或称抗抵赖性。这一需求是指某一方计算出的数据是与它身份绑定的，没有其他人能像这一方本人一样计算出一样的数据。因此，数字签名、身份认证等算法或协议需要对这一性质加以描述。下面将介绍几个最常见的安全模型。</p><h2 id="EUF-CMA"><a href="#EUF-CMA" class="headerlink" title="EUF-CMA"></a>EUF-CMA</h2><p>这一模型中的CMA指Chosen Message Attack，即选择消息攻击，本质上与CPA其实是一样的，只不过在数字签名等算法中，用消息一词要比明文更加贴切。CMA和CPA都是形容敌手能自由地向算法提交输入并获得的相应输出这一能力。</p><p>EUF则是指存在性不可伪造，即 Existential UnForgeability，指的是对于消息认证、数字签名等算法而言，当敌手通过查询获得了 q� 个签名后， 他无法再获得第 q+1�+1 个签名。这一Game的示意图如下所示。</p><p><img src="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220517145446612-124220213.png" alt="img"></p><p> 可以看到，其基本形式依然和前文的模型保持相似，在查询阶段，敌手 A� 可不断与一实现了签名Oracle的 C� 交互，来获得所提交消息 m�的签名 σ�。在进行 q� 次交互后，敌手将输出一对 (m∗,σ∗)(�∗,�∗)。这一Game的主要步骤为：</p><ol><li>Game中拥有一具有多项式资源的<strong>敌手 A�</strong> 和一个能自由调用签名算法oracle E� 的<strong>挑战者C�</strong>。</li><li>C� 随机选取sk$←{0,1}n��←${0,1}�，作为签名算法的私钥</li><li>A� 向 C� 提交消息 m�, C� 得到 m� 对应的签名 σ�</li><li>重复步骤 3 q� 次 (即敌手查询 q� 次不同消息的签名)</li><li>A� 输出一对 (m∗,σ∗)(�∗,�∗);</li><li>C� 对  σ∗�∗ 进行验证，并返回验证结果;</li></ol><p>若最后敌手输出的 m∗�∗ 未曾被查询过，且 σ∗�∗ 能通过验证，就可认为敌手挑战成功。这一结果即为“<strong>签名的伪造</strong>”，此处敌手的优势可写为：</p><p>AdvEUF−CMAS(A)=Pr[A forges (m∗,σ∗)]Adv�EUF−CMA(�)=Pr[� forges (�∗,�∗)]</p><h2 id="SUF-CMA"><a href="#SUF-CMA" class="headerlink" title="SUF-CMA"></a>SUF-CMA</h2><p>在EUF-CMA中，E表示的是Existential，而此处的SUF的S则表示Strong，即强不可伪造性，这一Game的基本模型如下图所示。</p><p><img src="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220517145454808-1367273401.png" alt="img"></p><p>与EUF-CMA相比，SUF-CMA唯一的不同之处在于敌手最终输出伪造的签名对 (m∗,σ∗)(�∗,�∗) 时，不仅要求 m∗�∗ 是未曾查询过的，也要求签名 σ∗�∗ 是未曾出现过的。因此，EUF-CMA这一Game中的敌手只需要寻找到 m� 关于 σ� 的一个<strong>碰撞</strong>即可，而在SUF-CMA中，敌手的任务并不是要找碰撞，而是要从根本上伪造出一个签名消息对。</p><p>EUF-CMA中的敌手最差也可以使用<strong>生日攻击</strong>去暴力地寻找碰撞，而SUF-CMA中的敌手则是应真正生成去另外一对 (m∗,σ∗)(�∗,�∗)。因此，SUF-CMA是比EUF-CMA安全性更强的安全模型。这两个模型通常用于消息认证、数字签名算法的安全性定义上，以说明其签名的不可伪造性，从而使实体是不可抵赖。</p><h2 id="Impersonation"><a href="#Impersonation" class="headerlink" title="Impersonation"></a>Impersonation</h2><p>这一部分要说明的安全模型与本文前面所介绍的都有所不同，对于一个身份认证协议而言，impersonation表示敌手最终能假冒某个合法用户的身份通过认证。这一概念最开始是为了描述Fiat-Shamir Protocol 以及 Shnorr Identification Protocol的安全性。</p><p>然而，身份认证协议是多种多样的，这一安全模型也不像上面的 EUF-CMA 等具有统一的定义方式。不过，Impersonation的基本过程依然可以总结为“查询-挑战”两个阶段， 即敌手先根据协议开放的某个Oracle进行查询，之后生成认证数据“试图”通过协议的检查，完成身份的认证。</p><blockquote><p>小结📝: 到此为止，几个经典的安全模型均介绍完毕。下面本文将介绍量子计算机模型下的安全模型，与这些经典安全模型相比，它们的交互方式与计算方法均有所不同。 </p></blockquote><h1 id="量子安全模型"><a href="#量子安全模型" class="headerlink" title="量子安全模型"></a>量子安全模型</h1><h2 id="量子计算与量子查询"><a href="#量子计算与量子查询" class="headerlink" title="量子计算与量子查询"></a>量子计算与量子查询</h2><p>为介绍量子计算机下的安全模型， 需要了解下载量子计算机中的算法有何不同。而量子计算机离不开量子力学，我们最熟悉的关于量子力学的理论莫过于<strong>薛定谔的猫</strong>。量子的世界本质上是用态（ ψ� ）来描述的，例如，放着猫的盒子如果看作一个量子世界的话, 薛定谔的猫死了其实就是一个<strong>态</strong>（纯态），而薛定谔的猫既生又死也是一个态，只不过是一个<strong>叠加态</strong>（混态）。那么，量子计算机究竟强大在何处呢? </p><p>量子计算机与量子算法的基本操作对象是<strong>量子比特</strong>（qubit），而在量子世界中，一个量子比特可以既是0也是1，即处于0-1叠加态。这样一来，量子计算机中的一个8 qbit寄存器，在某一时刻可<strong>最多表示 2828 条数据</strong>！但经典计算机中的8 bit寄存器某一时刻只能存1个数据。因此，对8 qbit寄存器里的数据运算一次，能最多得到 2828种结果，这与经典计算机相比会是指数级别的算力提升。这也就是为什么密码学家们对于量子计算机的出现如此恐慌了。那么，我们的安全模型在量子计算下该如何表示呢？</p><p>首先，需要明确量子安全模型中<strong>敌我的能力与目标</strong>。在量子安全模型中, 敌手和挑战者是都具备量子计算能力的, 而挑战者中的密码算法已经被实现或抽象为了一个quantum accessable oracle。注意算法本身是可运行于经典计算机上的, 只不过为了方便，我们人为抽象它为一个量子oracle。此时这个算法在面对一个8 qbit的输入数据叠加态时，能直接对其操作并返回对应的输出数据叠加态。即，<strong>算法的功能不变，但支持了对叠加态量子数据的操作</strong>。</p><p>由此，在量子计算下，敌手 A� 发起的一次针对加密算法的量子查询可以表示如下[4]：∑m,cψm,c|m,c⟩⟶∑m,cψm,c|m,c⊕Enc(k,m)⟩∑�,���,�|�,�⟩⟶∑�,���,�|�,�⊕Enc⁡(�,�)⟩ 这个式子第一眼看上去可能完全不知道在做什么，不要急我们一一解释。式子中的左半边到右半边, 表示这一次量子查询前后敌手 A� 的<strong>状态变化。</strong>而式子左右两端的求和式, 分别表示<strong>两个量子叠加态</strong> (一个量子计算机的当前状态可用一个叠加态来表示)。因此，这个式子实际就表示一次<strong>敌手的量子计算机状态的转换</strong>。</p><p>而敌我双方量子计算机所执行的运算, 本质就是在读写两个量子寄存器中的数据: 一个输入明文量子寄存器 <strong>QM</strong> 和一个输出密文量子寄存器 <strong>QC</strong> 。对于敌手 A�, 他在查询时会往QM中”叠加”入大量的明文消息, QC则置空；对于挑战者 C�, 则会读取 QM 中传过来的明文叠加态, 进行加密算法的运算后, 得到密文的叠加态并写入 QC 中，返回给敌手。</p><p>那回归到式子本身, ∑m,cψm,c|m,c⟩∑�,���,�|�,�⟩其实就表示将若干个明文态叠加起来变成一个叠加态, 即查询前的量子寄存器的内容。∑m,cψm,c|m,c⊕Enc(k,m)⟩∑�,���,�|�,�⊕Enc⁡(�,�)⟩ 则表示挑战者计算后, 往QC中叠加了密文后的新叠加态。式子中的 ψ� 表示某个量子态的表征值。</p><p>因此, 量子查询用一句话概括就是: 对于QM, QC这两个量子寄存器而言, A� 往QM里叠加消息并提交给挑战者, C� 计算后往QC里叠加密文并返回给敌手。这一过程的示意图如下:</p><p><img src="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220518114312292-2088865640.png" alt="img"></p><h2 id="IND-qCPA"><a href="#IND-qCPA" class="headerlink" title="IND-qCPA"></a>IND-qCPA</h2><p>那么在明确量子查询的含义后, IND-qCPA的过程其实就明了了. 这一Game的示意图如下所示:</p><p><img src="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220520143501420-324864716.png" alt="img"></p><p>可以看到, 在敌手的查询部分, 就是采用的我们上面介绍的量子查询; 然而, 在最终的挑战环节, 敌手和挑战者依然采用的是经典模型。这是因为如果敌手如果最终的挑战也是以量子寄存器的方式进行的话, Boneh等曾证明了敌手总能正确猜测出来那个bit b�。</p><p>因此, 我们不得不妥协一下, 让敌手可以执行量子查询, 但是<strong>不能执行量子挑战。</strong>除此以外, IND-CPA与IND-CCA是如何理解的, IND-qCPA与IND-qCCA 我们还可以怎么去理解。</p><h2 id="EUF-qCMA"><a href="#EUF-qCMA" class="headerlink" title="EUF-qCMA"></a>EUF-qCMA</h2><p> 而对于量子签名查询, 和加密类似, 核心的框架依然没变, 只是套用了量子查询这种形式下。这一Game的示意图如下所示:</p><p><img src="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220520143629734-632760535.png" alt="img"></p><p>同理, 签名方案下的量子状态转移式, 应该写作[5]: ∑m,σψm,σ|m,σ⟩⟶∑m,σψm,σ|m,σ⊕Sign(k,m)⟩∑�,���,�|�,�⟩⟶∑�,���,�|�,�⊕Sign⁡(�,�)⟩ 此处的签名挑战同样是在经典计算机而非量子计算机下执行的。</p><blockquote><p>可能很多读者此时心中有个疑问❓：量子查询与量子安全模型和经典模型似乎也没什么不同嘛！那为什么量子安全模型普遍认为是更强的安全性要求呢？</p><p>还记得本节开始时提到，一个量子寄存器中蕴含了指数量级的数据，但是攻击者在<strong>观测</strong>这个量子寄存器时，会发生<strong>叠加态的坍缩</strong>，即虽然有那么多数据，但攻击者每次依然只能获得一个值。</p><p>然而，他可以借助高效的<strong>量子搜索算法</strong>迅速地找到自己想要的那个值。Grover算法[6]、Shor算法、Simon算法、Deutsch–Jozsa 算法等就是能在量子叠加态数据中，以较低的复杂度进行查找的量子算法。量子安全模型中的敌手也可以使用这些算法，这就是让密码学家们一直担忧的达摩克利斯之剑。</p></blockquote><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>现代密码学中的主要安全模型与后量子安全模型已经全部介绍完了, 如果我们总结下规律可以发现, 这些安全模型的定义都遵从 <strong>安全目标</strong>-<strong>交互模型</strong> 这个规则, 例如IND-CPA中IND形容的是算法输出达到不可区分性, 而达到这一目标是在选择明文攻击 (CPA)这一交互模型下实现的。</p><p>因此, 只要你能严格的定义出某种交互模型以及对应的安全目标, 你就能提出属于你的安全模型。因此，其实还有很多学术界会用到的密码学安全模型本文是没有介绍的，但万变不离其宗，任何一个密码学安全模型都脱离不了所针对的算法功能及安全目标。</p><p>综上，本文一共介绍了14个现代密码学中的安全模型，了解它们的结构和原理可以为密码学中的安全性证明打下坚实的基础。最后，感谢你的阅读，以一句歌词作为结束。</p><p>“<em>毋忘你 精彩过别来无恙如游戏</em>，<em>我本人 明白什么都总有限期” —— 吴雨霏《我本人》</em></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p>[1] <a href="https://crypto.stackexchange.com/questions/99295/the-essential-differences-between-ind-cca1-and-ind-cca2">https://crypto.stackexchange.com/questions/99295/the-essential-differences-between-ind-cca1-and-ind-cca2</a><br>[2] <a href="https://crypto.stackexchange.com/questions/33279/difference-left-or-right-cpa-security-ind-cpa-security">https://crypto.stackexchange.com/questions/33279/difference-left-or-right-cpa-security-ind-cpa-security</a><br>[3] <a href="https://link.springer.com/content/pdf/10.1007/s00145-008-9026-x.pdf">https://link.springer.com/content/pdf/10.1007/s00145-008-9026-x.pdf</a><br>[4] <a href="https://eprint.iacr.org/2012/606.pdf">https://eprint.iacr.org/2012/606.pdf</a><br>[5] <a href="https://eprint.iacr.org/2013/088.pdf">https://eprint.iacr.org/2013/088.pdf</a><br>[6] <a href="https://en.wikipedia.org/wiki/Grover&#39;s_algorithm">https://en.wikipedia.org/wiki/Grover&#39;s_algorithm</a></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Self-Supervised_FL</title>
    <link href="/2023/03/06/Self-Supervised-FL/"/>
    <url>/2023/03/06/Self-Supervised-FL/</url>
    
    <content type="html"><![CDATA[<p>AI 的成功依赖优质数据源，医学数据数据集标签需要专业知识。</p><h4 id="联邦学习挑战"><a href="#联邦学习挑战" class="headerlink" title="联邦学习挑战"></a>联邦学习挑战</h4><ol><li>数据异质性，性能降低</li><li>有标签的数据量不够，客户端存在大量非标签的数据</li></ol><p>提出一种鲁棒的自监督联邦学习框架</p><p><img src="/images/Self-Supervised-FL/image-20230306171446082.png" alt="image-20230306171446082"></p><p>step 1 分布式自监督联邦预训练，挖掘分布在不同客户端的无标签的数据的知识</p><p>step 2 传统微调联邦学习</p><p>本文自监督用的是图像掩膜建模方法，和对比学习不同，对给定的图像的重建的学习，随机掩盖图像的部分，达到自监督学习的效果。（BEiT、 MAE）</p><p>早期自监督用的是对比学习。</p><h4 id="本文自监督模块"><a href="#本文自监督模块" class="headerlink" title="本文自监督模块"></a>本文自监督模块</h4><ol><li>Masking  随机盖住图像的部分image patches（自监督）</li><li>Encoder </li><li>Decoder 将输入的编码进行信号重建</li><li>Loss function</li></ol><h4 id="workflow"><a href="#workflow" class="headerlink" title="workflow"></a>workflow</h4><ol><li>本地客户端在本地数据集上进行自监督学习，更新本地Encoder、Decoder </li><li>上传联邦中心进行加权平均，得到全局模型，返回客户端继续训练</li><li>当达到最大联邦轮时，进入有监督联邦微调，此时只用Encoder </li></ol><p><img src="/images/Self-Supervised-FL/image-20230306191821570.png" alt="image-20230306191821570"></p><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p><img src="/images/Self-Supervised-FL/image-20230306191953121.png" alt="image-20230306191953121"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DeSearch(去中心化搜索引擎)</title>
    <link href="/2023/03/01/DeSearch/"/>
    <url>/2023/03/01/DeSearch/</url>
    
    <content type="html"><![CDATA[<h4 id="Bringing-Decentralized-Search-to-Decentralized-Services"><a href="#Bringing-Decentralized-Search-to-Decentralized-Services" class="headerlink" title="Bringing Decentralized Search to Decentralized Services"></a>Bringing Decentralized Search to Decentralized Services</h4><blockquote><p>为去中心化服务提供去中心化的、可验证的、隐私保护的搜索</p><p>源码：<a href="https://github.com/SJTU-IPADS/DeSearch">https://github.com/SJTU-IPADS/DeSearch</a></p><p>主页：<a href="https://www.usenix.org/conference/osdi21/presentation/li">https://www.usenix.org/conference/osdi21/presentation/li</a></p></blockquote><p>目前的中心化服务和其对应的去中心化架构的服务</p><p><img src="/images/DeSearch/image-20230301194330238.png" alt="image-20230301194330238" style="zoom:50%;"></p><h4 id="已有方案"><a href="#已有方案" class="headerlink" title="已有方案"></a>已有方案</h4><p>去中心化搜索引擎：</p><ol><li>IPFS搜索 <a href="https://ipfs-search.com/#/search">https://ipfs-search.com/#/search</a></li><li>Yacy搜索 <a href="https://yacy.net/">https://yacy.net/</a>.</li></ol><p>以上方案可以共享索引，并在任意peer节点查询（分布式哈希表），但是不支持可验证，并且peer节点可以监控用户的请求，还是能够泄露隐私。要想保护隐私，用户可以自己运行一个索引节点去访问区块链中的内容，但是大部分用户并没有这个资源和专业知识，一旦依赖其他第三方索引器又回到了内容审查和隐私问题上。</p><h4 id="本文的设计目标-amp-pipeline"><a href="#本文的设计目标-amp-pipeline" class="headerlink" title="本文的设计目标&amp;pipeline"></a>本文的设计目标&amp;pipeline</h4><p>设计一个去中心化搜索引擎，该引擎满足：</p><ol><li>可验证数据源、真实性</li><li>用户的查询信息保密、不可见</li><li>为用户提供查询执行结果的证明</li></ol><p><img src="/images/DeSearch/image-20230306195833028.png" alt="image-20230306195833028"></p><blockquote><p>DESEARCH outsources fragments of search tasks such as crawling, indexing, aggregation, ranking, and query processing to trusted execution environments (TEEs) running on untrusted executors that compose a decentralized network, and introduces new data structures and mechanisms that make executors’ operations reusable and externally verifiable.</p><p>DESEARCH将爬取、索引、聚合、排序、查询处理等搜索任务的片段外包给运行在不可信执行者上的可信执行环境( TEE )，构成一个去中心化的网络，并引入新的数据结构和机制，使执行者的操作具有可重用性和外部可验证性。</p><p>To summarize, the contributions of this paper are: • The design of DESEARCH, the first decentralized search engine that allows any executors with a TEE to join and provide search functionality for decentralized services. • A witness mechanism that organizes verifiable proofs from short-lived executors to form a global dataflow graph. Through these witnesses, DESEARCH offers fast verification for search queries.</p><p>归纳起来，本文的贡献有：•设计了第一个分散式搜索引擎研究，它允许任何具有TEE的执行器加入并为分散式服务提供搜索功能。•设计了一个见证机制，它组织来自短寿命执行器的可验证证明以形成全局数据流图。通过这些见证者，研究为搜索查询提供快速验证。</p></blockquote><h4 id="Challenges"><a href="#Challenges" class="headerlink" title="Challenges"></a>Challenges</h4><ol><li><p>分布式P2P网络的不稳定，worker可以随时离开。</p></li><li><p>不可信环境，数据被监控，监管</p><p><img src="/images/DeSearch/image-20230306203123574.png" alt="image-20230306203123574"></p></li></ol><p>解决challenge1—— decouple states from computation</p><blockquote><p><img src="/images/DeSearch/image-20230306203344950.png" alt="image-20230306203344950"></p></blockquote><p>解决challenge2—— 可验证难题，从看板可验证，和lambdas可验证两方面进行</p><blockquote><p><img src="/images/DeSearch/image-20230306204813102.png" alt="image-20230306204813102"></p><p>将看板内容划分为epoch，在每个epoch，计算root hash ，提交到block chain</p><p>每个client 可以从自己的short hash to verify 看板上某个特定的epoch</p><p>这个设计运用了现有的云和区块链基础设施，cloud 提供经济高效的存储，区块链提供看板上不可篡改的验证</p><p>short 减轻了链上的存储开销，基于epoch的操作避免了高额的区块链交互开销？？</p></blockquote><p><img src="/images/DeSearch/image-20230306210500389.png" alt="image-20230306210500389"></p><p>如何验证除看板外的分布式Lambda的计算是可验证的，它们处在不可信的环境中。目前的笔记本基本都支持TEE环境，但不能简单的将搜索Lambda 放到TEE运行，然后验证它们是正确的。因为，见如下PPT</p><p><img src="/images/DeSearch/image-20230306210523562.png" alt="image-20230306210523562"></p><blockquote><p>TEE 证明搜索function按照期望正确执行，但是数据输入不一定完整/正确，导致结果不一定完整/正确，故设计一个verification code 加入到TEE的Lambda中。具体做法是 decouple verification from computation。</p><ol><li><p>Lambda computes without verification</p></li><li><p>use witness</p></li><li><p>each step of search pipeline: Lambda creates a corresponding witness to mirror the data flow</p></li><li><p>place this witness on 看板</p></li><li><p>看板 conform the verification plane <strong>for the offline verification</strong> later</p><p><img src="/images/DeSearch/image-20230306212825144.png" alt="image-20230306212825144"></p></li></ol></blockquote><p>其中，第三步，Lambda creates witness，具体做法：</p><blockquote><ol><li>put the search function into verifiable Lambda</li><li>place the witness logic into Lambda</li><li>当输入进入Lambda时，被witness锁定，然后传给function，function 生成 result，然后witness锁定result，result 作为输出离开Lambda</li><li>witness Lock all the inputs and outputs in the function，records what has happened in the lambda honestly</li><li>witness 的数据结构 记录了input具体是怎么被function处理的全过程</li></ol><p>注：witness 和 function 被隔离在不同的sandboxes to avoid a bunky function tampering with integrity of the witness</p><p><img src="/images/DeSearch/image-20230306213413755.png" alt="image-20230306213413755"></p><ol><li>在 search pipeline 的每一步中，每个lambda 生成一个witness，witness记录了输入输出之间的 causality</li><li>这些 witness 会被组织成一个tree，因为witness 记录了输入输出的内容，用户可以追踪树的路径去检查内容完整性</li></ol><p><img src="/images/DeSearch/image-20230307150500049.png" alt="image-20230307150500049"></p></blockquote><p>解决challenge2—— 搜索隐私问题</p><p>SGX可以将 search function和系统其他内容隔离，故SGX可以提供隐私搜索，但还存在两个威胁：</p><ol><li>network adversary can eavesdrop on the communication between users and queriers 攻击者窃听交流信息（监视网络包的数量和信息长度，推断关键字长度）</li><li>执行器可通过内存访问的形式推断关键字</li></ol><p><img src="/images/DeSearch/image-20230307152942690.png" alt="image-20230307152942690"></p><p>总结 -Dsearch</p><ol><li>全局 看板（就是云服务器），数据被提交到看板，同时生成hash上链</li><li>crawlers 将数据和其对应的witness添加到看板上</li><li>indexer 用这些数据生成索引和其对应的witness</li><li>querier 用索引为client提供搜索服务</li><li>client 可以通过检查witness来验证结果</li></ol><p><img src="/images/DeSearch/image-20230307155531523.png" alt="image-20230307155531523"></p><p><img src="/images/DeSearch/image-20230307155816596.png" alt="image-20230307155816596"></p>]]></content>
    
    
    <categories>
      
      <category>blockchain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区块链分层分片</title>
    <link href="/2023/02/28/sharding/"/>
    <url>/2023/02/28/sharding/</url>
    
    <content type="html"><![CDATA[<h3 id="Scaling-Blockchain-via-Layered-Sharding（下次可看）"><a href="#Scaling-Blockchain-via-Layered-Sharding（下次可看）" class="headerlink" title="Scaling Blockchain via Layered Sharding（下次可看）"></a>Scaling Blockchain via Layered Sharding（下次可看）</h3><blockquote><p>提出了基于以太坊的新型分片系统，命名为PYRAMID</p></blockquote><p>基于先前工作：<a href="https://ieeexplore.ieee.org/abstract/document/9488747">Pyramid: A layered sharding blockchain system</a></p><p>区块链扩展是区块链广泛引用的重要属性。</p><blockquote><p>However, most of the existing popular blockchain systems suffer from poor scalability Bitcoin [1], Ethereum [2] since their <strong>consensuses involve all nodes</strong>. In other words, every node needs to verify and store all transactions and every consensus message needs to be broadcast in the whole network. (Fabric不需要每个节点都去验证和存储信息，而是将节点分成不同的角色，采用读写集合来统一世界状态)</p></blockquote><p>分片是区块链扩展研究最广泛的方法，其研究瓶颈在于跨分片交易的存在，严重降低了交易吞吐量、增加了分片系统中的确认延迟，目前关于分片的文章基本是都是讨论解决跨分片交易的更佳方案。</p><blockquote><p>Its main idea is to divide nodes into multiple consensus groups called shards. Accounts are distributed to the shards, each of which processes the transactions involving their stored accounts.</p><p>它的主要思想是将节点分成多个共识组，称为分片。账户被分配到分片，每个分片处理涉及其存储账户的交易。</p><p>As shown in Fig. 1(a), each shard maintains a blockchain and runs its own consensus independently. Ideally, the throughput scales out linearly with the number of shards.</p><p>如图 1(a) 所示，每个分片维护一个区块链并独立运行自己的共识。理想情况下，吞吐量随分片数量线性扩展。</p><p>本文主要思想：允许分片重叠，如图(b)节点3，可以直接验证和执行跨分片交易</p><p><img src="/images/sharding/image-20230228150004830.png" alt="image-20230228150004830"></p><p>以太坊预计在2023年某个时间发布分片</p><p><a href="https://ethereum.org/en/upgrades/sharding/">https://ethereum.org/en/upgrades/sharding/</a></p></blockquote><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p>区块链相关领域:</p><ul><li><p>[ ] 供应链溯源</p></li><li><p>[ ] 高性能计算 BAASH: Lightweight, efficient, and reliable blockchain-as-a-service for HPC systems</p></li><li><p>[ ] 搜索引擎 Bringing decentralized search to decentralized services(去中心化搜索引擎)</p><blockquote><p><a href="https://www.usenix.org/conference/osdi21/presentation/li">https://www.usenix.org/conference/osdi21/presentation/li</a></p><p><a href="https://github.com/SJTU-IPADS/DeSearch">https://github.com/SJTU-IPADS/DeSearch</a></p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>blockchain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区块链和高性能计算</title>
    <link href="/2023/01/31/bc-hpc/"/>
    <url>/2023/01/31/bc-hpc/</url>
    
    <content type="html"><![CDATA[<p>橡树岭国家实验室</p><blockquote><p>Furthermore, blockchains represent a fundamentally new type of data store which can simultaneously be public and secure based on cryptography.</p><p>此外，区块链代表了一种基于密码学的可同时公开和安全的新型数据存储方式。</p><p>a new type of system for securing networks</p><p>In terms of data security and distribution, blockchain represents a mechanism for rapidly reaching consensus about the state of data in a way that is strongly resistant to errors and resilient to network node failures.</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BAASH</title>
    <link href="/2023/01/27/BAASH/"/>
    <url>/2023/01/27/BAASH/</url>
    
    <content type="html"><![CDATA[<h1 id="BAASH-Lightweight-Efficient-and-Reliable-Blockchain-As-A-Service-for-HPC-Systems"><a href="#BAASH-Lightweight-Efficient-and-Reliable-Blockchain-As-A-Service-for-HPC-Systems" class="headerlink" title="BAASH: Lightweight, Efficient, and Reliable Blockchain-As-A-Service for HPC Systems"></a>BAASH: Lightweight, Efficient, and Reliable Blockchain-As-A-Service for HPC Systems</h1><blockquote><p>Baash：面向Hpc系统的轻量、高效、可靠的Blockchain - As - A -服务</p></blockquote><h4 id="文章目标"><a href="#文章目标" class="headerlink" title="文章目标"></a>文章目标</h4><blockquote><p><strong>Distributed resiliency</strong> becomes paramount to alleviate the growing costs of <strong>data movement</strong> and <strong>I/Os</strong> while preserving the data accuracy in HPC systems.This paper proposes to adopt <strong>blockchain-like decentralized protocols</strong> to achieve such <strong>distributed resiliency</strong>.</p><p>用区块链的思想来提高分布式系统的容错能力</p><p><strong>This paper proposes two key techniques to enable a blockchain service in HPC systems.</strong>（HPC系统中用区块链特性）</p></blockquote><ul><li>分布式容错distributed resiliency</li></ul><p>​        即分布式系统的容错能力。分布式系统设计中的一个重要目标，是以这样的方式构建系统：它可以从部分失效中自动恢复，而且不会严重的影响整体性能。特别是，当故障发生时，分布式系统应该在进行恢复的同时继续以可接受的方式进行操作，也就是说，它应该能容忍错误，在发生错误时某种程度上可以继续操作。</p><ul><li><p><em>HPC</em>系统体系架构</p><p>高性能计算简称 <em>HPC</em>，是指利用聚集起来的计算能力来处理标准工作站无法完成的数据密集型计算任务，包括仿真、建模和渲染等。将数据和运算相应地分布到多个单元中，这就需要引入<em>并行</em> 概念。</p><p>就硬件配置而言，常用的类型有两种：</p><ol><li>共享内存计算机</li><li>分布式内存集群</li></ol><p><a href="http://cn.comsol.com/multiphysics/high-performance-computing">高性能计算（HPC）</a></p><p><a href="https://blog.csdn.net/weixin_33762130/article/details/92927289">https://blog.csdn.net/weixin_33762130/article/details/92927289</a></p></li><li><p>HPC 的工作机制</p><p>虽然 HPC 可以在单一节点上运行，但它真正强大的地方，在于连接多个 HPC 节点并将其整合成具有并行数据处理能力的集群或超级计算机。HPC 集群可以实现单一系统不可能完成的超大规模模拟计算、AI 推理和数据分析。<a href="https://www.intel.cn/content/www/cn/zh/high-performance-computing/what-is-hpc.html">https://www.intel.cn/content/www/cn/zh/high-performance-computing/what-is-hpc.html</a></p></li><li><p>高性能计算机群（<em>HPC Cluster</em>）：<em>HPC</em>机群基于<em>MPI/</em>调度等软件，将计算任务分配到机群的不同计算节点而提高计算能力，主要应用在科学计算领域。</p></li><li><p>高性能计算—mpi</p><p>Massage Passing Interface:是消息传递函数库的标准规范，由MPI论坛开发。</p><p>在程序中，不同的进程需要相互的数据交换，特别是在科学计算中，需要大规模的计算与数据交换，集群可以很好解决单节点计算力不足的问题，但在集群中大规模的数据交换是很耗费时间的，因此需要一种在多节点的情况下能快速进行数据交流的标准，这就是MPI。MPI是一组用于多节点数据通信的标准，而非一种语言或者接口。<a href="https://zhuanlan.zhihu.com/p/69497154">https://zhuanlan.zhihu.com/p/69497154</a></p></li></ul><h4 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h4><blockquote><p>分布式一致性缓存</p><p>数据溯源</p><p>数据保真</p><p>a blockchain can enable data synchronization in HPC systems with strong reliability in an autonomous fashion.</p><p>区块链能够以自动的方式在可靠性强的HPC系统中实现数据同步。</p></blockquote><h4 id="核心挑战"><a href="#核心挑战" class="headerlink" title="核心挑战"></a>核心挑战</h4><blockquote><p>The key challenge for such an adoption lies in the mismatch between blockchain’s targeting systems (e.g., shared-nothing, loosely-coupled, TCP/IP stack) and HPC’s unique design on storage subsystems, resource allocation, and programming models.</p><p>采用这种方式的关键挑战在于区块链的目标系统(例如,无共享、松耦合、TCP / IP协议栈等)与HPC在存储子系统、资源分配和编程模型上的独特设计之间的不匹配。</p></blockquote><h4 id="contribution"><a href="#contribution" class="headerlink" title="contribution"></a>contribution</h4><blockquote><p>BAASH bridges the HPC-blockchain gap with two key components:</p><p> (i) <strong>Lightweight consensus protocols</strong> for the HPC’s shared-storage architecture</p><p> (ii) A new <strong>fault-tolerant mechanism</strong> compensating for the MPI to guarantee the distributed resiliency.</p><p>BAASH通过两个关键组件弥合HPC -区块链之间的鸿沟：( i ) HPC共享存储架构的轻量级共识协议，( ii )补偿MPI的新容错机制，以保证分布式容错能力。</p></blockquote><p>简单点来说就是为HPC环境设计了一个新的区块链框架，作为中间件部署，命名为BAASH。</p><p><img src="/images/BAASH.assets/image-20230127193022793.png" alt="image-20230127193022793"></p><blockquote><p>We design a set of HPC-specific scalable consensus protocols to facilitate a <strong>parallel block processing </strong>to provide a <strong>lightweight distributed in-memory</strong> and <strong>sharedstorage resiliency support</strong>; </p><p>我们设计了一组特定于HPC的可扩展共识协议，以促进并行块处理，从而提供轻量级的分布式内存和共享存储弹性支持</p></blockquote><p>架构解析</p><p><a href="https://zh.wikipedia.org/zh-hans/InfiniBand">InfiniBand</a></p><blockquote><p><strong>InfiniBand</strong>（直译为“无限带宽”技术，缩写为<strong>IB</strong>）是一个用于<a href="https://zh.wikipedia.org/wiki/超级计算机">高性能计算</a>的计算机网络通信标准，它具有极高的<a href="https://zh.wikipedia.org/wiki/吞吐量">吞吐量</a>和极低的<a href="https://zh.wikipedia.org/wiki/潜伏时间_(工程学">延迟</a>)，用于计算机与计算机之间的数据互连。</p></blockquote><p><a href="https://zh.wikipedia.org/zh-hans/%E8%BF%9C%E7%A8%8B%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE">RDMA</a></p><blockquote><p>在数据中心领域，<strong>远程直接内存访问</strong>（英语：<strong>remote direct memory access</strong>，<strong>RDMA</strong>）是一种绕过远程主机操作系统内核访问其内存中数据的技术，由于不经过操作系统，不仅节省了大量CPU资源，同样也提高了系统吞吐量、降低了系统的网络通信<a href="https://zh.wikipedia.org/wiki/Latency_(engineering">延迟</a>)，尤其适合在大规模并行<a href="https://zh.wikipedia.org/wiki/计算机集群">计算机集群</a>中有广泛应用。在基于NVMe over Fabric的数据中心中，RDMA可以配合高性能的NVMe SSD构建高性能、低延迟的存储网络。</p></blockquote><p><a href="https://en.wikipedia.org/wiki/Diskless_node">Diskless node</a></p><blockquote><p><strong>无盘节点</strong>（或<strong>无盘工作站</strong>）是没有<a href="https://en.wikipedia.org/wiki/Disk_drive">磁盘驱动器的</a><a href="https://en.wikipedia.org/wiki/Workstation">工作站</a>或个人计算机，它使用<a href="https://en.wikipedia.org/wiki/Network_booting">网络引导</a>从<a href="https://en.wikipedia.org/wiki/Server_(computing">服务器</a>)加载其<a href="https://en.wikipedia.org/wiki/Operating_system">操作系统</a>。</p></blockquote><p>共识协议设计</p><p>协议1：协调块的事务并行处理</p><p>协议2：并行管理分布式共识（通过并行事务管理器<code>Parallel transaction manager</code>）</p><p>协议3：管理块验证过程</p><p>协议4：通过将验证后的块存储在节点内存中并持久化共享存储，有助于弹性分布式账本的管理</p><p>过程描述：</p><ol><li>BAASH引擎利用一个队列来跟踪各个活跃和未决事务。所有的事务由hash（地址|时间戳）来做特定标识并锁定，当事务到达时，协议1检查事务是否解锁，并在加入块前为其创造一个唯一的hash值，该块中的交易批处理过程超过时间阈值t时停止。协议1转发block并启动共识进程。</li><li>BAASH共识，协议2引导块的验证和持久化。</li><li>持久化存储。利用键值对将块和交易存储到内存账本和远程存储中</li></ol><p><a href="https://github.com/brianfrankcooper/YCSB">YCSB 区块链评估工具</a></p><p>本文相关工作总结了区块链目前较为重要的研究成果。但是目前没有工作关注到可以弥补HPC和区块链之间差距的底层架构，本文是首次提出用MPI开发的类区块链并行框架，让我们可以利用HPC系统的去中心化机制。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>带有MPI的轻量级区块链架构，The HPC-aware consensus protocols and MPI-compatible reliability, under the framework coined as BAASH, collectively enable a blockchain service for HPC systems.</p>]]></content>
    
    
    <categories>
      
      <category>blockchain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode 配置python环境（Anaconda）</title>
    <link href="/2023/01/19/vscodepython/"/>
    <url>/2023/01/19/vscodepython/</url>
    
    <content type="html"><![CDATA[<h4 id="step1-安装"><a href="#step1-安装" class="headerlink" title="step1 安装"></a>step1 安装</h4><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">安装Anaconda<br>https://mirrors.bfsu.edu.cn/anaconda/archive/<br>配置环境变量，系统变量，path，添加<br>E:<span class="hljs-symbol">\P</span>rogramData<span class="hljs-symbol">\A</span>naconda3<br>E:<span class="hljs-symbol">\P</span>rogramData<span class="hljs-symbol">\A</span>naconda3<span class="hljs-symbol">\S</span>cripts<br>E:<span class="hljs-symbol">\P</span>rogramData<span class="hljs-symbol">\A</span>naconda3<span class="hljs-symbol">\L</span>ibrary<span class="hljs-symbol">\b</span>in<br>E:<span class="hljs-symbol">\P</span>rogramData<span class="hljs-symbol">\A</span>naconda3<span class="hljs-symbol">\L</span>ibrary<span class="hljs-symbol">\m</span>ingw-w64<span class="hljs-symbol">\b</span>in<br><br>检查<br>where python<br>conda --version<br>conda info<br></code></pre></td></tr></table></figure><p><img src="/images/vscodepython.assets/image-20230119150522489.png" alt="image-20230119150522489" style="zoom:50%;"></p><h4 id="step2-配置"><a href="#step2-配置" class="headerlink" title="step2 配置"></a>step2 配置</h4><p>设置镜像</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">conda config --show-sources <span class="hljs-comment">#查看现有源</span><br>conda config --add channels https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/anaconda/</span>pkgs<span class="hljs-regexp">/free/</span><br>conda config --add channels https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/anaconda/</span>pkgs<span class="hljs-regexp">/main/</span><br>conda config --add channels https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/anaconda/</span>cloud<span class="hljs-regexp">/conda-forge/</span><br>conda config --add channels https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/anaconda/</span>cloud<span class="hljs-regexp">/bioconda/</span><br>升级conda<br>conda update conda<br></code></pre></td></tr></table></figure><p>创建虚拟环境，好管理</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">conda create -n xxx python=<span class="hljs-number">3.9</span>           <span class="hljs-comment"># 构建一个虚拟环境，名为：xxx</span><br>conda init bash &amp;&amp; source <span class="hljs-regexp">/root/</span>.bashrc  <span class="hljs-comment"># 更新bashrc中的环境变量</span><br>conda activate xx                        <span class="hljs-comment"># 切换到创建的虚拟环境：xx</span><br>conda env list <span class="hljs-comment">#查看所有环境</span><br>conda list      <span class="hljs-comment">#查看所有库</span><br>查询是否有想要安装的库<br>conda search package_name<br>在当前环境中安装库<br>conda install package_name<br>更新环境中的某个库<br>conda update package_name<br>卸载环境中的库<br>conda uninstall package_name<br></code></pre></td></tr></table></figure><p>vs code中安装 扩展搜python，安装</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xl">`F<span class="hljs-function"><span class="hljs-title">ile</span>--&gt;</span>P<span class="hljs-function"><span class="hljs-title">references</span>--&gt;</span>S<span class="hljs-function"><span class="hljs-title">ettings</span>--&gt;</span>E<span class="hljs-function"><span class="hljs-title">xtensions</span>--&gt;</span>P<span class="hljs-function"><span class="hljs-title">ython</span>--&gt;</span>setting.json 添加下面的 Python 路径<br><span class="hljs-string">&quot;python.pythonPath&quot;</span> :<span class="hljs-string">&quot;XX:\\anaconda3\\envs\\（你的虚拟环境名称）\\python.exe&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/images/vscodepython.assets/image-20230119154730024.png" alt="image-20230119154730024" style="zoom:50%;"></p>]]></content>
    
    
    <categories>
      
      <category>tool</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode配置C++环境</title>
    <link href="/2023/01/14/vscodecplusplus/"/>
    <url>/2023/01/14/vscodecplusplus/</url>
    
    <content type="html"><![CDATA[<h4 id="step-1"><a href="#step-1" class="headerlink" title="step 1"></a>step 1</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">下载vscode https:<span class="hljs-regexp">//</span>code.visualstudio.com/Download<span class="hljs-comment">#</span><br>安装插件：<br>chinese<br>c++<br>code<br>下载mingw-w64 https:<span class="hljs-regexp">//</span>sourceforge.net<span class="hljs-regexp">/projects/mi</span>ngw-w64<span class="hljs-regexp">/files/</span><br>（选择x86_64-posix-seh）<br>E:\mingw64\bin 添加到环境变量 Path<br></code></pre></td></tr></table></figure><h4 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js">配置launch.json 和task.json<br>&#123;<br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.2.0&quot;</span>,<br>    <span class="hljs-string">&quot;configurations&quot;</span>: [<br>        &#123;<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;(gdb) Launch&quot;</span>,<span class="hljs-comment">// 配置名称，将会在启动配置的下拉菜单中显示</span><br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;cppdbg&quot;</span>, <span class="hljs-comment">// 配置类型，这里只能为cppdbg</span><br>            <span class="hljs-string">&quot;request&quot;</span>: <span class="hljs-string">&quot;launch&quot;</span>,<span class="hljs-comment">// 请求配置类型，可以为launch（启动）或attach（附加）</span><br>            <span class="hljs-string">&quot;program&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceRoot&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>,<span class="hljs-comment">// 将要进行调试的程序的路径</span><br>            <span class="hljs-string">&quot;args&quot;</span>: [],<span class="hljs-comment">// 程序调试时传递给程序的命令行参数，一般设为空即可</span><br>            <span class="hljs-string">&quot;stopAtEntry&quot;</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 设为true时程序将暂停在程序入口处，一般设置为false</span><br>            <span class="hljs-string">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceRoot&#125;&quot;</span>,<span class="hljs-comment">// 调试程序时的工作目录，一般为$&#123;workspaceRoot&#125;即代码所在目录</span><br>            <span class="hljs-string">&quot;environment&quot;</span>: [],<br>            <span class="hljs-string">&quot;externalConsole&quot;</span>: <span class="hljs-literal">true</span>,<span class="hljs-comment">// 调试时是否显示控制台窗口，一般设置为true显示控制台</span><br>            <span class="hljs-string">&quot;MIMode&quot;</span>: <span class="hljs-string">&quot;gdb&quot;</span>,<br>            <span class="hljs-string">&quot;miDebuggerPath&quot;</span>: <span class="hljs-string">&quot;C:\\MinGW\\bin\\gdb.exe&quot;</span>,<span class="hljs-comment">// miDebugger的路径，注意这里要与MinGw的路径对应</span><br>            <span class="hljs-string">&quot;preLaunchTask&quot;</span>: <span class="hljs-string">&quot;g++&quot;</span>,<span class="hljs-comment">// 调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc</span><br>            <span class="hljs-string">&quot;setupCommands&quot;</span>: [<br>                &#123;<br>                    <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;Enable pretty-printing for gdb&quot;</span>,<br>                    <span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span>,<br>                    <span class="hljs-string">&quot;ignoreFailures&quot;</span>: <span class="hljs-literal">true</span><br>                &#125;<br>            ]<br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br><span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;2.0.0&quot;</span>,<br><span class="hljs-string">&quot;tasks&quot;</span>: [<br>&#123;<br><span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br><span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;task g++&quot;</span>,<br><span class="hljs-string">&quot;command&quot;</span>: <span class="hljs-string">&quot;D:\\mingw64\\bin\\g++.exe&quot;</span>,<br><span class="hljs-string">&quot;args&quot;</span>: [<br><span class="hljs-string">&quot;-g&quot;</span>,<span class="hljs-comment">//g++ -g</span><br><span class="hljs-string">&quot;$&#123;file&#125;&quot;</span>,<span class="hljs-comment">//g++ -g main.cpp</span><br><span class="hljs-string">&quot;-o&quot;</span>,<span class="hljs-comment">//g++ -g main.cpp -o</span><br><span class="hljs-string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="hljs-comment">//g++ -g main.cpp -o main.exe</span><br>],<br><span class="hljs-string">&quot;options&quot;</span>: &#123;<br><span class="hljs-string">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><br>&#125;,<br><span class="hljs-string">&quot;problemMatcher&quot;</span>: [<br><span class="hljs-string">&quot;$gcc&quot;</span><br>],<br><span class="hljs-string">&quot;group&quot;</span>: &#123;<br><span class="hljs-string">&quot;kind&quot;</span>: <span class="hljs-string">&quot;build&quot;</span>,<br><span class="hljs-string">&quot;isDefault&quot;</span>: <span class="hljs-literal">true</span><br>&#125;,<br><span class="hljs-string">&quot;presentation&quot;</span>: &#123;<br><span class="hljs-string">&quot;panel&quot;</span>: <span class="hljs-string">&quot;shared&quot;</span><br>&#125;<br><br><br>&#125;<br>]<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">配置includer,自己选择之前编译器的安装路径<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>tool</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>papers</title>
    <link href="/2023/01/14/papers/"/>
    <url>/2023/01/14/papers/</url>
    
    <content type="html"><![CDATA[<hr><ul><li><p>[ ] Age-Critical and Secure Blockchain Sharding Scheme for Satellite-Based Internet of Things</p><p> 面向卫星物联网的关键年龄安全区块链分片方案</p></li><li><p>[ ] An improved algorithm for practical byzantine fault tolerance to large-scale consortium chain</p><p>面向大规模联盟链的实用拜占庭容错改进算法</p></li><li><p>[x] Authenticated Keyword Search in Scalable Hybrid-Storage Blockchains</p><p>可扩展混合存储区块链中的认证关键字搜索</p></li><li><p>[ ] Authenticating Aggregate Queries over Set-Valued Data with Confidentiality</p><p>对Set - value数据上的聚集查询进行机密性认证</p></li><li><p>[x] BAASH: Lightweight, Efficient, and Reliable Blockchain-As-A-Service for HPC Systems</p><p>Baash：面向Hpc系统的轻量、高效、可靠的Blockchain - As - A -服务</p></li><li><p>[x] Blockchain Based Decentralized Replay Attack Detection for Large Scale Power Systems</p><p>基于区块链的大规模电力系统去中心化重放攻击检测</p></li><li><p>[x] BLOCKCHAINS VS. DISTRIBUTED DATABASES: DICHOTOMY AND FUSION</p><p>区块链VS .分布式数据库：二分法和融合法</p></li><li><p>[x] Blurring the Lines between Blockchains and Database Systems: the Case of Hyperledger Fabric</p><p>区块链与数据库系统之间的界限模糊：Hyperledger Fabric案例</p></li><li><p>[x] Building High Throughput Permissioned Blockchain Fabrics: Challenges and Opportunities</p><p>构建高吞吐量的许可区块链架构：挑战与机遇</p></li><li><p>[ ] CHChain: Secure and parallel crowdsourcing driven by hybrid blockchain</p><p>CHChain：混合区块链驱动的安全并行众包</p></li><li><p>[ ] CloudChain: A Cloud Blockchain Using Shared Memory Consensus and RDMA</p><p>云链：使用共享内存共识和Rdma的云区块链</p></li><li><p>[ ] Coding for Scalable Blockchains via Dynamic Distributed Storage</p><p>通过动态分布式存储对可扩展区块链进行编码</p></li><li><p>[ ] Cumulus: A Secure BFT-based Sidechain for Off-chain Scaling</p><p>Cumulus：一种安全的基于Bft的侧链用于链外缩放</p></li><li><p>[x] DCert: Towards Secure, Efficient, and Versatile Blockchain Light Clients</p><p>Dcert：迈向安全、高效、多功能的区块链轻客户端</p></li><li><p>[x] Hawk: The Blockchain Model of Cryptography and Privacy-Preserving Smart Contracts</p><p>Hawk：密码学和隐私保护智能合约的区块链模型</p></li><li><p>[ ] Kauri: Scalable BFT Consensus with Pipelined Tree-Based Dissemination and Aggregation</p><p>Kauri：基于流水线树传播和聚合的可扩展Bft共识</p></li><li><p>[x] MITOSIS: Practically Scaling Permissioned Blockchains</p><p>Mitosis：实际可伸缩的许可区块链</p></li><li><p>[ ] MVCom: Scheduling Most Valuable Committees for the Large-Scale Sharded Blockchain</p><p>Mvcom：为大规模分片的区块链调度最有价值的委员会</p></li><li><p>[x] Occam: A Secure and Adaptive Scaling Scheme for Permissionless Blockchain</p><p>Occam：一种针对无许可区块链的安全自适应扩展方案</p></li><li><p>[x] Permissioned Blockchains: Properties, Techniques and Applications</p><p>许可区块链：属性、技术与应用</p></li><li><p>[x] Plumo: An Ultralight Blockchain Client</p><p>Plumo：超轻区块链客户端</p></li><li><p>[ ] Practical Smart Contract Sharding with Ownership and Commutativity Analysis</p><p>实用智能合约分拆与所有权和交换性分析</p></li><li><p>[ ] PriBank: Confidential Blockchain Scaling Using Short Commit-and-Proof NIZK Argument</p><p>Pribank：使用短提交和证明Nizk参数的机密区块链扩展</p></li><li><p>[ ] Pyramid: A Layered Sharding Blockchain System</p><p>金字塔：一种分层的Sharding区块链系统</p></li><li><p>[ ] Qanaat: A Scalable Multi-Enterprise Permissioned Blockchain System with Confidentiality Guarantees</p><p>Qanaat：具有机密性保证的可扩展多企业授权区块链系统</p></li><li><p>[x] Red Belly: A Secure, Fair and Scalable Open Blockchain</p><p>红肚皮：一个安全、公平、可扩展的开放区块链</p></li><li><p>[ ] Scaling Blockchains Using Pipelined Execution and Sparse Peers</p><p>使用Pipelined执行和稀疏节点对区块链进行扩展</p></li><li><p>[ ] Scaling Blockchains Without Giving up Decentralization and Security</p><p>在不放弃去中心化和安全性的前提下扩展区块链</p></li><li><p>[ ] Scaling Membership of Byzantine Consensus</p><p>拜占庭共识成员规模</p></li><li><p>[ ] Scaling the Blockchain-based Access Control Framework for IoT via Sharding</p><p>通过分片扩展基于区块链的物联网访问控制框架</p></li><li><p>[x] SChain: A Scalable Consortium Blockchain Exploiting Intra- and Inter-Block Concurrency</p><p>Schain：利用块内和块间并发的可扩展联盟区块链</p></li><li><p>[ ] Sharding for Blockchain based Mobile Edge Computing System: A Deep Reinforcement Learning Approach</p><p>基于区块链的移动边缘计算系统的切分：一种深度强化学习方法</p></li><li><p>[ ] Sharding Techniques in the Era of Blockchain</p><p>区块链时代的分片技术</p></li><li><p>[x] Scaling Blockchain via Layered Sharding</p><p> <a href="https://ieeexplore.ieee.org/abstract/document/9926060">https://ieeexplore.ieee.org/abstract/document/9926060</a></p></li><li><p>[x] SlimChain: Scaling Blockchain Transactions through Off-Chain Storage and Parallel Processing</p><p>Slimchain：通过链外存储和并行处理实现区块链交易的规模化</p></li><li><p>[ ] The design, architecture and performance of the Tendermint Blockchain Network</p><p>腾德明区块链网络的设计、架构和性能</p></li><li><p>[ ] Toward Next Generation of Blockchain Using Improvized Bitcoin-NG</p><p>面向下一代区块链的即兴比特币</p></li><li><p>[ ] Towards a Blockchain Database for Massive IoT Workloads</p><p>面向海量物联网工作负载的区块链数据库</p></li><li><p>[ ] Towards a Scalable and Trustworthy Blockchain: IoT Use Case</p><p>迈向可扩展和可信的区块链：物联网用例</p></li><li><p>[x] TrustChain: A Sybil-resistant scalable blockchain</p><p>TrustChain：一种抗Sybil攻击的可扩展区块链</p></li><li><p>[ ] Vericom: A Verification and Communication Architecture for IoT-based Blockchain</p><p>Vericom：一种面向物联网区块链的验证和通信架构</p></li><li><p>[ ] NeuChain: A Fast Permissioned Blockchain System with Deterministic Ordering(slimchain方向类似)</p></li></ul><ul><li>[ ] Untangling Blockchain: A Data Processing View of Blockchain Systems</li><li>[x] Off-chaining Models and Approaches to Off-chain Computations（链下执行系统模型设计）</li><li>[ ] TEE+区块链应用：Extending On-chain Trust to Off-chain Trustworthy Blockchain Data Collection using Trusted Execution Environment (TEE)</li><li>[x] Giving State to the Stateless: Augmenting Trustworthy Computation with Ledgers</li><li>[ ] Challenges for Combining Smart Contracts with Trusted Computing</li><li>[ ] SoK: TEE-assisted Confidential Smart Contract.</li><li>[ ] Understanding Ethereum via Graph Analysis</li><li>[ ] <strong>HyperMaze: Towards Privacy-Preserving and Scalable Permissioned Blockchain</strong></li><li>[ ] 边缘计算+外包计算 Blockchain for achieving accountable outsourcing computations in edge computing  <a href="https://www.sciencedirect.com/science/article/pii/S0140366422004807">https://www.sciencedirect.com/science/article/pii/S0140366422004807</a></li><li>[ ] 2023CCFA通道技术 Transaction transmission model for blockchain channels based on non-cooperative games</li><li>[ ] <a href="https://www.jianshu.com/p/23ad9d1b2853">IoT security: Review, blockchain solutions, and open challenges</a></li><li>[ ] Blockchain at the edge: performance of resource-constrained IoT networks</li><li>[ ] Password-Authenticated Decentralized Identities</li><li>[ ]  <a href="https://scholars.hkbu.edu.hk/ws/portalfiles/portal/72274038/G23THFL-023762T.pdf">Towards Secure, Efficient and Versatile Blockchain Light Clients</a></li><li>[ ]  IOTA</li><li>[ ]  Ghostor: Toward a Secure Data-Sharing System from Decentralized Trust Ghostor：从去中心化信任走向安全数据共享系统</li><li>[ ]  MAGE: Mutual Attestation for a Group of Enclaves without Trusted Third Parties</li><li>[ ]  L2chain: Towards High-performance, Confidential and Secure Layer-2 Blockchain Solution for Decentralized Applications</li><li>[ ]  Town Crier: An authenticated data feed for smart contracts(数据馈送系统)</li><li>[ ]  <a href="https://www.sciencedirect.com/science/article/pii/S0167739X22003326">TEBDS: A Trusted Execution Environment-and-Blockchain-supported IoT data sharing system</a></li><li>[ ]  <a href="https://link.springer.com/chapter/10.1007/978-3-031-30637-2_33">Efficient Execution of Blockchain Transactions Through Deterministic Concurrency Control</a><strong>CCFB 确定性排序 2023</strong></li><li>[x]  L2DART: A Trust Management System Integrating Blockchain and Off-Chain Computation</li><li>[x]  MeHLDT: A multielement hash lock data transfer mechanism for on‑chain and off‑chain</li></ul><p>待看论文</p><ul><li>[ ] Scaling Blockchain Consensus via a Robust Shared Mempool</li><li>[ ] <a href="https://ietresearch.onlinelibrary.wiley.com/doi/abs/10.1049/ise2.12124">Solving blockchain trilemma using off‐chain storage protocol</a>(双链？)</li><li>[ ] An Overview of Blockchain Scalability for Storage</li><li>[ ] <a href="https://link.springer.com/article/10.1007/s12083-023-01491-z">MeHLDT: A multielement hash lock data transfer mechanism for on-chain and off-chain</a></li></ul><ul><li>[ ] Scaling Blockchains Using Pipelined Execution and Sparse Peers</li><li>[ ] SChain: Scalable Concurrency over Flexible Permissioned Blockchain（2023）</li><li>[ ] （看）GriDB: Scaling Blockchain Database via Sharding and Off-Chain Cross-Shard Mechanism（vldb2023）</li><li>[ ] CanDID: Can-Do Decentralized Identity with Legacy Compatibility, Sybil-Resistance,and Accountability <a href="https://mp.weixin.qq.com/s/N_OIGgC4t1T1JZf4fImxlw">https://mp.weixin.qq.com/s/N_OIGgC4t1T1JZf4fImxlw</a></li><li><p>[ ] ZeeStar: Private Smart Contracts by Homomorphic Encryption and Zero-knowledge Proofs <a href="https://mp.weixin.qq.com/s/nSv8l-jNFAsjMlLkoLaRvw">https://mp.weixin.qq.com/s/nSv8l-jNFAsjMlLkoLaRvw</a></p><p>DID <a href="https://mp.weixin.qq.com/s/SeJqlDuFdDrIrnJM0Z9WCw">https://mp.weixin.qq.com/s/SeJqlDuFdDrIrnJM0Z9WCw</a></p></li><li><p>[ ] 匿名身份zk-creds: Flexible Anonymous Credentials from zkSNARKs and Existing Identity Infrastructure</p></li><li>[ ] （看）<a href="https://ietresearch.onlinelibrary.wiley.com/doi/abs/10.1049/ise2.12124">Solving blockchain trilemma using off‐chain storage protocol</a></li></ul><p>向量承诺</p><ul><li>[ ] Succinct Vector, Polynomial, and Functional Commitments from Lattices</li><li>[ ] Aggregatable Subvector Commitments for Stateless Cryptocurrencies</li><li>[ ] Pointproofs: Aggregating Proofs for Multiple Vector Commitments</li></ul><p>研究账本和TEE混合协议设计的论文：</p><ul><li>[x] PISTIS: Issuing Trusted and Authorized Certificates With Distributed Ledger and TEE</li></ul><p>隐私智能合约：</p><ul><li>[x] Giving state to the stateless: Augmenting trustworthy computation with ledgers</li></ul><p>2022区块链论文分析：</p><p>区块链轻客户端设计学习链上状态转移：</p><ul><li>[ ] Towards Privacy-assured and Lightweight On-chain Auditing of Decentralized Storage</li></ul><p><a href="http://xintelligence.pro/archives/898">http://xintelligence.pro/archives/898</a></p><p>零知识</p><p>Concise Mercurial Vector Commitments and Independent Zero-Knowledge Sets with Short Proofs.</p><p>Zero-knowledge sets with short proofs.</p><p>Universal Accumulators with Efficient Nonmembership Proofs</p><p><a href="https://zhuanlan.zhihu.com/p/148920420">https://zhuanlan.zhihu.com/p/148920420</a></p><p>Batching Techniques for Accumulators with Applications to IOPs and Stateless Blockchains</p><h2 id="各个研究领域适合投稿的A类会议总结"><a href="#各个研究领域适合投稿的A类会议总结" class="headerlink" title="各个研究领域适合投稿的A类会议总结"></a>各个研究领域适合投稿的A类会议总结</h2><ul><li>\1. “智能合约”方向接收论文较多的A类会议为：ISSTA、CCS</li><li>\2. “区块链性能优化”方向接收论文较多的A/B类会议为：INFOCOM、CCS、NDSS</li><li>\3. “区块链分析”方向接收论文较多的A/B类会议为：CCS、ICDCS</li><li>\4. “区块链安全”方向接收论文较多的A类会议为：ICDE、S&amp;P</li><li>\5. “区块链应用”方向接收论文在A类会议接收较少，分布比较零散</li><li>\6. “共识协议”方向接收论文较多的A类会议为：CCS、S&amp;P</li></ul><h4 id="layer2-方向投稿会议-期刊总结"><a href="#layer2-方向投稿会议-期刊总结" class="headerlink" title="layer2 方向投稿会议/期刊总结"></a>layer2 方向投稿会议/期刊总结</h4><h4 id="USENIX-Security"><a href="#USENIX-Security" class="headerlink" title="USENIX Security"></a>USENIX Security</h4><blockquote><p> Das P, Eckey L, Frassetto T, et al. {FastKitten}: Practical smart contracts on bitcoin[C]//28th USENIX Security Symposium (USENIX Security 19). 2019: 801-818.</p><p>Kalodner H, Goldfeder S, Chen X, et al. Arbitrum: Scalable, private smart contracts[C]//27th USENIX Security Symposium (USENIX Security 18). 2018: 1353-1370.</p></blockquote><h4 id="NDSS"><a href="#NDSS" class="headerlink" title="NDSS"></a>NDSS</h4><blockquote><p> Frassetto T, Jauernig P, Koisser D, et al. POSE: Practical off-chain smart contract execution[J]. arXiv preprint arXiv:2210.07110, 2022.</p><p>Kaptchuk G, Miers I, Green M. Giving state to the stateless: Augmenting trustworthy computation with ledgers[J]. Cryptology ePrint Archive, 2017.</p></blockquote><h4 id="ACM-SIGSAC"><a href="#ACM-SIGSAC" class="headerlink" title="ACM SIGSAC"></a>ACM SIGSAC</h4><blockquote><p>Wüst K, Matetic S, Egli S, et al. ACE: Asynchronous and concurrent execution of complex smart contracts[C]//Proceedings of the 2020 ACM SIGSAC Conference on Computer and Communications Security. 2020: 587-600.</p></blockquote><h4 id="Euro-S-amp-P"><a href="#Euro-S-amp-P" class="headerlink" title="Euro S&amp;P"></a>Euro S&amp;P</h4><blockquote><p>Cheng R, Zhang F, Kos J, et al. Ekiden: A platform for confidentiality-preserving, trustworthy, and performant smart contracts[C]//2019 IEEE European Symposium on Security and Privacy (EuroS&amp;P). IEEE, 2019: 185-200.</p></blockquote><h4 id="VLDB"><a href="#VLDB" class="headerlink" title="VLDB"></a>VLDB</h4><blockquote><p>Xu C, Zhang C, Xu J, et al. SlimChain: Scaling blockchain transactions through off-chain storage and parallel processing[J]. Proceedings of the VLDB Endowment, 2021, 14(11): 2314-2326.</p><p>Xu Z, Chen L. L2chain: Towards High-performance, Confidential and Secure Layer-2 Blockchain Solution for Decentralized Applications[J]. Proceedings of the VLDB Endowment, 2022, 16(4): 986-999.</p></blockquote><h4 id="TIFS"><a href="#TIFS" class="headerlink" title="TIFS"></a>TIFS</h4><blockquote><p>Wang L, Guan Z, Chen Z, et al. sChain: An Efficient and Secure Solution for Improving Blockchain Storage[J]. IEEE Transactions on Information Forensics and Security, 2023.</p></blockquote><h4 id="ACM-IFIP"><a href="#ACM-IFIP" class="headerlink" title="ACM/IFIP"></a>ACM/IFIP</h4><blockquote><p>Ji Y, Xu C, Zhang C, et al. DCert: towards secure, efficient, and versatile blockchain light clients[C]//Proceedings of the 23rd ACM/IFIP International Middleware Conference. 2022: 269-280.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>blockchain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hawk</title>
    <link href="/2023/01/13/Hawk/"/>
    <url>/2023/01/13/Hawk/</url>
    
    <content type="html"><![CDATA[<h2 id="【SP-2016】Hawk：The-Blockchain-Model-of-Cryptography-and-Privacy-Preserving-Smart-Contracts密码学和隐私保护智能合约的区块链模型"><a href="#【SP-2016】Hawk：The-Blockchain-Model-of-Cryptography-and-Privacy-Preserving-Smart-Contracts密码学和隐私保护智能合约的区块链模型" class="headerlink" title="【SP 2016】Hawk：The Blockchain Model of Cryptography and Privacy-Preserving Smart Contracts密码学和隐私保护智能合约的区块链模型"></a>【SP 2016】Hawk：The Blockchain Model of Cryptography and Privacy-Preserving Smart Contracts密码学和隐私保护智能合约的区块链模型</h2><h4 id="论文创新点总结"><a href="#论文创新点总结" class="headerlink" title="论文创新点总结"></a>论文创新点总结</h4><blockquote><p>1.提出去中心化智能合约系统Hawk，交易信息不明文存储，程序员可编写私有智能合约，编译器自动生成密码协议。<br>2.正式提出区块链密码学模型。被广泛接受。</p></blockquote><h4 id="motivation"><a href="#motivation" class="headerlink" title="motivation"></a>motivation</h4><blockquote><ol><li>现有区块链忽视了交易隐私性，虽然有假名，但可以被统计分析攻击</li><li>Zerocash 和其他一些等隐私保护的加密货币的设计方面已经取得了进展，但是这些系统放弃了可编程性。</li></ol></blockquote><p>Hawk</p><blockquote><p>Hawk，一个隐私保护智能合约的框架。</p><p>Main idea: Use Zero-knowledge Proofs(ZKP)</p><p>Prove statements about a ciphertext without revealing information about the plaintext</p></blockquote><p><img src="/images/Hawk.assets/image-20230113105305465.png" alt="image-20230113105305465" style="zoom:50%;"></p><p>对等网络提供了一种更通用的接口，不仅仅是虚拟银行，而是一种虚拟通用信计算机，可以运行任何用户定义的程序，这些程序可以和金钱交互，也可也查找数据等。</p><p>区块链不能提供隐私</p><p><img src="/images/Hawk.assets/image-20230114101401521.png" alt="image-20230114101401521"></p><p>分享：</p><p><a href="https://mp.weixin.qq.com/s/kaDUSz6rF1hQUCAGY0e_jw">https://mp.weixin.qq.com/s/kaDUSz6rF1hQUCAGY0e_jw</a></p><p><a href="https://mp.weixin.qq.com/s/dEFfybyUG7s9i2OAJdKH7A">https://mp.weixin.qq.com/s/dEFfybyUG7s9i2OAJdKH7A</a></p><blockquote><p>货币支付的逻辑是简单且固定的，而具有general-purpose的智能合约的逻辑是图灵完备的，因此，其逻辑将不再是固定的。智能合约本质上是链上的代码，对于一个智能合约func(input), 大伙儿/不同的矿工都执行一遍该代码，对比给定的结果和本地输出的结果，如果一样，就accept该智能合约相关的交易。该过程本质上是为了“计算完整性 Integrity of computing”， 能够保证该程序执行结果的一致性，从而解决不同parties之间的trust问题。</p><p>Hawk尝试解决这个问题。at a high-level view，它在Zerocash的基础之上引入了一个Manager，再结合zk-SNARKs来实现。该manager充当半个trusted third party的角色。</p></blockquote><p>其他论文对其评价：</p><p>1.来自Arbitrum: Scalable, private smart contracts</p><blockquote><p>Hawk [18] is a proposed system for private smart contracts using zkSNARKs [16, 27].</p><p>Hawk [18] 是一个使用 zkSNARKs [16, 27] 的私有智能合约系统。</p><p>Hawk does not improve scalability as each contract requires kilobytes of data to be put on-chain.</p><p>Hawk 不会提高可扩展性，因为每个合约都需要将千字节的数据放在链上。</p></blockquote><p>2.来自fastkitten</p><blockquote><p>None of the solutions discussed above achieves privacy preserving off-chain contract execution. This is tackled by the work Hawk [36] which keeps the state, all inputs and all outputs private. Hawk contracts [35] achieve these properties using Ethereum smart contracts that judge computations done by a third party (a manager), who executes the contract on private inputs and is trusted not to reveal any secrets. First all parties submit their encrypted inputs to the contract, then the manager computes the result and proves its correctness with a zero knowledge proof. If the proof is correct, the contract pays out money accordingly. While the authors of Hawk discuss the possibility to use SGX for instantiating the manager and reducing the trust assumptions in this party, it still leverages the blockchain for every user input, and it only supports single round protocols which is their main difference to FASTKITTEN. A possible extension to multi-round protocols would be difficult to achieve without letting the smart contract verify the correctness of every round individually, and thus create a large blockchain communication overhead.</p><p>上面讨论的解决方案都没有实现保护隐私的链下合约执行。 Hawk [36] 解决了这个问题，它使状态、所有输入和所有输出保持私有。 Hawk 合同 [35] 使用以太坊智能合同实现这些属性，该合同判断第三方（经理）所做的计算，第三方根据私人输入执行合同，并且被信任不会泄露任何秘密。首先各方将他们的加密输入提交给合约，然后管理者计算结果并用零知识证明证明其正确性。如果证明是正确的，合同就会相应地支付款项。虽然 Hawk 的作者讨论了使用 SGX 来实例化管理器并减少这一方的信任假设的可能性，但它仍然为每个用户输入利用区块链，并且它仅支持单轮协议，这是它们与 FASTKITTEN 的主要区别。如果不让智能合约单独验证每一轮的正确性，将很难实现对多轮协议的可能扩展，从而产生大量的区块链通信开销。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>blockchain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hybrid-Storage</title>
    <link href="/2023/01/11/Hybrid-Storage/"/>
    <url>/2023/01/11/Hybrid-Storage/</url>
    
    <content type="html"><![CDATA[<h4 id="混合存储区块链"><a href="#混合存储区块链" class="headerlink" title="混合存储区块链"></a>混合存储区块链</h4><blockquote><p>原始数据被发送到链外存储服务提供商( SP )进行管理，而其密文散列存储在链上以维护数据完整性。</p><p>让智能合约和链外SP都维护一个经过认证的数据结构( ADS )。对于每个查询，SP不仅计算查询结果，还计算一个称为验证对象( Validation Object，VO )的加密证明来证明这些结果。通过SP的VO和从区块链中检索的认证信息，客户端可以验证结果完整性。</p></blockquote><p><img src="/images/Hybrid-Storage.assets/image-20230111110926118.png" alt="image-20230111110926118"></p><p>paper:<a href="https://xuc.me/file/paper/ICDE21.pdf">https://xuc.me/file/paper/ICDE21.pdf</a></p><p>分享：<a href="https://mp.weixin.qq.com/s/VabVyzTpBpMH9eRm4sLMFw">https://mp.weixin.qq.com/s/VabVyzTpBpMH9eRm4sLMFw</a></p><p><a href="https://xuc.me/file/slides/ICDE21.pdf">https://xuc.me/file/slides/ICDE21.pdf</a></p>]]></content>
    
    
    <categories>
      
      <category>blockchain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fabric++</title>
    <link href="/2023/01/10/fabricplusplus/"/>
    <url>/2023/01/10/fabricplusplus/</url>
    
    <content type="html"><![CDATA[<h4 id="论文阅读-SIGMOD-’19-Blurring-the-Lines-between-Blockchains-and-Database-Systems-the-Case-of-Hyperledger-Fabric"><a href="#论文阅读-SIGMOD-’19-Blurring-the-Lines-between-Blockchains-and-Database-Systems-the-Case-of-Hyperledger-Fabric" class="headerlink" title="[论文阅读] (SIGMOD ’19)Blurring the Lines between Blockchains and Database Systems: the Case of Hyperledger Fabric"></a>[论文阅读] (SIGMOD ’19)Blurring the Lines between Blockchains and Database Systems: the Case of Hyperledger Fabric</h4><blockquote><p>对fabric事务排序进行改进，提供性能，提出fabric++，主要用来理解fabric</p></blockquote><p>比特币、以太坊都遵循order-execute 模式</p><blockquote><p>在排序阶段，所有节点首先就全局交易订单达成一致，通常使用共识机制。然后，每个对等点在本地的状态的副本上按该顺序进行交易执行。虽然这种方法很简单，但它有两个严重的缺点：首先，事务的执行是按顺序进行的。其次，由于每个交易都必须在每个节点上执行，系统的性能不会随着节点数量的增加而增加（<strong>不可扩展</strong>）。当然，并行执行和扩展能力多年来一直是分布式数据库系统公认的特性。</p></blockquote><p>fabric 采用 simulate-order-validate-commit 模式</p><blockquote><p>该模型在很大程度上受到数据库系统中的乐观并发控制机制的影响：事务在实际排序之前被推测性地并行模拟。并行交易执行，因此具有扩展能力(<strong>可扩展性</strong>)</p></blockquote><h4 id="fabric-架构"><a href="#fabric-架构" class="headerlink" title="fabric 架构"></a>fabric 架构</h4><p><img src="/images/fabricplusplus.assets/image-20230110120459044.png" alt="image-20230110120459044" style="zoom:50%;"></p><blockquote><p><code>peers</code>被分组到托管它们的<code>组织</code>中。<br>在一个组织内，所有<code>peer</code>都相互信任。每个对等点都运行一个 Fabric 的本地实例。此实例包括分类账的副本，其中包含通过系统的所有交易的有序序列（包括有效和无效交易）。除了账本之外，每个<code>peer</code>还包含状态数据库形式的<code>current state</code>，它表示将账本中的所有有效交易应用到初始状态后的状态。除了在模拟阶段和验证阶段都发挥重要作用的对等点之外，还有一个称为ordering service排序服务的单独实例，它是排序阶段的核心组件，并被认为是可信的。</p></blockquote><h5 id="模拟阶段。"><a href="#模拟阶段。" class="headerlink" title="模拟阶段。"></a>模拟阶段。</h5><p>在模拟阶段，客户端向一些背书节点（peer节点的子集）提交交易提议以进行模拟。向哪些背书节点提交由<code>背书策略</code>中定义。由于组织之间并不完全信任，因此通常会指定每个相关组织的至少一个<code>peer</code>必须模拟交易提议。背书者现在针对当前状态的本地副本<strong>并行</strong>模拟交易提案。每个背书者在模拟期间建立一个<code>读取集</code>和一个<code>写入集</code>。模拟后，每个背书者将其读写集返回给客户端。除此之外，背书人还返回一个关于集合的加密签名。如果返回的所有<code>读写集</code>都相等，则客户端形成一个实际的事务。它包含先前计算的读取集和写入集以及所有签名。然后客户端将此交易传递给排序服务。</p><h5 id="排序阶段。"><a href="#排序阶段。" class="headerlink" title="排序阶段。"></a>排序阶段。</h5><p>在排序阶段，受信任的排序服务接收来自客户的交易。在所有收到的交易中，它建立一个全局秩序，并将它们打包成包含一定数量交易的区块。默认情况下，事务基本上按照它们到达服务的方式排序，而不以任何方式检查事务语义。然后排序服务将每个形成的块分发给网络的所有<code>peer</code>。请注意，系统不保证所有节点同时收到一个块。但是，它保证所有对等点都以相同的顺序接收相同的块。</p><h5 id="验证阶段。"><a href="#验证阶段。" class="headerlink" title="验证阶段。"></a>验证阶段。</h5><p>当一个块到达一个节点时，它的验证阶段就开始了。对于块内的每个事务，验证包括两个检查：首先，Fabric测试事务是否遵守背书策略，以及是否所有事务都包含对读写集的签名。如果情况并非如此，则意味着client或背书节点以某种方式篡改了交易。在这种情况下，系统将交易标记为无效。如果一个事务通过了第一个测试，Fabric会进行第二个测试，检查是否出现序列化条件。由于交易模拟在对交易进行排序之前是并行进行的，因此模拟的效果可能与既定顺序相冲突。因此，Fabric也将与先前交易冲突的交易标记为无效交易。</p><h5 id="提交阶段。"><a href="#提交阶段。" class="headerlink" title="提交阶段。"></a>提交阶段。</h5><p>在提交阶段，每个节点将包含有效和无效事务的块追加到其本地账本中。此外，每个节点将有效事务所做的所有更改应用于其当前状态。（即修改写入本地数据库）</p><p>总结：Fabric 不用在每个节点重复执行操作，而是通过读写集直接修改世界状态。</p><p><a href="https://mp.weixin.qq.com/s/xL8LwWigbFd2UDs8Q2p9Wg">https://mp.weixin.qq.com/s/xL8LwWigbFd2UDs8Q2p9Wg</a></p>]]></content>
    
    
    <categories>
      
      <category>blockchain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DCert Towards Secure, Efficient, and Versatile Blockchain Light Clients</title>
    <link href="/2023/01/04/Dcert/"/>
    <url>/2023/01/04/Dcert/</url>
    
    <content type="html"><![CDATA[<h4 id="论文阅读-DCert-towards-secure-efficient-and-versatile-blockchain-light-clients-DCert-迈向安全、高效、多功能区块链轻客户端"><a href="#论文阅读-DCert-towards-secure-efficient-and-versatile-blockchain-light-clients-DCert-迈向安全、高效、多功能区块链轻客户端" class="headerlink" title="[论文阅读] DCert: towards secure, efficient, and versatile blockchain light clients DCert:迈向安全、高效、多功能区块链轻客户端"></a>[论文阅读] DCert: towards secure, efficient, and versatile blockchain light clients DCert:迈向安全、高效、多功能区块链轻客户端</h4><blockquote><p>Ji Y, Xu C, Zhang C, et al. DCert: towards secure, efficient, and versatile blockchain light clients[C]//Proceedings of the 23rd conference on 23rd ACM/IFIP International Middleware Conference. 2022: 269-280.</p></blockquote><p>一种新的去中心化认证框架 DCert, 用安全证书轻松验证区块链完整性</p><p>motivation: 随着区块链的发展，用户查询区块链历史数据进行分析的需求增加。</p><p><strong>存在的问题</strong>：轻客户端想要查询区块链历史数据，要么就是在区块结构中事先加入某种查询信息，这种方式不适合现有的成熟的区块链系统，而且事先构建好的信息也就意味着只能按照某些固定的方式查询，不能随意灵活定制。</p><blockquote><p>It remains a challenge to design a verifiable query processing solution that supports efficient and versatile queries for light clients without modifying the underlying blockchains.如何在不修改底层区块链结构的情况下支持高效通用的可验证查询方法？</p></blockquote><h4 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h4><p><img src="/images/Dcert.assets/image-20230101111015313.png" alt="image-20230101111015313"></p><blockquote><p>CI : 有TEE的全节点，作用是1.验证区块链完整性; 2.验证认证索引(authenticated index)完整性（这个是为了验证查询结果）</p><p>SP : 在区块链数据上构建和维护验证索引(authenticated index),以便轻客户端能够灵活查询</p><p>Superlight Client : 与传统轻节点不同的是，超轻节点<strong>只保存</strong>和验证最后一个块以及这个块的证书；同时超轻节点能够灵活任意查询区块链数据</p></blockquote><ol><li><p>作为全节点，CI同步全局状态，并用SGX为构建证书做一些准备信息</p></li><li><p>接收到新block，调用SGX，为这个block构建<strong>证书</strong>以及与之关联的<strong>可验证索引</strong></p></li><li>构建好证书后，CI将证书广播给区块链网络</li><li>超轻节点用公开的证书即可验证区块链完整性和可验证索引完整性，查询同理</li></ol><h4 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h4><blockquote><p>1.证书构建过程全在SGX，开销太大，文章后续设计一些方案来优化证书构建算法</p></blockquote><h4 id="证书构建与验证过程"><a href="#证书构建与验证过程" class="headerlink" title="证书构建与验证过程"></a>证书构建与验证过程</h4><p><strong>问题所在</strong>：所以状态信息加载到飞地，然后更新当前块的状态并签名，但是完整的状态数据过大，飞地装不下</p><p><strong>解决方法</strong>：受无状态飞地设计启发</p><ul><li>[ ]  <a href="https://eprint.iacr.org/2017/201">(NDSS 2019)Giving State to the Stateless: Augmenting Trustworthy Computation with Ledgers.  </a></li></ul><p>在飞地外先执行部分证书构建程序。具体来说，飞地外部程序计算读写集合以及相应merkle proof，最后与上一个block以及它的证书一起送入飞地。飞地内部程序重新运行新交易，并验证签名后构建新证书。具体构建与验证算法文章中有详述。</p><p><img src="/images/Dcert.assets/image-20230106121655976.png" alt="image-20230106121655976" style="zoom: 40%;"> <img src="/images/Dcert.assets/image-20230106122543422.png" alt="image-20230106122543422" style="zoom:40%;"></p><h4 id="可验证查询"><a href="#可验证查询" class="headerlink" title="可验证查询"></a>可验证查询</h4><blockquote><p>SP 要在区块链数据上构建并维护可验证索引，然后向超轻节点提供查询结果和proof<br>支持任何可验证查询只要具有可认证查询处理算法<br>怎么说？</p></blockquote><h5 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h5><p>LineageChain、vChain、vChain+都是在区块链块头添加特殊设计的索引，才能支持历史查询或者其他查询，修改了底层区块链结构，Dcert不需要修改底层就能实现按需要查询。</p><p><img src="/images/Dcert.assets/image-20230107105652315.png" alt="image-20230107105652315"></p><blockquote><p>DCert does not integrate the authenticated indexes with the underlying blockchain structure.</p></blockquote><h5 id="Dcert做法"><a href="#Dcert做法" class="headerlink" title="Dcert做法"></a>Dcert做法</h5><p>让CI给超轻客户颁发证书以跟踪可认证索引的更新，SP可以提供查询服务。需要什么样的查询，就相应构建什么样的cert</p><blockquote><p>When needed, a new certificate 𝑐𝑒𝑟𝑡𝑖𝑑𝑥2 can be constructed by the enclave of the CI by signing the digest 𝐻𝑖𝑑𝑥2 of this authenticated index (shown in the rightlower part of Fig. 5)</p></blockquote><h5 id="Dcert的TEE环境可选"><a href="#Dcert的TEE环境可选" class="headerlink" title="Dcert的TEE环境可选"></a>Dcert的TEE环境可选</h5><blockquote><p>we note that the DCert can be deployed using any other TEE implementations such as ARM TrustZone, RISC-V MultiZone, and AMD Platform Security Processor.</p></blockquote><h4 id="Dcert-创新点总结"><a href="#Dcert-创新点总结" class="headerlink" title="Dcert 创新点总结"></a>Dcert 创新点总结</h4><blockquote><p>Different from all these prior works, our proposed DCert <strong>does not require modifying the underlying blockchain</strong> [24, 33] and is not confined to specific query types [13, 35, 36]. It can dynamically <strong>support new query types</strong> by constructing corresponding certificates of the indexes in an on-demand manner.</p><p>1.不修改区块链数据结构 2. 通过按需构建证书的方式支持任意查询</p></blockquote><h4 id="提及的重要资料"><a href="#提及的重要资料" class="headerlink" title="提及的重要资料"></a>提及的重要资料</h4><h5 id="1-谷歌区块链历史数据分析2018"><a href="#1-谷歌区块链历史数据分析2018" class="headerlink" title="1.谷歌区块链历史数据分析2018"></a>1.谷歌区块链历史数据分析2018</h5><p><a href="https://cloud.google.com/blog/topics/public-datasets/bitcoin-in-bigquery-blockchain-analytics-on-public-data">BigQuery 中的比特币：公共数据的区块链分析</a></p><h5 id="2-提供可验证查询的工作，但修改了底层区块链数据结构或者只支持特定类型查询"><a href="#2-提供可验证查询的工作，但修改了底层区块链数据结构或者只支持特定类型查询" class="headerlink" title="2.提供可验证查询的工作，但修改了底层区块链数据结构或者只支持特定类型查询"></a>2.提供可验证查询的工作，但修改了底层区块链数据结构或者只支持特定类型查询</h5><ul><li><p>[ ] <a href="https://dl.acm.org/doi/abs/10.14778/3329772.3329775">(PVLDB  2019) Fine-grained, secure and efficient data provenance on blockchain systems.区块链系统上细粒度、安全、高效的数据溯源</a></p><blockquote><p>设计一个经过认证的确定性跳转列表，并将该索引集成到链的每个块中</p></blockquote></li><li><p>[ ] <a href="https://ieeexplore.ieee.org/abstract/document/9835165/">(ICDE 2022) vChain+: Optimizing Verifiable Blockchain Boolean Range Queries. Vchain +：优化可验证区块链布尔范围查询</a> ==<a href="https://xuc.me/publication/icde22/vchain-plus/">作者同团队</a>==</p></li><li><p>[ ] <a href="https://dl.acm.org/doi/abs/10.1145/3299869.3300083">(ACM SIGMOD) vChain: Enabling Verifiable Boolean Range Queries over Blockchain Databases.Vchain：实现区块链数据库上的可验证布尔范围查询。</a>==作者同团队==</p><blockquote><p>vChain系列：将专门设计的认证索引的根摘要添加到块头中。</p></blockquote></li><li>[ ] <a href="https://xuc.me/publication/tkde/auth-aggregate-queries/">(TKDE 2018 )Authenticating Aggregate Queries over Set-Valued Data with Confidentiality. 对Set - value数据上的聚合查询进行机密性认证。</a>==作者同团队==</li><li>[ ] (INFOCOM 2018 )Searching an encrypted cloud meets blockchain: A decentralized, reliable and fair realization. </li><li>[ ] (ICDE 2021)Authenticated Keyword Search in Scalable Hybrid-Storage Blockchains.可扩展混合存储区块链中的认证关键字搜索。==作者同团队==<a href="https://mp.weixin.qq.com/s/VabVyzTpBpMH9eRm4sLMFw">https://mp.weixin.qq.com/s/VabVyzTpBpMH9eRm4sLMFw</a></li></ul><h5 id="3-MHT-区块链底层数据结构"><a href="#3-MHT-区块链底层数据结构" class="headerlink" title="3.MHT - 区块链底层数据结构"></a>3.MHT - 区块链底层数据结构</h5><p>为了支持区块链的查询，将其扩展到数据库索引中，用于构建可认证索引。例如</p><ul><li>[ ] MHT可以扩展到多叉Merkle B -树( MB-树)，它遵循B + 树结构，并为每个索引项增加相应的哈希<a href="https://dl.acm.org/doi/abs/10.1145/1142473.1142488">(2006 ACM SIGMOD)Dynamic authenticated index structures for outsourced databases.</a></li></ul><h5 id="4-SGX资料"><a href="#4-SGX资料" class="headerlink" title="4.SGX资料"></a>4.SGX资料</h5><p><a href="https://eprint.iacr.org/2016/086">Intel SGX explained</a><br><a href="https://eprint.iacr.org/2016/086.pdf">paper</a></p><h5 id="5-经典区块链威胁模型"><a href="#5-经典区块链威胁模型" class="headerlink" title="5.经典区块链威胁模型"></a>5.经典区块链威胁模型</h5><ul><li>[ ]  <a href="https://ieeexplore.ieee.org/abstract/document/7546538/">(SP 2016)Hawk: The Blockchain Model of Cryptography and Privacy-Preserving Smart Contracts Hawk：密码学与隐私保护智能合约的区块链模型。</a></li></ul><h5 id="6-用飞地做区块链隐私保护的工作"><a href="#6-用飞地做区块链隐私保护的工作" class="headerlink" title="6.用飞地做区块链隐私保护的工作"></a>6.用飞地做区块链隐私保护的工作</h5><ul><li><p>[ ] (CCS 2019)Tesseract: Real-time cryptocurrency exchange using trusted hardware超正方体：使用可信硬件的实时加密货币交换</p></li><li><p>[ ] (<em>Euro</em>S&amp;P 2019)Ekiden: A platform for confidentiality-preserving, trustworthy, and performant smart contracts.Ekiden：一个保密性、可信任、可履约的智能合约平台。</p><blockquote><p>Ekiden:通过将共识节点和计算节点与可信硬件分开，提供保密的智能合约解决方案。</p></blockquote></li><li><p>[ ] (ACM SIGMOD 2019)Towards scaling blockchain systems via sharding.通过分片实现区块链系统的扩展。</p><blockquote><p>将新交所支持的可信随机性引入共识协议的运行过程中，构建了一个具有高交易吞吐量的分片区块链系统。</p></blockquote></li><li><p>[ ] (ACM SOSP 2019)Teechain: a secure payment network with asynchronous blockchain access. Teechain：具有异步区块链访问的安全支付网络。</p></li><li><p>[ ] (USENIX Security 2019)BITE: Bitcoin lightweight client privacy using trusted execution. BITE：使用可信执行的比特币轻量级客户端隐私。</p><blockquote><p>BITE将多种私人信息检索和侧通道保护技术与可信硬件集成在一起，以保护客户的地址和交易。</p></blockquote></li><li><p>[ ] (PVLDB 2021)SlimChain: Scaling Blockchain Transactions through Off-Chain Storage and Parallel Processing. SlimChain：通过链下存储和并行处理扩展区块链交易。==作者同团队== <a href="https://mp.weixin.qq.com/s/he_TEVoA0SWobvSLaOwVKw">https://mp.weixin.qq.com/s/he_TEVoA0SWobvSLaOwVKw</a></p></li></ul><ul><li><p>[ ] (USENIX Security 2017)REM: Resource-efficient mining for blockchains. In USENIX Security REM：区块链的资源高效挖掘。</p><blockquote><p>REM提出了一种称为有用工作证明的新共识，它依赖于英特尔 SGX 中可信的随机数生成器来代替hash puzzle。</p></blockquote></li></ul><h5 id="7-分层PKI设计-Intel-SGX-远程认证的成本过高的解决办法"><a href="#7-分层PKI设计-Intel-SGX-远程认证的成本过高的解决办法" class="headerlink" title="7.分层PKI设计,Intel SGX 远程认证的成本过高的解决办法"></a>7.分层PKI设计,Intel SGX 远程认证的成本过高的解决办法</h5><p>(ACM CCS 2016)Town crier: An authenticated data feed for smart contracts.<br>Town crier：面向智能合约的可认证数据源。</p><h5 id="8-以太坊黄皮书"><a href="#8-以太坊黄皮书" class="headerlink" title="8.以太坊黄皮书"></a>8.以太坊黄皮书</h5><p>Merkle Patricia Trie <a href="https://ethereum.github.io/yellowpaper/paper.pdf">https://ethereum.github.io/yellowpaper/paper.pdf</a><br>Merkle B-tree</p><h5 id="9-可验证轻节点相关工作"><a href="#9-可验证轻节点相关工作" class="headerlink" title="9.可验证轻节点相关工作"></a>9.可验证轻节点相关工作</h5><ul><li><p>[ ] (S&amp;P 2020)Flyclient: Super-light clients for cryptocurrencies. </p></li><li><p>[ ] (SBC 2020)Proof of Necessary Work: Succinct State Verification with Fairness Guarantees.必要工作的证明：简洁的状态验证，具有公平性保证。</p></li><li><p>[x] Plumo: An Ultralight Blockchain Client</p></li></ul><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p> <a href="https://github.com/apache/incubator-teaclave-sgx-sdk">https://github.com/apache/incubator-teaclave-sgx-sdk</a><br> <a href="https://github.com/rust-blockchain/evm">https://github.com/rust-blockchain/evm</a></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4>]]></content>
    
    
    <categories>
      
      <category>blockchain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Blockchain-basics</title>
    <link href="/2023/01/04/Blockchain-basics/"/>
    <url>/2023/01/04/Blockchain-basics/</url>
    
    <content type="html"><![CDATA[<h3 id="2022-学习-北大肖榛"><a href="#2022-学习-北大肖榛" class="headerlink" title="2022/学习/北大肖榛"></a>2022/学习/北大肖榛</h3><blockquote><p><img src="/images/Blockchain-basics.assets/image-20220923104503998.png" alt="image-20220923104503998" style="zoom:50%;"></p><p><img src="/images/Blockchain-basics.assets/image-20220923104733985.png" alt="image-20220923104733985" style="zoom:50%;"></p><p><img src="/images/Blockchain-basics.assets/image-20220923104749972.png" alt="image-20220923104749972" style="zoom:50%;"></p></blockquote><h4 id="比特币中的密码学原理"><a href="#比特币中的密码学原理" class="headerlink" title="比特币中的密码学原理"></a>比特币中的密码学原理</h4><blockquote><p>hash函数 和 数字签名</p><p><strong>hash 函数</strong>需要满足</p><ol><li>collision resistance性质（但不绝对，非哈希碰撞证明不出来）</li><li>hiding  x-&gt;h(x)  从h(x)推不出x</li><li>collision resistance + hiding 可以实现 <strong>digital commitment</strong>/digital equivalent of sealed envelope (预测结果不能提前公布，但是可以公布hash值，之后再验证预测值)</li><li>puzzle friendly  光从x无法判断h(x)的大致范围(挖矿就是找一个nonce,这个随机数和区块链块头的数字合起来，取hash,落在指定的范围之内，找随机数方法没有捷径)</li></ol><p>实际操作中为了使样本均匀，x经常补全一些随即数 x||nonce</p><p>比特币中用的hash函数是SHA-256(Secure Hash Algorithm)</p><p><strong>数字签名</strong></p><p>比特币开户的过程：创立公钥和私钥对（非对称加密体系，asymmetric encryption algorithm）生成公私钥时要有好的随机源，不然容易被破解</p></blockquote><h4 id="比特币中的数据结构"><a href="#比特币中的数据结构" class="headerlink" title="比特币中的数据结构"></a>比特币中的数据结构</h4><blockquote><p>hash指针 ：保存结构体的位置，以及结构体的hash值（可验证篡改</p><p>区块链就是使用hash指针的链表，每个区块包含指向前一个区块的hash指针，当有篡改时，后面所有的验证都不通过，我保存的hash值会感知到篡改（牵一发而动全身），所有可以只保存后几个新区块不用保存所有</p><p><img src="/images/Blockchain-basics.assets/image-20220923113101710.png" alt="image-20220923113101710"></p><p>第二个数据结构：merkle tree </p><p>最后一层是数据块，其余是hash指针，根节点也可以取hash ，root hash，只要保存了根hash，就能检测任何区块的修改。每个数据块是一个交易。</p><p><img src="/images/Blockchain-basics.assets/image-20220923113703982.png" alt="image-20220923113703982"></p><p>比特币中每个区块通过hash指针连在一起，每个区块<strong>所包含的交易组织成一个merkle tree</strong>的形式</p><p>每个<strong>区块</strong>分为 块头（block header）和块身(block body)，块头存放 root hash值，块身存放交易列表</p><p>merkle  tree 作用：提供 <strong>merkle proof</strong> 例如手机端的轻结点只保存block header</p><p>假设某轻节点想要知道某个交易(图中黄色)是否包含在这个merkle tree中，但它只有一个root hash. 全节点接受到proof请求，发送三个红色的hash值，轻节点可以在本地通过和红色的组合来计算出绿色的hash，最终算出root hash ,和block header里面的root hash 对比，即可验证黄色tx是否存在这棵树上。（proof of membership）</p><p><img src="/images/Blockchain-basics.assets/image-20220923115202061.png" alt="image-20220923115202061"></p><p>怎么证明这棵树上没有某个交易tx? </p><p>按照hash值排序</p></blockquote><h4 id="BTC协议"><a href="#BTC协议" class="headerlink" title="BTC协议"></a>BTC协议</h4><blockquote><p>暂时不考虑去中心化，如果央行要发行电子货币：</p><p>数字货币相当于一个文件，虽然不能伪造，但是可以复制（要防止<strong>双花攻击</strong>）</p><p>但任何两个人之间的交易都要通过央行确认、记录</p><p>解决以上问题，引入一种数据结构，区块链</p><p><img src="/images/Blockchain-basics.assets/image-20220925103515818.png" alt="image-20220925103515818"></p><p>有两种hash指针，一种是讲区块连接起来的指针，另一种是表示币的来源（防范double spending） ,实际交易中，每个区块包括多个交易。</p><p>block header:使用区块链哪个版本的协议、指向前一个区块的指针、整颗merkel树的root hash、挖矿的目标阈值、随机数</p><p>block body:交易链表，取hash时只管 block header,block body由  root hash保证不可篡改性</p><p>分布式共识-分布式hash表</p><p>FLP impossiblity result  :  在异步的系统中，即使只有一个成员是有问题的，就不能在系统中达成共识</p><p>CAP Theorem : consistency availability partition tolerance</p><p>Paxos 协议</p><p>联盟链：不是谁都能加入 hyperledger(适合基于投票决定下一个区块-fabric)</p><p>女巫攻击： cybil attack</p></blockquote><p>区块分为 </p><div class="table-container"><table><thead><tr><th>block header</th><th>block body</th></tr></thead><tbody><tr><td>比特币哪个版本协议</td><td>tx  list(交易列表)</td></tr><tr><td>指向前一个区块的hash指针</td><td></td></tr><tr><td>默克尔树根hash（保证body中的交易不被篡改）</td><td></td></tr><tr><td>target(难度目标阈值)</td><td></td></tr><tr><td>nonce（随机数）</td></tr></tbody></table></div><blockquote><p> H(block header) &lt;= target  （target是由比特币官方发布？？？）</p><p> block hearder存 nbits目标阈值的编码，<strong>指向前一个区块的hash只算区块的块头</strong></p></blockquote><p>节点分为：全节点(保存区块链所有信息，可以验证交易)、轻节点(只保存header,无法验证交易)，全节点比较少，大部分是轻节点</p><p>交易是如何写到区块链中？<strong>账本的内容要取得分布式的共识。</strong>distributed consensus</p><p>分布式hash表的研究中：有很多不可能结论——如下</p><blockquote><p>FLP :在异步的系统中，只要有一个节点是不诚实的，就无法达成共识</p><p>CAP理论：一致性、可用性、分区容错，不可能三角</p></blockquote><p>分布式共识著名协议：Paxos——共识是键值对</p><p>比特币中的共识协议</p><blockquote><p>思考：如果投票行不行，先打包一个候选区块，广播给所有节点，然后投票，如果恶意节点，每次都打包恶意交易，大家不停的投票，区块链无法继续下去；或者某些节点懒，谁的区块我都不投票。所以，任何以投票为基础的区块链，首先要确定谁有投票权，比如联盟链。</p><p>在比特币中，任何节点都能在本地产生公私钥对加入区块链，那假设某个恶意机器不停的产生账户，一旦超过50%，它就可以控制区块链，如果是投票机制的话，大于半数的票会被控制。——女巫攻击。（本地产生公私钥对其他人不知道，只有转账交易的时候才知道）</p><p>故，简单的直接投票不可行。</p><p><strong>比特币中基于算力“投票”</strong></p><p>H(block header) &lt;= target 找到 正确的nonce,其他节点验证：先看block hearder 中的nBits（目标阈值范围）是不是符合难度要求，再验证算出来的nonce是不是满足上述不等式，验证body中的交易合法性。</p><p>如果验证了某个区块都是合法的，是否也存在不想要接收的情况？——存在</p><p>接收到一个区块，怎么知道它插在哪里？——根据hash of prev block</p><p><img src="/images/Blockchain-basics.assets/image-20221104115814175.png" alt="image-20221104115814175"></p><p>下面这个分支，验证是合法的，但是不在最长合法链上，如果被接收了，相当于把A-&gt;B交易回滚了，所有不能接收。——分叉攻击</p><p>区块链在正常情况下也可能出现分叉，当出现两个等长的分叉，该接受哪个呢，不同网络节点中可能先后听到不同的区块，临时性分叉会维持一段时间，直到某一分叉胜出。另一个分叉就是orphan block。</p><p>为什么要争夺记账权？——出块奖励 coinbase transaction (发行新比特币的唯一方法)</p><p>比特币要取得的共识是什么？——账本的内容</p></blockquote><h4 id="BTX实现——transaction-based-ledger"><a href="#BTX实现——transaction-based-ledger" class="headerlink" title="BTX实现——transaction-based ledger"></a>BTX实现——transaction-based ledger</h4><p>比特币系统中的全节点要维护一个叫UTXO 的数据结构(unspent transaction output)，想要花掉的币必须在UTXO 中，总输入 == 总输出</p><p>发布区块的节点为啥要把某个包打包到区块链中？——有gas费（不光是出块奖励）</p><p>比特币是基于交易的账本，所有每个交易都要说明每个币是从哪里来的</p><p>account-based ledger 基于账户的账本（以太坊）</p><p>每次尝试一个nonce,相当于一个Bernoulli trial: a random experiment with binary outcome,这些Bernoulli trial 构成一个Bernoulli process: a sequence of independent Bernolli trails,是无记忆性的</p><p>实验次数很多时，变成泊松过程，出块时间服从指数分布，progress free,不会因为之前的工作而影响后面的工作</p><p><strong>区块插在哪个位置在一开始挖矿的时候就是确定的，因为block-header里要填前一个block的hash</strong></p><p>分叉攻击代价很大，等待6个确认之后，两个分叉的链竞赛</p><p>特殊情况：selfish mining 自己悄咪咪挖一直挖不发布，一直挖到超过上一个分叉链，等到收到货了（交易在上一个分叉中），一下子发布，企图覆盖上一个分叉区块</p><p>缺省设置：节点接收最先听到的交易</p><h4 id="比特币网络-工作原理"><a href="#比特币网络-工作原理" class="headerlink" title="比特币网络-工作原理"></a>比特币网络-工作原理</h4><blockquote><p>比特币工作在应用层（没有超级节点和主节点）</p><p>底层是p2p网络</p><p>加入比特币网络过程：与种子节点联系，它会告诉你它所知道的其他节点，节点之间通过TCP进行联系，有利于穿透防火墙</p></blockquote><p>simple,robust,but not efficient</p><p>每个节点维护一个邻居节点的集合，节点第一次听到某一个交易时，转发给所有邻居节点(flooding)，每个节点维护一个等待上链的区块链的交易集合，如果听到某一交易已经被写入区块链，从集合中删除这个交易</p><p>某一个交易发布到网络中，不一定每个节点都能收到，并且收到的顺序也不一样，有的节点收到了故意不转发，不按照规则，best effort</p><h4 id="挖矿难度的调整"><a href="#挖矿难度的调整" class="headerlink" title="挖矿难度的调整"></a>挖矿难度的调整</h4><p>H(block header) &lt;= target （target越小，挖矿难度越大，目标在整个空间中占比越小）</p><p>比特币用的hash算法是SHA-256</p><p>difficulty = difficult_1_target / target</p><p>为什么要调整挖矿难度?——出块时间越来越短会带来什么问题，会经常出现分叉，分叉过多严重影响效率。以太坊出块时间15秒，但要设计一个新的共识机制，ghost.对孤块也会有奖励，以太坊也要调整挖矿难度，保证出块时间的稳定。</p><p>比特币中规定，每隔2016个区块，就要调整挖矿难度，大概是两周（10min一个区块）。</p><blockquote><p>target = target * (actual time / expected time) </p><p>当实际所用时间大于2周，target变大，挖矿难度降低；当小于2周，target变小，挖矿难度变大。上下调整4倍为阈值</p><p>如何让大家都按照这个规则调整挖矿难度？——调整规则写在比特币代码里面，自动调整，但是代码是开源的，恶意节点可以故意不调整。但是此时target(256位)已经改变了，在header里面以nBits来存储target(压缩编码)，检测时，不调整的话其他节点不承认。</p></blockquote><h4 id="比特币挖矿"><a href="#比特币挖矿" class="headerlink" title="比特币挖矿"></a>比特币挖矿</h4><blockquote><p><img src="/images/Blockchain-basics.assets/image-20221104163050417.png" alt="image-20221104163050417"></p><p><img src="/images/Blockchain-basics.assets/image-20221104163249141.png" alt="image-20221104163249141"></p><p>只转账不挖矿，用轻节点就可以了。如果挖矿过程中听到区块链上已经挖出来了，要停止挖矿，重新组装交易，形成新的待上链集合。header会发生变化。 </p><p>挖矿设备（通用-&gt;专用）：</p><p>1、用通用计算机挖矿，hash计算只用到部分cpu指令集，内存有很多闲置，不划算</p><p>2、用GPU（通用并行计算），但很多操作指令也用不到，也不划算，不如用深度学习</p><p>3、用ASIC 芯片挖矿（专门用来挖矿，为某一加密货币设计的ASIC，除非mining puzzle一样，不如一个芯片只能为一种加密货币挖矿）</p><p>矿工按照通讯协议和矿主联系，矿主分配hash任务，矿工返回hash值。 </p></blockquote><h4 id="比特币引发的思考"><a href="#比特币引发的思考" class="headerlink" title="比特币引发的思考"></a>比特币引发的思考</h4><blockquote><p>1、hash指针，并不是真的指针，发布到网络的区块，header存的就是上一个区块的hash值而已，全节点把这些hash值存在一个（key,value）数据库中，levelDB,将所有区块串起来。</p><p>2、多个人保存私钥，不要用截断的方式，这样很容易猜到另外的片段，要用多重签名</p><p>3、比特币并不是把公钥直接暴露，而是提供公钥的hash,如果只是收钱，提供公钥的hash即可，取钱时才需要公钥 + 私钥签名，量子计算机也无法从公钥的hash推导出公钥。或者取钱之后，地址就丢弃，钱一下子取完。如果担心量子计算的威胁的话。</p></blockquote><h4 id="以太坊概述"><a href="#以太坊概述" class="headerlink" title="以太坊概述"></a>以太坊概述</h4><blockquote><p>1.重新设计共识机制ghost</p><p>2.不同的 mining puzzle,以太坊设计的mining puzzle对内存要求高，限制了ASIC芯片的使用，并且用权益证明来代替工作量证明</p><p>3.对智能合约的支持</p><p>为什么要用智能合约？——如果我们可以将货币去中心化，那还有什么可以去中心化？——去中心化合约，不是所有的合同都可以用编程语言实现，一些逻辑简单的合同可以放到智能合约中。</p><p>应用场景：比特币-跨国转账</p><p>智能合约：跨国交易（难以用司法手段维护权益）</p><p>BTC </p><p>ETH</p><p>bitcoin ：decentralized currency</p><p>ethereum: decentralized contract</p></blockquote><h4 id="以太坊账户"><a href="#以太坊账户" class="headerlink" title="以太坊账户"></a>以太坊账户</h4><blockquote><p>比特币中没有余额状态，每个币都要说明它的来源，交易的余额要换个地址存</p><p>以太坊内有账户余额的概念 account-based ledger,对双花有天然的防范作用，双花我二次扣费就行了。</p><p>以太坊会出现 replay attack ，解决办法是交易中增加计数器</p><p>外部账户：externally owned account(内包含：balance(账户余额) + nonce(计数器))</p><p>合约账户：smart contract account(balance(账户余额) + nonce(计数器)+code,storage)</p><p>合约可以调用合约，但是合约账户不能主动发起交易，创建合约的过程会返回一个地址，知道地址就可以调用合约啦</p><p>所有交易只能由外部账户发起，外部账户可以调用合约账户</p><p>因为需要支持<strong>智能合约</strong>，所以比特币不方便，比特币地址随时变化，没有固定的身份，以太坊要求参与者有比较稳定的身份。</p></blockquote><h4 id="以太坊的状态树"><a href="#以太坊的状态树" class="headerlink" title="以太坊的状态树"></a>以太坊的状态树</h4><blockquote><p>从账户地址到账户状态（外部账户和合约账户的状态）的映射</p><p>addr ——&gt; state 地址对应状态，直观想法是通过hash表来实现</p><p>状态树中保存（key,value）pair,MPT是管理key（即地址）的管理方式，value即账户状态，到底是怎么存储到状态树上。要经过一个rlp（递归长度编码做序列化）序列化，之后再存储。</p><p>protocal buffer(protobuf,pb) 著名的做序列化的库</p><p>RLP 只支持 nested array of bytes,即字节组成的数组，可以嵌套，以太坊中数据最终都要变成nested array of bytes</p><p>三棵树放到header,保证全节点本地的数据结构状态一致。</p><p>trie  字典树</p><p>以太坊地址格式 40位16进制（公钥的hash）</p><p><img src="/images/Blockchain-basics.assets/image-20221106211347241.png" alt="image-20221106211347241"></p><p><img src="/images/Blockchain-basics.assets/image-20221106211406571.png" alt="image-20221106211406571"></p><p>fabric项目</p></blockquote><h4 id="权益证明"><a href="#权益证明" class="headerlink" title="权益证明"></a>权益证明</h4><blockquote><p>比特币，工作量证明，很浪费资源和电力</p><p>能耗一定时必须的吗？挖矿的多少最本质就是投入钱的多少，那我们直接把钱拿出来比一比，把钱投入区块链开发，将来按照资金投入多少来分配收益。——POS 权益证明 proof of stack ，又称虚拟挖矿 virtual mining</p><p>比特币的挖矿资金是从区块链外部世界获得的，其资金其实只占世界资产的一小部分，如果真的有恶意攻击，很容易集齐51%的算力来攻击，使得比特币市值下降，对于比特币来说，其算力还是比较强大，但是对于一些刚刚发行的小货币，无法抵抗这种攻击。</p><p>POS 怎么对抗攻击？——情况有何不同，权益证明是按照拥有的币的总量进行投票，如果某个人想恶意攻击，他首先要获得币总发行量的一半以上，恶意者的资源只能从区块链内部得到，闭环。如果大量买入货币来进行攻击的话，价格会上涨。也有小货币用混合模式，挖矿难度和拥有币有关联，proof of deposit。</p><p>早期权益证明遇到的问题：nothing at stack 两头下注？  </p><p>以太坊中采用的权益证明（过渡阶段和pow混用）：Casper the Friendly Finality Gadget(FFG),引入一个概念，Validator验证者，投票决定哪个链是最长合法链，投票权重取决于保证金。验证者可以得到奖励，行政不作为/乱作为 会扣费。</p><p>以太坊的设计：逐渐从工作量证明过渡到权益证明，使得工作量证明的奖励越来越少</p><p>EOS：之前就是完全用权益证明，还在探索，不知道现在凉了没</p><p><strong>误区</strong>：认为比特币挖矿耗费电能，挖矿消耗的电其实占比不是很多。但其实电能很难存储，挖矿提供了将电转换成钱的手段。用电高峰电不够用，但是非高峰期，电能过剩，很多大型数据中心建立在电比较便宜的地方，因为传输数据比传输电容易。很多风力发电站的电除了满足当地用电，很难传输回主电网。主电网往边缘地区送电容易，但这些清洁能源的电发回主电网不是很容易，需要电网改造。</p></blockquote><h4 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h4><blockquote><p><img src="/images/Blockchain-basics.assets/image-20221104212616029.png" alt="image-20221104212616029"></p><p>solidity是面向对象编程语言</p><p>bidders.push(bidder)是一个动态可改变的数组</p><p>拍卖时，调用bid函数，此时比特币也发送过去锁定，所以bid函数要能够接收外部转账的能力，后面加payable</p><p>withdraw，将自己的出价取回来</p><p><img src="/images/Blockchain-basics.assets/image-20221104212704927.png" alt="image-20221104212704927"></p></blockquote><p>怎么调用智能合约？</p><p>转账地址如果为智能合约，则为调用函数，并不是要转账</p><blockquote><p><img src="/images/Blockchain-basics.assets/image-20221104213203037.png" alt="image-20221104213203037"></p><p>要先用外部账户调用B中的函数</p><p><img src="/images/Blockchain-basics.assets/image-20221104213344864.png" alt="image-20221104213344864"></p><p><img src="/images/Blockchain-basics.assets/image-20221104213443852.png" alt="image-20221104213443852"></p><p><img src="/images/Blockchain-basics.assets/image-20221104213615099.png" alt="image-20221104213615099"></p><p>data域为空，即没有指明调用智能合约哪个函数，就调用fallback</p><p><img src="/images/Blockchain-basics.assets/image-20221104214048239.png" alt="image-20221104214048239"></p><p>通过加一层虚拟机，增强可移植性，对智能合约的运行提供一个一致性平台</p><p><img src="/images/Blockchain-basics.assets/image-20221104214645320.png" alt="image-20221104214645320"></p><p>​    汽油费，智能合约是图灵完备的编程模型</p><p>出现死循环怎么办？</p><p><img src="/images/Blockchain-basics.assets/image-20221106114602715.png" alt="image-20221106114602715"></p><p>以太坊中的交易有原子性，普通交易or智能合约调用都是如此</p><p><img src="/images/Blockchain-basics.assets/image-20221106115103753.png" alt="image-20221106115103753"></p><p>连锁式回滚</p><p><img src="/images/Blockchain-basics.assets/image-20221106115341448.png" alt="image-20221106115341448"></p><p>gaslimit:每个矿工在发布区块时可以微调</p><p><img src="/images/Blockchain-basics.assets/image-20221106115444823.png" alt="image-20221106115444823"></p><p>假设某个全节点要打包一个交易到区块里，交易里面有一些是对智能合约的调用，全节点应该<strong>先执行智能合约？还是先挖矿？</strong>——首先明确，一个智能合约应该是要被所有全节点都执行的，不然状态会不一样。应该先执行所有智能合约，得到root,Txhash,ReceiptHash三棵树的根hash值，才能确定block header,才能开始挖矿。 </p><p>状态树（每个账户状态，包括余额），交易树，收据树，三棵树都保存在全节点本地数据结构，扣gas费时，多个全节点在本地数据结构中将gas费扣除。智能合约任何对状态的修改都是在改本地的数据结构，只有在智能合约执行完了，而且发布到区块链上之后，本地修改才外部可见，才会变成共识。</p><p>当接收交易时，每个全节点接收的交易可能不一样，但是就按照自己的执行，然后挖矿，直到某个块已经挖出来了，丢弃本地的计算，将块上的智能合约再执行一遍，更新本地的三棵树。 </p><p><strong>会不会有全节点不验证发布的区块的合法性？</strong>——不验证会威胁区块链安全。不会出现这个情况，如果不验证，本地三棵树无法更新，以后没法挖矿了。发布的区块上只有根hash值，没有三棵树的具体内容，所以每个全节点必须独立验证，更新自己的本地状态。 </p><p><strong>发布到区块链上的交易是否一定成功执行？</strong>——不一定，因为要扣gas费</p><p>如何知道交易是否执行成功，每个交易形成一个收据，如下图，status表明交易执行情况。</p><p><img src="/images/Blockchain-basics.assets/image-20221106150032510.png" alt="image-20221106150032510"></p><p><strong>智能合约是否支持多线程？——solidity不支持多线程。</strong></p><p>以太坊是交易驱动的状态机——该<strong>状态机必须完全确定</strong>，给定一个智能合约，面对同一组输入，产生的输出/转移到的下一个状态必须完全一致。因为每个全节点都要执行和验证。</p><p>多线程——对内存访问顺序不同，执行结果可能是不确定的。</p><p>所有不确定的操作都不可以，所以智能合约无法产生真正意义上的随机数，不然每个全节点产生的随机数不一样，可以用伪随机数。</p><p><strong>智能合约的执行必须是确定性的</strong>，每个全节点的执行环境不一样，所以不能像其他编程语言那样通过systemcall之类的方法得到环境信息</p><p><img src="/images/Blockchain-basics.assets/image-20221106150955674.png" alt="image-20221106150955674"></p><p><img src="/images/Blockchain-basics.assets/image-20221106151243198.png" alt="image-20221106151243198"></p><p>address.balance 账户余额</p><p>address.transfer 转入address钱</p><p><img src="/images/Blockchain-basics.assets/image-20221106151447135.png" alt="image-20221106151447135"></p></blockquote><p>拍卖例子</p><p>受益人：要拍卖东西的人</p><p>拍卖结束之前，每个人都能出价，竞拍时要把以太币发到智能合约锁住 </p><p><img src="/images/Blockchain-basics.assets/image-20221106152028684.png" alt="image-20221106152028684"></p><p><img src="/images/Blockchain-basics.assets/image-20221106152306021.png" alt="image-20221106152306021"></p><p>上述图片合约有问题吗？——看下图 （没看懂，继续搜搜？？）</p><blockquote><p>参数是拍卖合约的地址，调用拍卖合约中的bid函数，最后退款时auctionEnd只能看到hack地址，但是其中没有函数，只能调用fallback,引发异常，连锁回滚。——谁收不到钱了？</p><p>先明确转账是怎么转的，beneficiary.transfer把相应账户的余额进行了调整，所以回滚都回滚，转账就是修改本地数据结构，发布后其他矿工在改。此时回滚到合约执行之前，所有人都收不到钱。</p><p>这个hack有可能忘了写fallback函数</p></blockquote><p><img src="/images/Blockchain-basics.assets/image-20221106153236557.png" alt="image-20221106153236557"></p><p>改进方法——第二版</p><p><img src="/images/Blockchain-basics.assets/image-20221106160223541.png" alt="image-20221106160223541"></p><p>上图方法可行吗？——不行，重入攻击，递归调用，什么时候停止:拍卖账户上的钱不够了 or 汽油费不够了 or 调用栈溢出</p><p><img src="/images/Blockchain-basics.assets/image-20221106160519077.png" alt="image-20221106160519077"></p><p><img src="/images/Blockchain-basics.assets/image-20221106161051158.png" alt="image-20221106161051158"></p><h4 id="ETH-the-DAO"><a href="#ETH-the-DAO" class="headerlink" title="ETH - the DAO"></a>ETH - the DAO</h4><blockquote><p>DAO : Decentralized Autonomous Oraganization 去中心化的自治组织</p></blockquote><p>出现了一个组织叫 the  DAO ,本质是运行在以太坊上的智能合约，众筹。投入以太币，换回the DAO  的代币，用这些代币可以投票决定众筹的资金投入哪个项目，过一段时间内，通过拆分DAO,拿回资金和收益。</p><blockquote><p>DAC：Decentralized Autonomous Corporation</p></blockquote><p>拆分DAO 代码出了问题</p><blockquote><p>没有先把账户余额清0，重入攻击转走众筹的好多钱</p></blockquote><p><img src="/images/Blockchain-basics.assets/image-20221106164034705.png" alt="image-20221106164034705"></p><p>因为28天锁定，所以还有补救机会，能不能从攻击交易开始回滚？——不现实，以太坊上还有很多合法交易，回滚全都作废了。（此处回滚指分叉），所以补救措施只能精确到那些攻击的交易上。</p><p>1.锁定黑客账户（凡是与the DAO 相关的账户不允许发生交易，软分叉（收到the Dao相关交易不打包）），此时以太坊软件没有收取这个额外判断是否与the  DAO账户相关的汽油费，因此受到很多攻击，恶意交易，浪费矿工计算资源，矿工纷纷回滚软件</p><p>2.用软件升级的方法，强行将theDAO上的资金转到一个新的智能合约，这个新的智能合约只有一个功能，退钱。强行重新记账，没有什么签名（硬分叉）</p><p>至此区块链分成了两个链，目前以太坊也是两条链并存。</p><p>旧链 ETC （Ethereum Classic）</p><p>硬分叉后 ETH</p><p>许多矿工仍留在旧链上挖矿，为了信仰，挖矿难度低</p><p>为了防止重放攻击，两条链有chainID 的区分</p><h4 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h4><blockquote><p>智能合约真的智能吗？</p></blockquote><p>修bug要通过硬分叉，很难搞，需要绝大部分矿工同意</p><p>区块链冻结账户需要软分叉，发布软件更新，凡是与改账户有关账户的交易不予打包。但个人的账户不可能给你这样补救。只能尽快转到新账户。</p><p>区块链上如果出现智能合约漏洞，没有办法阻止别人不去调用这个bug,要想阻止只能软分叉。或者尽快把钱转走。</p><p>Nothing is irrevocable.</p><p>智能合约未来的方向：智能合约模板，合约框架</p><p>为什么开源软件，全世界都能查看，还会出现漏洞？</p><p>Many eyeball fallacy.</p><p>手机上的区块链钱包代码也是开源的，但是用的人认真看过的没有几个。</p><p>去中心化反思：不满与中心化管理方式</p><p>What does decentralization mean？——硬分叉能够成功也是大部分矿工的共识。对规则的修改要用去中心化的方法来修改。</p><p>存在分叉的选项，恰恰是民主的体现。</p><p>去中心化 不等于 分布式：分布式系统不一定是去中心化的，去中心化是分布式的。</p><blockquote><p>比特币和以太坊都是状态机，让不同节点维护同一种状态，但分布式一般是让不同节点做不同的事情，然后将结果汇总成最终结果（提高速度）。</p></blockquote><p>状态机最早的应用是stock exchange、space shuttle这种需要一刻不停的提供服务的，即使某一台服务器宕机，其他服务器能够继续提供服务。</p><blockquote><p>重点思想：智能合约到底适用于什么样的场景，不要把Evm平台当作成大规模计算/存储的服务，速度很慢且昂贵，<strong>智能合约是用来编写控制逻辑的，只有那些在互不信任的实体之间建立共识的操作才适合写在智能合约里面</strong>。大规模计算可以用云服务平台。</p></blockquote><h4 id="美链"><a href="#美链" class="headerlink" title="美链"></a>美链</h4><blockquote><p>Beauty Chain</p><p><img src="/images/Blockchain-basics.assets/image-20221106192823012.png" alt="image-20221106192823012"></p></blockquote><ul><li>ICO Initial Coin Offering</li><li>IPO Initial Public Offering</li><li>ERC EThereum Request for Comments</li></ul><blockquote><p><img src="/images/Blockchain-basics.assets/image-20221106193354921.png" alt="image-20221106193354921"></p><p>第2行，如果value很大，给每个人发行的代币很大，乘法可能溢出，导致扣掉的amount很小，但是value还是照常发，相当于凭空多发了代币。攻击方式如下：</p><p><img src="/images/Blockchain-basics.assets/image-20221106194005112.png" alt="image-20221106194005112"></p></blockquote><p>代码运算一定要仔细</p><blockquote><p><img src="/images/Blockchain-basics.assets/image-20221106194221468.png" alt="image-20221106194221468"></p></blockquote><h3 id="2022-常驻-学习"><a href="#2022-常驻-学习" class="headerlink" title="2022/常驻/学习"></a>2022/常驻/学习</h3><h4 id="1-1密码学哈希函数-是-数学函数"><a href="#1-1密码学哈希函数-是-数学函数" class="headerlink" title="1.1密码学哈希函数 是 数学函数"></a>1.1密码学哈希函数 是 数学函数</h4><blockquote><p>输入可以是任意长度字符串，输出为固定长度字符串（fixed-size)</p><ol><li><p>无碰撞 collision-free  ： 找不到 x ,y 满足 hash(x) = hash(y) [但实际上不是找不到，而是找到要花费的时间很多，代价高，但是某些简单的hash函数很容易找到碰撞]</p><ol><li>若一个哈希函数被假设为collision-free,我们可以用它作为信息的摘要，例如比较两个长文件是否一致，直接比较hash值即可</li></ol></li><li><p>隐藏性 hiding : 已知 hash(x),不可能推断出 x. H(r|x)可以隐藏其输入值x, 我们从分散的分布中得到r, 然后与x连接，r|x是指将r的二进制位放到x后面 。r是从具有最小熵的分布中选择的随机值 high min-entropy(高阶最小熵描述了分布的分散程度)</p><ol><li><p>应用：commitment</p><blockquote><p>承诺一个数据，然后展示它，承诺协议方案由两个算法构成</p><p>1）将承诺信息放入承诺函数,然后得到两个返回值com(commitment承诺)和临时随机数 key（com,key）:=commit(msg) </p><p>2）展示信息，（公开key 和msg）任何人都可以通过key和msg来验证公布的msg是否为之前承诺的.match:=verify(com,key,msg)</p><p><img src="/images/Blockchain-basics.assets/image-20220816100406870.png" alt="image-20220816100406870"></p><p>hash 的作用，com is the hash of key concatenated with msg</p><p><img src="/images/Blockchain-basics.assets/image-20220816100633628.png" alt="image-20220816100633628"></p></blockquote></li></ol></li><li><p>puzzle-friendly： 对于每个可能输出的 y ，如果 k是从高阶最小熵分布中随机选取的，那么不可能找到 x，使其满足 H( k | x ) = y</p><blockquote><p><img src="/images/Blockchain-basics.assets/image-20220818085143127.png" alt="image-20220818085143127"></p></blockquote></li></ol><p>哈希函数应用</p><p>SHA-256</p><p>1） 将你需要hash的信息分为 512bit大小的 block,最后一块不足512bit时补足</p><p><img src="/images/Blockchain-basics.assets/image-20220818085755713.png" alt="image-20220818085755713"></p></blockquote><h4 id="1-2-哈希指针及其应用"><a href="#1-2-哈希指针及其应用" class="headerlink" title="1.2 哈希指针及其应用"></a>1.2 哈希指针及其应用</h4><blockquote><p>哈希指针不但能告诉你数据的位置，还能判断数据是否遭到篡改</p><p>哈希指针指向某数据区块 + 记录了<strong>某个时间戳下该数据的hash值</strong><img src="/images/Blockchain-basics.assets/image-20220818093231959.png" alt="image-20220818093231959"></p><p>key idea : 用哈希指针构建数据结构</p><p>1）用哈希指针来构建链表，该数据结构称为 ——<strong>区块链</strong></p><p>每个区块都能告诉我们上一个区块的值在哪以及这个值的摘要，以此来验证那个值是否被篡改。区块链 — 防篡改日志，修改中间某个区块的值，就要一连串改动链上所有的信息，但是最初的hash指针无法改变（创世区块）</p><p><img src="/images/Blockchain-basics.assets/image-20220818093443722.png" alt="image-20220818093443722" style="zoom:67%;"></p><p>2）用哈希指针来构建二叉树——默克尔树  Merkle tree</p><p><img src="/images/Blockchain-basics.assets/image-20220818105756354.png" alt="image-20220818105756354"></p><p>与区块链的不一样之处：若某人想要证明某数据是该树中的一部分，他只需要给出这些数据，然后层层往上验证，花费logn的时间</p><p>优点：a) 能存很多东西，但在根部只需要记住一个256bit的哈希值；b)在logn的时间内验证从属关系</p><p>哈希指针可以用来构建任何基于指针且没有环的数据结构</p></blockquote><h4 id="1-3-数字签名"><a href="#1-3-数字签名" class="headerlink" title="1.3 数字签名"></a>1.3 数字签名</h4><p>类似纸上的签名，数字签名需要满足：</p><blockquote><p>1）只有自己可以签署自己的签名，且在其他地方别人可以验证该签名的有效性(only you can sign, but anyone can verify )</p><p>2）签名和某份特征文件绑定，不能剪下来粘贴</p><p>可验证  +  不可伪造</p></blockquote><p>如何利用密码学创造数字化形式的签名</p><blockquote><p>三种操作 - 组成数字签名方案</p><p>1）在一开始生成密钥，输入keysize ,得到 sk,pk</p><p>sk 为私钥，用来签署签名； pk为公钥，用于验证签名</p><p>2）签署，用sk签署签名，得到sign签名（一串表示你的签名的字符串</p><p>3）验证，接受声称有效的签名，用pk验证</p><p>注：前两个可以是随机算法，验证是确定的</p><p><img src="/images/Blockchain-basics.assets/image-20220818112731881.png" alt="image-20220818112731881"></p></blockquote><p>数字签名在实践中需要关注的点</p><blockquote><p>1）需要选择好的随机发生算法，否则容易泄露私钥导致不安全<br>2）注意消息长度限制，实践中通常不是对消息本身而是对消息的哈希结果进行签名，消息的hash值作为数字签名的输入<br>3）可以签署一个hash指针。如果对区块链最后一个哈希指针签名，相当于保证了整个指针结构及块链正确性，为该区块链的全部内容赋予了一个有效的数字签名</p><p><img src="/images/Blockchain-basics.assets/image-20220818155712239.png" alt="image-20220818155712239"></p></blockquote><p>比特币使用的特定的数字签名方案——ECDSA</p><blockquote><p>ECDSA涉及到复杂的数学，良好的随机性对其非常重要</p><p>Elliptic Curve Digital Signature Algorithm  椭圆曲线数字签名算法 </p></blockquote><h4 id="1-4-公钥作为身份标识"><a href="#1-4-公钥作为身份标识" class="headerlink" title="1.4 公钥作为身份标识"></a>1.4 公钥作为身份标识</h4><blockquote><p>如果某个签名被公钥验证正确，这是一段特定信息上面的签名，公钥即”说” 出了这个信息，公钥代表了一种身份，可以去做出这种声明</p><p><img src="/images/Blockchain-basics.assets/image-20220818160942667.png" alt="image-20220818160942667"></p><p>解释：在系统中可以利用数字签名方案生成公钥和私钥，公钥作为公开身份的名字（即声明身份，实践中通常用公钥的哈希值，公钥通常比较大），私钥作为这个身份的声明/证明，因为我有这个私钥，所有我拥有这个身份，同时，如果公钥的生成方式足够随机，没有人知道你究竟是谁。</p><p><img src="/images/Blockchain-basics.assets/image-20220818164019025.png" alt="image-20220818164019025"></p><p>以上就引导出一个去中心化身份管理的概念，无须注册身份或者名字，如果想要生成一个新身份，直接生成identity就行（公私钥）</p><p><strong>这些 identity 在区块链中称为地址</strong>（实际上就是一个公钥或者是公钥的哈希值）</p><p>身份的隐私性：</p><ol><li>identity和现实世界中的身份毫无关联</li><li>多次声明，行为方式可能会被观察者推断出现实身份</li></ol></blockquote><h4 id="1-5-简单的加密货币"><a href="#1-5-简单的加密货币" class="headerlink" title="1.5 简单的加密货币"></a>1.5 简单的加密货币</h4><h5 id="GoofyCoin"><a href="#GoofyCoin" class="headerlink" title="GoofyCoin"></a>GoofyCoin</h5><p>运行规则：</p><blockquote><ol><li><p>Goofy可以创造新的硬币</p><blockquote><p>CreateCoin 操作，生成币编号，，并且有一个Goofy签署的数字签名，任何人都能验证它</p></blockquote></li><li><p>高飞币可以被花掉，从一个到另一个人</p><blockquote><p>现有一个高飞币，加入一个指向其队hash指针，同时goofy做出将其付给Alice的声明（Alice被一个公钥代表），付给的动作由hash指针代表，同时Goofy签署签名，完成之后Alice成为这个高飞币的主人。</p><p>交易可以一直下去，通过检查hash指针链可以确保有效性</p><p><img src="/images/Blockchain-basics.assets/image-20220818165614862.png" alt="image-20220818165614862"></p><p><img src="/images/Blockchain-basics.assets/image-20220818170118103.png" alt="image-20220818170118103"></p></blockquote></li></ol><p>高飞币解决不了双重支付问题，并不安全，而这正是加密货币设计的关键问题之一</p><p><img src="/images/Blockchain-basics.assets/image-20220818170515230.png" alt="image-20220818170515230"></p></blockquote><h5 id="ScroogeCoin"><a href="#ScroogeCoin" class="headerlink" title="ScroogeCoin"></a>ScroogeCoin</h5><blockquote><p>ScroogeCoin会公开所有的货币交易记录</p><p>说明：iD 为 73的区块记录了当前的交易信息，并有一个 hash指针指向之前的交易信息，ScroogeCoin会在最后代表着全部交易的哈希指针上签名并发布，任何人可以验证。（实际区块链中，每个区块记录了多个交易信息）</p><p>公开交易记录可以防止双重支付现象，任何人都可以验证交易链</p><p><img src="/images/Blockchain-basics.assets/image-20220818170954917.png" alt="image-20220818170954917"></p><p>两种交易：</p><p>创币交易</p><p><img src="/images/Blockchain-basics.assets/image-20220819085759104.png" alt="image-20220819085759104"></p><p>支付代币交易</p><p>如果交易合法，需要满足四个条件，满足后此次交易才有效，Scrooge将接受该交易，并将交易记录写进区块链，所有人都能看到。</p><p>注：代币不会改变，不会组合，不能分割，只是在某次交易中被创造，或被销毁（通过交易的方式获得代币组合或者分割点效果</p><p><img src="/images/Blockchain-basics.assets/image-20220819090015863.png" alt="image-20220819090015863"></p><p>ScroogeCoin 的问题，如果Scrooge不诚信，系统将会出问题，我们能不能不要这个具有中心化管理的Scrooge，即不需要权威中心机构的加密货币。<strong>去中心化 ，但是依然能够提供Scrooge这样的服务。</strong><img src="/images/Blockchain-basics.assets/image-20220819090611351.png" alt="image-20220819090611351"></p></blockquote><h4 id="2-1-去中心化的比特币"><a href="#2-1-去中心化的比特币" class="headerlink" title="2.1 去中心化的比特币"></a>2.1 去中心化的比特币</h4><blockquote><p>比特币实现去中心化的方法并不是完全依靠技术，是技术和巧妙激励机制的结合</p><p>没有彻底的去中心化和中心化，例如邮件系统，去中心化的，完全依靠SMTP协议，但是近年来被邮箱供应商控制（<strong>基于去中心化系统之上开发的应用服务可能是中心化的</strong>）</p></blockquote><p>去中心化面临的几个问题</p><blockquote><p>谁来维护账本？</p><p>谁来认证交易是否有效？</p><p>谁来创造新代币？</p><p>谁来决定系统的规则？</p><p>比特币如何取得汇率？</p></blockquote><p>点对点网络：任何人都可以运行比特币节点，去网上下载比特币客户端</p><p>挖矿：可以基于某挖矿生态系统中进行投入，并不是去中心化的</p><p>软件更新：核心开发员受社区信任，在决定电脑上使用什么比特币软件来运行节点时有很高的权限</p><h4 id="2-2-分布式共识"><a href="#2-2-分布式共识" class="headerlink" title="2.2 分布式共识"></a>2.2 分布式共识</h4><h4 id="2-3-没有身份共识的区块链"><a href="#2-3-没有身份共识的区块链" class="headerlink" title="2.3 没有身份共识的区块链"></a>2.3 没有身份共识的区块链</h4><blockquote><p>为什么比特币没有身份认证？（没有持久的长期身份）</p><p>身份认证在p2p网络很难：在去中心化的点对点网络，没有中央权威机构来给节点赋予身份，女巫攻击——恶意对手创建的节点副本，营造有很多不同参与者的假象，实际上全都由同一个对手控制</p><p>使用假名本就是比特币的目标之一</p></blockquote><p>区块链共识算法</p><blockquote><p>Alice想转账给Bob,她会创建一笔交易，并向所有节点广播这笔交易，任意一个节点都在持续不断接收着网络中的信息，并收集尚未纳入区块链的未完成交易列表。</p><p>某一时刻，这些节点中的某一个会被随机调用，用来提议下一个区块，它会收集所有未完成的交易，该节点可能是诚实的也可能是恶意的（）提议一个无效的交易。</p><p>其他节点将包含下一个区块的hash值，或者无视该区块转而去包含前一个他们认为有效的区块的hash值</p><p><img src="/images/Blockchain-basics.assets/image-20220822104845720.png" alt="image-20220822104845720"></p></blockquote><p>双重支付</p><blockquote><p>ALice 付钱后，恰好轮到ALice 提议下一个区块，Alice提出一笔交易，是将钱付给另一个由她控制的节点，这个钱指向的区块链和之前付给Bob的是同一笔，也就是说同一笔钱，Alice想用两次，让她付给Bob的交易变成孤儿节点，但她已经获得了Bob的商品，实际Bob并没有收到钱。</p><p><img src="/images/Blockchain-basics.assets/image-20220822111654641.png" alt></p><p>Bob怎么保护自己：零确认交易….放弃交易</p><p>最终防范双花现象靠的是共识机制，因为大部分节点都是诚实的，和密码学无关</p></blockquote><h4 id="2-4-激励机制与工作量证明"><a href="#2-4-激励机制与工作量证明" class="headerlink" title="2.4 激励机制与工作量证明"></a>2.4 激励机制与工作量证明</h4><p>给节点一个激励政策，保证它是诚实的？惩罚不诚实节点。</p><blockquote><p>节点是匿名的，没办法追踪去惩罚? 所以重点关注奖励最终留在长期共识链上的节点。</p><p>用比特币去激励创造了区块的节点</p><p><img src="/images/Blockchain-basics.assets/image-20220822112840189.png" alt="image-20220822112840189"></p><p>2种激励机制</p><p>1）区块奖励：每个创造了区块的节点，都可以在该区块中包含一个特殊交易——比特币创建交易，可以自主选择交易的地址。（系统唯一产生新货币的方式）</p><p><img src="/images/Blockchain-basics.assets/image-20220822113318971.png" alt="image-20220822113318971"></p><p>2）交易手续费：任何交易的创建者都会支付“小费”给那个将该交易写入下一个区块的节点</p><p><img src="/images/Blockchain-basics.assets/image-20220822113921326.png" alt="image-20220822113921326"></p></blockquote><h4 id="遗留的问题"><a href="#遗留的问题" class="headerlink" title="遗留的问题"></a>遗留的问题</h4><blockquote><ol><li>如何随机选择节点？</li><li>如何避免每个人都想获得区块奖励的混战？</li><li>如何避免女巫攻击？</li></ol><p><img src="/images/Blockchain-basics.assets/image-20220822114014942.png" alt="image-20220822114014942"></p><p><strong>工作量证明</strong>（以上问题都用这个解决）</p><p>不再随机随机选取节点，而是按照计算能力的比例来选择节点，让节点用自身的计算能力来相互竞争</p><p><img src="/images/Blockchain-basics.assets/image-20220822114554106.png" alt="image-20220822114554106"></p><p>实现方法：hash pazzels</p><p>为了创建区块，提出该区块的节点，需要找到一个随机数（不会被轻易找到）（只能穷举）</p><p>这是节点在创造区块之前必须解决的数学难题</p><p><img src="/images/Blockchain-basics.assets/image-20220822115545201.png" alt="image-20220822115545201"></p><p>hash power?</p></blockquote><h4 id="2-5-整合所有内容"><a href="#2-5-整合所有内容" class="headerlink" title="2.5 整合所有内容"></a>2.5 整合所有内容</h4>]]></content>
    
    
    <categories>
      
      <category>blockchain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lectures</title>
    <link href="/2023/01/04/lectures/"/>
    <url>/2023/01/04/lectures/</url>
    
    <content type="html"><![CDATA[<h3 id="2022-8-10-CCS论文讲座-HTTPS上下文混淆攻击"><a href="#2022-8-10-CCS论文讲座-HTTPS上下文混淆攻击" class="headerlink" title="2022/8/10 CCS论文讲座-HTTPS上下文混淆攻击"></a>2022/8/10 CCS论文讲座-HTTPS上下文混淆攻击</h3><p>《Talking with Familiar Strangers: An Empirical Study on HTTPS Context Confusion Attacks》</p><p>主要对HTTPS上下文混淆攻击进行了研究。</p><p>问题本质：中间人攻击，中间人对客户端和服务器端分别伪装</p><p>使用https的场景已经足够安全，会有证书过期提示、风险提示等，但这并非真的安全。</p><p>例子：支付劫持</p><p>预备知识</p><p>证书共享</p><ul><li>[ ] 一张证书在多个场景都有效</li><li>[ ] 多个服务器共享同一张证书</li></ul><p>在加密过程中，客户端依赖证书来判断服务器的合法性。</p><p>但是共享TLS证书会导致安全依赖，攻击<strong>比较弱势的服务器</strong>来劫持安全部署过的网站，这些共享证书的网站即为最熟悉的陌生人，其安全性由最弱的决定（木桶效应）</p><p><img src="/images/lectures.assets/image-20220810093038425.png" alt="image-20220810093038425" style="zoom:50%;"></p><p>攻击模型</p><p>http降级攻击，将信息降级为明文</p><p>http绕过攻击</p><p><img src="/images/lectures.assets/image-20220810094054184.png" alt="image-20220810094054184" style="zoom:50%;"></p><p>攻击的根源和解决方法</p><p>证书的共享会带来很多隐藏的问题</p><p><img src="/images/lectures.assets/image-20220810094523119.png" alt="image-20220810094523119" style="zoom:50%;"></p><h3 id="2022-8-11-论文讲座-跨异构区块链的互操作性和可编程性"><a href="#2022-8-11-论文讲座-跨异构区块链的互操作性和可编程性" class="headerlink" title="2022/8/11 论文讲座-跨异构区块链的互操作性和可编程性"></a>2022/8/11 论文讲座-跨异构区块链的互操作性和可编程性</h3><p>（未看完[北邮向阳曦：HyperService: Interoperability and Programmability Across Heterogeneous Blockchains]</p><p>跨异构区块链的互操作性和可编程性</p><p>预备知识</p><p>区块链成果</p><p>交易网络：分布式账本，交易记录存储在分布式账本上（比特币</p><p>智能合约平台：利用防篡改特性</p><p>区块链1.0</p><p>以太坊</p><p>智能合约</p><h3 id="2022-8-11-InForSec-网络空间安全讲座"><a href="#2022-8-11-InForSec-网络空间安全讲座" class="headerlink" title="2022/8/11 InForSec 网络空间安全讲座"></a>2022/8/11 InForSec 网络空间安全讲座</h3><h4 id="1-结合软件安全工作谈有价值研究"><a href="#1-结合软件安全工作谈有价值研究" class="headerlink" title="1-结合软件安全工作谈有价值研究"></a>1-结合软件安全工作谈有价值研究</h4><p>（邹德清  华中科技大学网络空间安全学院副院长、教授）</p><p><strong>开源软件</strong>成为软件产业主流开发模式，商业软件 含有开源组件和开源代码</p><p>开源时代大量开源组件让软件供应链变得更复杂</p><p>针对软件供应链的攻击，大部分由于开源组件导致，例如liunx内核脏牛漏洞，导致其下各种发行版和软件收到影响</p><p>软件源代码漏洞智能检测：将深度学习用于源代码检测（细粒度，某个函数</p><p><img src="/images/lectures.assets/image-20220811091657360.png" alt="image-20220811091657360" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220811092350902.png" alt="image-20220811092350902" style="zoom:50%;"></p><p>1.将代码输入到模型去学习—-确定哪里有漏洞</p><p><img src="/images/lectures.assets/image-20220811092536739.png" alt="image-20220811092536739" style="zoom:50%;"></p><p>2.如何确定漏洞类型</p><p><img src="/images/lectures.assets/image-20220811092834369.png" alt="image-20220811092834369" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220811092929818.png" alt="image-20220811092929818" style="zoom:50%;"></p><p>3.不局限在库函数，提取所有漏洞相关的特征（漏洞扫描规则）</p><p><img src="/images/lectures.assets/image-20220811093102569.png" alt="image-20220811093102569" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220811093217670.png" alt="image-20220811093217670" style="zoom:50%;"></p><p>4.精准定位到漏洞代码的某行</p><p><img src="/images/lectures.assets/image-20220811093346189.png" alt="image-20220811093346189" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220811093516641.png" alt="image-20220811093516641" style="zoom:50%;"></p><p>5.深度学习模型是黑盒，试图解释到底是哪些特征会被识别出漏洞？</p><p><img src="/images/lectures.assets/image-20220811093652476.png" alt="image-20220811093652476" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220811093838680.png" alt="image-20220811093838680" style="zoom:50%;"></p><p>final.总结</p><p>很多国产软件用的都是国外开源组件</p><p><img src="/images/lectures.assets/image-20220811094305341.png" alt="image-20220811094305341" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220811094404233.png" alt="image-20220811094404233" style="zoom:50%;"></p><h4 id="2-漫谈漏洞研究"><a href="#2-漫谈漏洞研究" class="headerlink" title="2-漫谈漏洞研究"></a>2-漫谈漏洞研究</h4><p>钱志云 加州大学河滨分校教授</p><p>漏洞研究是什么？——作为黑客怎么利用人工规则的漏洞</p><p>1.漏洞建模</p><p>2.漏洞挖掘，自动化分析，写一些工具</p><p>3.漏洞评估</p><p>4.漏洞防范（检测or补丁or系统重建）</p><p><img src="/images/lectures.assets/image-20220811095648125.png" alt="image-20220811095648125" style="zoom:50%;"></p><p>侧信道漏洞建模</p><p>（小时候偷玩游戏机，老爸回家摸到电视机发烫，被发现）</p><p>攻击者通过感知共享资源来获取信息</p><p><img src="/images/lectures.assets/image-20220811100534135.png" alt="image-20220811100534135" style="zoom:50%;"></p><p>网络协议中</p><p>有没有通信？用DNS查询</p><p>攻击者：off-path ,IP spoofing</p><p>获取源端口号</p><p><img src="/images/lectures.assets/image-20220811100728615.png" alt="image-20220811100728615" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220811101149252.png" alt="image-20220811101149252" style="zoom:50%;"></p><p>作为攻击者，利用某种共享资源</p><h4 id="3-国际网络空间安全顶级学术会议介绍与数据分析"><a href="#3-国际网络空间安全顶级学术会议介绍与数据分析" class="headerlink" title="3-国际网络空间安全顶级学术会议介绍与数据分析"></a>3-国际网络空间安全顶级学术会议介绍与数据分析</h4><p>张玉清  中国科学院大学</p><p>什么是网安顶会？</p><p><img src="/images/lectures.assets/image-20220811103700493.png" alt="image-20220811103700493" style="zoom:50%;"></p><p>1980-2021年顶会数据分析</p><p><img src="/images/lectures.assets/image-20220811104657842.png" alt="image-20220811104657842" style="zoom:50%;"></p><p>中国大陆学者与单位的表现</p><p><img src="/images/lectures.assets/image-20220811104828458.png" alt="image-20220811104828458" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220811105242969.png" alt="image-20220811105242969" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220811105914018.png" alt="image-20220811105914018" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220811105933322.png" alt="image-20220811105933322" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220811110416647.png" alt="image-20220811110416647" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220811110727719.png" alt="image-20220811110727719" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220811111006252.png" alt="image-20220811111006252" style="zoom:50%;"></p><p>顶会研究方向：网络安全 + 软件与系统安全 + 漏洞分析和利用 + 密码学</p><p><img src="/images/lectures.assets/image-20220811111105151.png" alt="image-20220811111105151"></p><p>国际顶会新兴研究方向： 模糊测试 + 机器学习 + 区块链 + 安全计算</p><p><img src="/images/lectures.assets/image-20220811111120377.png" alt="image-20220811111120377" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220811111144341.png" alt="image-20220811111144341" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220811111227418.png" alt="image-20220811111227418"></p><p><img src="/images/lectures.assets/image-20220811111255597.png" alt="image-20220811111255597"></p><p><img src="/images/lectures.assets/image-20220811111322802.png" alt="image-20220811111322802"></p><p>趋势和启发</p><h4 id="4-AI系统安全风险与测试评估"><a href="#4-AI系统安全风险与测试评估" class="headerlink" title="4-AI系统安全风险与测试评估"></a>4-<strong>AI系统安全风险与测试评估</strong></h4><p>蔺琛皓 西安交通大学研究员、博士生导师</p><p>AI系统安全风险</p><p>性别人种歧视，自动驾驶安全，伪造视频</p><p><img src="/images/lectures.assets/image-20220811112630657.png" alt="image-20220811112630657" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220811112734287.png" alt="image-20220811112734287" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220811112758761.png" alt="image-20220811112758761" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220811112833773.png" alt="image-20220811112833773" style="zoom:50%;"></p><p>对AI系统全生命周期进行保护</p><ol><li><p>输入阶段（数据污染）：虚假数据、恶意数据（例如推荐视频投毒）</p><p><img src="/images/lectures.assets/image-20220811113058449.png" alt="image-20220811113058449" style="zoom:50%;"></p></li><li><p>传感器欺骗：对汽车传感器造成干扰</p></li></ol><p><img src="/images/lectures.assets/image-20220811113248533.png" alt="image-20220811113248533" style="zoom:50%;"></p><p>防止人类歧视的放大</p><p><img src="/images/lectures.assets/image-20220811113549137.png" alt="image-20220811113549137" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220811114443638.png" alt="image-20220811114443638" style="zoom:50%;"></p><p>机器学习框架存在大量问题</p><p><img src="/images/lectures.assets/image-20220811115740496.png" alt="image-20220811115740496" style="zoom:50%;"></p><h4 id="5-打造机密计算的安全底座"><a href="#5-打造机密计算的安全底座" class="headerlink" title="5-打造机密计算的安全底座"></a>5-打造机密计算的安全底座</h4><p>张殷乾 南方科技大学教授</p><p>可信执行环境（TEE）</p><p><img src="/images/lectures.assets/image-20220811133444070.png" alt="image-20220811133444070" style="zoom: 67%;"></p><p>TEE 安全原理</p><p><img src="/images/lectures.assets/image-20220811133759476.png" alt="image-20220811133759476" style="zoom: 67%;"></p><p>机密计算：利用可信执行环境的硬件，保护使用中的数据和代码</p><p>TEE机密计算场景</p><p><img src="/images/lectures.assets/image-20220811134136459.png" alt="image-20220811134136459" style="zoom: 67%;"></p><p><img src="/images/lectures.assets/image-20220811134146414.png" alt="image-20220811134146414" style="zoom: 67%;"></p><p>机密计算面临的问题</p><p>瞬态执行漏洞 （intel SGX 内存泄露</p><p><img src="/images/lectures.assets/image-20220811134353658.png" alt="image-20220811134353658" style="zoom: 67%;"></p><p><img src="/images/lectures.assets/image-20220811134722036.png" alt="image-20220811134722036" style="zoom:50%;"></p><p>侧信道漏洞</p><p><img src="/images/lectures.assets/image-20220811134827119.png" alt="image-20220811134827119"></p><p>线程并发漏洞</p><p>如何保证机密计算</p><p><img src="/images/lectures.assets/image-20220811135639844.png" alt="image-20220811135639844"></p><p><img src="/images/lectures.assets/image-20220811140439492.png" alt="image-20220811140439492"></p><p>分布式机密计算或是未来前沿</p><h3 id="2022-8-14-CCF-区块链安全与隐私论坛"><a href="#2022-8-14-CCF-区块链安全与隐私论坛" class="headerlink" title="2022/8/14 CCF 区块链安全与隐私论坛"></a>2022/8/14 CCF 区块链安全与隐私论坛</h3><h4 id="1-当安全计算碰上区块链（？没听懂）"><a href="#1-当安全计算碰上区块链（？没听懂）" class="headerlink" title="1-当安全计算碰上区块链（？没听懂）"></a>1-当安全计算碰上区块链（？没听懂）</h4><p>When Secure Computing Meets Blockchain</p><p><img src="/images/lectures.assets/image-20220814091029706.png" alt="image-20220814091029706"></p><p>可证明安全</p><ol><li><p>定义一个目标</p></li><li><p>合适的工具</p></li><li>构造一个协议、方案</li><li>证明方案的安全</li></ol><p><img src="/images/lectures.assets/image-20220814091140415.png" alt="image-20220814091140415"></p><p><img src="/images/lectures.assets/image-20220814091231271.png" alt="image-20220814091231271"></p><p><img src="/images/lectures.assets/image-20220814091308286.png" alt="image-20220814091308286"></p><p>什么是安全计算</p><ol><li>找到共同的朋友</li><li>一组互相不信任的可以计算</li></ol><h4 id="2-多密钥的数字签名及在区块链中的应用"><a href="#2-多密钥的数字签名及在区块链中的应用" class="headerlink" title="2-多密钥的数字签名及在区块链中的应用"></a>2-多密钥的数字签名及在区块链中的应用</h4><p>Tsz Hon Yuen, Assistant Professor, Hongkong University</p><p><img src="/images/lectures.assets/image-20220814100255229.png" alt="image-20220814100255229" style="zoom:50%;"></p><h5 id="门限签名-区块链中的密钥托管"><a href="#门限签名-区块链中的密钥托管" class="headerlink" title="门限签名 - 区块链中的密钥托管"></a>门限签名 - 区块链中的密钥托管</h5><p>为啥密钥这么重要？</p><blockquote><p>比特币交易平台，私钥被盗，损失money</p></blockquote><p><img src="/images/lectures.assets/image-20220814100510913.png" alt="image-20220814100510913" style="zoom:50%;"></p><p>密钥怎么管理？</p><p>单一密钥-&gt;单点故障</p><p>多密钥的数字签名-&gt;门限签名</p><p><img src="/images/lectures.assets/image-20220814100738068.png" alt="image-20220814100738068" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220814100845110.png" alt="image-20220814100845110" style="zoom:50%;"></p><p>举例，门限密钥分为两个部分，两边分别不能拿到对方的私钥</p><p><img src="/images/lectures.assets/image-20220814100959583.png" alt="image-20220814100959583" style="zoom:50%;"></p><p>ECDSA的难题是</p><p><img src="/images/lectures.assets/image-20220814101150273.png" alt="image-20220814101150273" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220814101226171.png" alt="image-20220814101226171" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220814101327807.png" alt="image-20220814101327807" style="zoom:50%;"></p><p>两方ECDSA的研究</p><p>老方法</p><p><img src="/images/lectures.assets/image-20220814101710919.png" alt="image-20220814101710919" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220814101743166.png" alt="image-20220814101743166" style="zoom:50%;"></p><p>我们的设计</p><p><img src="/images/lectures.assets/image-20220814101844544.png" alt="image-20220814101844544" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220814101921163.png" alt="image-20220814101921163" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220814102024996.png" alt="image-20220814102024996"></p><h5 id="多重签名－多重UTXO输入交易"><a href="#多重签名－多重UTXO输入交易" class="headerlink" title="多重签名－多重UTXO输入交易"></a>多重签名－多重UTXO输入交易</h5><p>多个钱包才够支付，但是每次交易都有交易费用</p><p><img src="/images/lectures.assets/image-20220814102217754.png" alt="image-20220814102217754" style="zoom:50%;"></p><p>我们的工作，怎么用多重签名就代表多个地址提交的签名</p><p>Alice只需要传一个签名</p><p><img src="/images/lectures.assets/image-20220814102341163.png" alt="image-20220814102341163" style="zoom:50%;"></p><p>Schnorr多重签名</p><p>ECDSA多重签名</p><p><img src="/images/lectures.assets/image-20220814102625627.png" alt="image-20220814102625627" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220814102710271.png" alt="image-20220814102710271" style="zoom:50%;"></p><p>通过的办法</p><p><img src="/images/lectures.assets/image-20220814102734358.png" alt="image-20220814102734358"></p><h5 id="环签名-匿名交易"><a href="#环签名-匿名交易" class="headerlink" title="环签名-匿名交易"></a>环签名-匿名交易</h5><p>区块链咋用</p><p><img src="/images/lectures.assets/image-20220814103133867.png" alt="image-20220814103133867"></p><p><img src="/images/lectures.assets/image-20220814103335278.png" alt="image-20220814103335278" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220814103505987.png" alt="image-20220814103505987" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220814104734504.png" alt="image-20220814104734504" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220814104438094.png" alt="image-20220814104438094" style="zoom:50%;"></p><blockquote><p>感觉说的还不错，但是很多基础知识我不懂所以还是不太明白，稍后补一下基础概念</p></blockquote><h4 id="3-去中心化金融中的智能合约安全"><a href="#3-去中心化金融中的智能合约安全" class="headerlink" title="3-去中心化金融中的智能合约安全"></a>3-去中心化金融中的智能合约安全</h4><p>周亚金博士，BlockSec联合创始人</p><blockquote><p><img src="/images/lectures.assets/image-20220814105144350.png" alt="image-20220814105144350"></p><p><img src="/images/lectures.assets/image-20220814105223290.png" alt="image-20220814105223290"></p><p>去中心化金融</p><p>将金融活动放到区块链场景，基于以太坊</p><p><strong>稳定币</strong></p><blockquote><p><img src="/images/lectures.assets/image-20220814105434545.png" alt="image-20220814105434545"></p><p>通过价值绑定实现稳定币</p><p>USDC，比特币换成美元时，先销毁，找USDC，兑换成美元（大概这个意思？</p><p><img src="/images/lectures.assets/image-20220814105651523.png" alt="image-20220814105651523"></p><p><img src="/images/lectures.assets/image-20220814105941676.png" alt="image-20220814105941676"></p></blockquote><p><strong>借贷平台</strong></p><p>无抵押借贷</p><p><img src="/images/lectures.assets/image-20220814110448925.png" alt="image-20220814110448925"></p><p>区块链交易安全</p><p><img src="/images/lectures.assets/image-20220814110951785.png" alt="image-20220814110951785"></p><p>三明治攻击</p><blockquote><p>一笔交易发出时，会在区块链网络进行广播（p2p网络），记账权的矿工将交易进行打包。金融交易会被其他节点知道</p></blockquote><p><img src="/images/lectures.assets/image-20220814111030105.png" alt="image-20220814111030105"></p><blockquote><p>交易信息提前被别人知道，会收到三明治攻击</p><p>买家想买Y，攻击者预先购买Y，付出更高手续费，矿工打包时按照手续费排序，攻击者的交易会先上链，然后卖掉？？（没听懂</p></blockquote><p><img src="/images/lectures.assets/image-20220814111521792.png" alt="image-20220814111521792"></p><p>智能合约，检测不安全的价格依赖</p></blockquote><h4 id="4-基于区块链的数据安全共享机制"><a href="#4-基于区块链的数据安全共享机制" class="headerlink" title="4-基于区块链的数据安全共享机制"></a>4-基于区块链的数据安全共享机制</h4><p>沈蒙，北京理工大学教授</p><p>数据共享面临这隐私和安全问题</p><p>现有的解决方案：安全多方计算  联邦学习  <strong>区块链</strong></p><blockquote><p><img src="/images/lectures.assets/image-20220814135102203.png" alt="image-20220814135102203" style="zoom: 33%;"></p><p><img src="/images/lectures.assets/image-20220814135239631.png" alt="image-20220814135239631" style="zoom:33%;"></p></blockquote><p>区块链数据安全共享架构-借助区块链提出数据共享平台</p><blockquote><p><img src="/images/lectures.assets/image-20220814135447475.png" alt="image-20220814135447475" style="zoom:33%;"></p><p>同构数据共享</p><p><img src="/images/lectures.assets/image-20220814135659046.png" alt="image-20220814135659046" style="zoom:33%;"></p><p>数据同态加密后记录在链上</p><p><img src="/images/lectures.assets/image-20220814140947894.png" alt="image-20220814140947894" style="zoom:33%;"></p></blockquote><p>Q：请教沈老师：物联网设备接入安全如何保证？物联网设备数据共享标志性场景有哪些？</p><p>Q：沈老师好，我想问两个问题，一个是区块链引入，是基于什么共识机制，区块链[表情]svm实现的是什么共享呢？<br>Q：第二个问题是区块链和人工智能底层主要基于不同的编程语言和库，您是自己搭建了自己的代码，还是用了什么方式进行不同编程语言的协同呢？</p><p>A：网络上的工具搭建的区块链工具，主要是智能合约部分的编写。</p><p>Q：沈老师好，基于同态加密真的能做基于密文的机器模型训练？用同态加密外包给第三方做一次密文计算问题不大（机器学习预测），但深度学习设计多层，尤其是后向传播，密文训练模型目前有什么进展？</p><p>A：难，没啥进展。</p><h4 id="5-BlockMaze-面向账户模型区块链的高效隐私保护机制"><a href="#5-BlockMaze-面向账户模型区块链的高效隐私保护机制" class="headerlink" title="5-BlockMaze: 面向账户模型区块链的高效隐私保护机制"></a>5-BlockMaze: 面向账户模型区块链的高效隐私保护机制</h4><p>万志国，之江实验室研究员</p><h5 id="motivation"><a href="#motivation" class="headerlink" title="motivation"></a>motivation</h5><blockquote><p>区块链分为两个模型 ： UTXO 模型 、银行账户余额模型</p><p><img src="/images/lectures.assets/image-20220814141935671.png" alt="image-20220814141935671" style="zoom: 50%;"></p><p><strong>UTXO模型</strong></p><p>在隐私保护方面更好，但是问题是难以和智能合约（区块链2.0）进行协同工作</p><p><strong>银行账户模型</strong></p><p>可以和智能合约协同工作，但是隐私保护成为问题，因为每次交易都会更新余额，但是这区块链上，交易是所有人都知道的</p><p><img src="/images/lectures.assets/image-20220814142136025.png" alt="image-20220814142136025"></p><p>UTXO模型的电子货币有隐私保护的解决方案（如下），但是基于账户余额模型却没有对应的隐私保护方案</p><p><img src="/images/lectures.assets/image-20220814142359887.png" alt></p></blockquote><h5 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h5><blockquote><p>零知识证明</p><p>验证者没有办法伪装</p><p>最著名的是schnorr</p><p><img src="/images/lectures.assets/image-20220814142736268.png" alt></p><p>我们的方案，使用特殊的零知识证明，zk-snark</p><p><img src="/images/lectures.assets/image-20220814143021008.png" alt></p><p>最早的zk的使用</p><p>《commitment的方案》啥意思？？</p><p>cm存在链上，黄色变量存在钱包</p><p><img src="/images/lectures.assets/image-20220814143235139.png" alt="image-20220814143235139" style="zoom:50%;"></p><p>把cm放进迷宫黑盒，我知道其中的cm的面额，然后转账出去</p><p>我们的BlockMaze</p><p>通过零知识证明保护的余额+以太坊的余额</p><p>两步转账的过程保证发送和接收方</p><p>发送方发送账户余额，金额是多少不知道，金额，默克尔树，证明在树上某一节点的主人就是发送方，接收方也从树中，通过零知识证明，接收货币</p><p>进去出去都是通过零知识证明来保护</p><p><img src="/images/lectures.assets/image-20220814143702661.png" alt></p><p><img src="/images/lectures.assets/image-20220814143757009.png" alt="image-20220814143757009"></p></blockquote><h5 id="BlockMaze数据结构"><a href="#BlockMaze数据结构" class="headerlink" title="BlockMaze数据结构"></a>BlockMaze数据结构</h5><p>对以太坊进行改造</p><blockquote><p><img src="/images/lectures.assets/image-20220814144018671.png" alt></p><p>每一个账户都有两类余额，明文 + 零知识状态的承诺值，承诺值计算参考图底部等式</p></blockquote><h5 id="BlockMaze-转账过程"><a href="#BlockMaze-转账过程" class="headerlink" title="BlockMaze 转账过程"></a>BlockMaze 转账过程</h5><p>先将500比特币转换为零知识状态，再从承诺状态转成300，多个交易的承诺状态的货币组成默克尔树，</p><p>接收方接收零知识状态的货币</p><blockquote><p><img src="/images/lectures.assets/image-20220814144312682.png" alt="image-20220814144312682"></p><p>步骤总结</p><p><img src="/images/lectures.assets/image-20220814144513694.png" alt="image-20220814144513694"></p><p>Mint是怎么做的</p><p>把明文余额转换成零知识状态的余额</p><p><img src="/images/lectures.assets/image-20220814144723948.png" alt="image-20220814144723948" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220814144846002.png" alt="image-20220814144846002" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220814144920337.png" alt="image-20220814144920337" style="zoom:50%;"></p><p><img src="/images/lectures.assets/image-20220814144932022.png" alt="image-20220814144932022" style="zoom:50%;"></p></blockquote><h5 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h5><p>目前零知识证明有很多现有的工具</p><blockquote><p><img src="/images/lectures.assets/image-20220814145211099.png" alt="image-20220814145211099"></p><p><img src="/images/lectures.assets/image-20220814145354611.png" alt="image-20220814145354611"></p><p><img src="/images/lectures.assets/image-20220814145739323.png" alt="image-20220814145739323"></p></blockquote><h5 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h5><blockquote><p>初秋<br>请问一下，方案存在监管机制或者说追溯不合法用户身份的机制吗</p><p>A：没有</p><p>孙玉红<br>请问万老师，send跟deposit需要保证一个转账的原子性吗？如何保证的，谢谢</p><p>A :没有</p></blockquote><h4 id="6-VOProof-Efficient-zkSNARKs-from-Vector-Oracle-Compilers-CCS-2022"><a href="#6-VOProof-Efficient-zkSNARKs-from-Vector-Oracle-Compilers-CCS-2022" class="headerlink" title="6-VOProof: Efficient zkSNARKs from Vector Oracle Compilers, CCS 2022"></a>6-VOProof: Efficient zkSNARKs from Vector Oracle Compilers, CCS 2022</h4><p>张云聪，上海交通大学博士生（没听懂啊啊）</p><p>zk-snarks 的</p><blockquote><p><img src="/images/lectures.assets/image-20220814150446521.png" alt="image-20220814150446521"></p></blockquote><p>常见的snark</p><blockquote><p><img src="/images/lectures.assets/image-20220814150555640.png" alt="image-20220814150555640"></p></blockquote><p>最近的工作</p><blockquote><p><img src="/images/lectures.assets/image-20220814150629240.png" alt="image-20220814150629240"></p></blockquote><p>snark的设计的基本步骤</p><blockquote><p><img src="/images/lectures.assets/image-20220814150702591.png" alt="image-20220814150702591"></p><p>目前对snark的研究大部分是在第二部分，以及设计第三部分协议的设计</p><p>constraint system有 ：RICS、HPR、PLONK</p><p>本文思路：在2、3部分中间引入VOP</p><p><img src="/images/lectures.assets/image-20220814151105078.png" alt="image-20220814151105078"></p><p><img src="/images/lectures.assets/image-20220814151055896.png" alt="image-20220814151055896"></p></blockquote><h4 id="7-Speeding-Dumbo-Pushing-Asynchronous-BFT-Closer-to-Practice-NDSS-2022"><a href="#7-Speeding-Dumbo-Pushing-Asynchronous-BFT-Closer-to-Practice-NDSS-2022" class="headerlink" title="7-Speeding Dumbo: Pushing Asynchronous BFT Closer to Practice, NDSS 2022"></a>7-Speeding Dumbo: Pushing Asynchronous BFT Closer to Practice, NDSS 2022</h4><p>路远，中科院软件所副研究员</p><p>区块链很神奇</p><blockquote><p><img src="/images/lectures.assets/image-20220814153431520.png" alt="image-20220814153431520" style="zoom:50%;"></p></blockquote><p>打开区块链的黑盒子</p><blockquote><p><img src="/images/lectures.assets/image-20220814153554860.png" alt="image-20220814153554860"></p><p>分布式交易的协议BA的变体</p><p><img src="/images/lectures.assets/image-20220814153705745.png" alt="image-20220814153705745"></p></blockquote><p>容忍错误BFT很重要</p><blockquote><p><img src="/images/lectures.assets/image-20220814153828611.png" alt="image-20220814153828611"></p><p><img src="/images/lectures.assets/image-20220814153902941.png" alt="image-20220814153902941"></p><p><img src="/images/lectures.assets/image-20220814154103414.png" alt="image-20220814154103414"></p><p><img src="/images/lectures.assets/image-20220814154242011.png" alt="image-20220814154242011"></p><p><img src="/images/lectures.assets/image-20220814154339757.png" alt="image-20220814154339757"></p><p><img src="/images/lectures.assets/image-20220814154430670.png" alt="image-20220814154430670"></p><p>最近有了突破性的进展</p><p>。。。省略很多</p><p><img src="/images/lectures.assets/image-20220814160154587.png" alt="image-20220814160154587"></p><p>共识机制</p></blockquote><h4 id="8-基于区块链的数字孪生中同步的可证数据持有-TIFS-2022"><a href="#8-基于区块链的数字孪生中同步的可证数据持有-TIFS-2022" class="headerlink" title="8-基于区块链的数字孪生中同步的可证数据持有,TIFS 2022"></a>8-基于区块链的数字孪生中同步的可证数据持有,TIFS 2022</h4><p>李甜，南京邮电大学博士生(没听懂)</p><p>数字孪生</p><blockquote><p><img src="/images/lectures.assets/image-20220814160653977.png" alt="image-20220814160653977"></p><p><img src="/images/lectures.assets/image-20220814161045225.png" alt="image-20220814161045225"></p><p><img src="/images/lectures.assets/image-20220814161055867.png" alt="image-20220814161055867"></p><p><img src="/images/lectures.assets/image-20220814161153408.png" alt="image-20220814161153408"></p></blockquote><h4 id="9-SPDL-A-Blockchain-enabled-Secure-and-Privacy-preserving-Decentralized-Learning-System-TC-2022"><a href="#9-SPDL-A-Blockchain-enabled-Secure-and-Privacy-preserving-Decentralized-Learning-System-TC-2022" class="headerlink" title="9-SPDL: A Blockchain-enabled Secure and Privacy-preserving Decentralized Learning System, TC 2022"></a>9-SPDL: A Blockchain-enabled Secure and Privacy-preserving Decentralized Learning System, TC 2022</h4><p>徐明辉，山东大学助理教授</p><p>nature`21 去中心化学习</p><blockquote><p><img src="/images/lectures.assets/image-20220814164049392.png" alt="image-20220814164049392"></p><p>又提到了环签名</p><p><img src="/images/lectures.assets/image-20220814164157158.png" alt="image-20220814164157158"></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>讲座</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fabric相关</title>
    <link href="/2023/01/04/fabric/"/>
    <url>/2023/01/04/fabric/</url>
    
    <content type="html"><![CDATA[<h6 id="关于MPT，merkle-proof"><a href="#关于MPT，merkle-proof" class="headerlink" title="关于MPT，merkle proof"></a>关于MPT，merkle proof</h6><p>merkle proof:快速判断两份大数据是否相同</p><p>生成一个merkle proof，即proof == sibling hashes along the search path，搜索路径上兄弟节点的hash值</p><p><img src="/images/fabric.assets/image-20221121112842291.png" alt="image-20221121112842291" style="zoom:50%;"></p><p><a href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/design/merkle_proof.html">https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/design/merkle_proof.html</a></p><p><a href="https://ethbook.abyteahead.com/ch4/mpt.html">https://ethbook.abyteahead.com/ch4/mpt.html</a></p><p><a href="https://blog.csdn.net/itleaks/article/details/79992072">https://blog.csdn.net/itleaks/article/details/79992072</a></p><p><a href="https://ethbook.abyteahead.com/ch4/merkle.html#">https://ethbook.abyteahead.com/ch4/merkle.html#</a></p><p><a href="https://zhuanlan.zhihu.com/p/46702178">https://zhuanlan.zhihu.com/p/46702178</a></p><p><a href="https://ethereum.stackexchange.com/questions/6415/eli5-how-does-a-merkle-patricia-trie-tree-work">https://ethereum.stackexchange.com/questions/6415/eli5-how-does-a-merkle-patricia-trie-tree-work</a></p><p><a href="https://medium.com/codechain/modified-merkle-patricia-trie-how-ethereum-saves-a-state-e6d7555078dd">https://medium.com/codechain/modified-merkle-patricia-trie-how-ethereum-saves-a-state-e6d7555078dd</a></p><p><img src="https://i.stack.imgur.com/YZGxe.png" alt="enter image description here"></p><h6 id="关于读写集语义"><a href="#关于读写集语义" class="headerlink" title="关于读写集语义"></a>关于读写集语义</h6><p>键的版本只记录在读集中；写集只包含键和交易设置的键的最新值。</p><p><code>提交节点</code> 使用读写集中的读集来验证交易，使用写集来更新受影响的键的版本和值</p><p>在更新阶段，会根据写集更新世界状态中对应的键的值。然后，世界状态中键的版本会更新到最新的版本。</p><p>执行交易验证时，对于某个更新操作，只有当读集版本号=世界状态版本号时，才会执行写集。写集每更新一个键值对，都会同时更新这一键值对的版本号。这一设计的目的在于保障同一区块中的多笔交易不会对世界状态产生重复操作(类似于Redis的乐观锁机制)。</p><p><a href="https://hyperledger-fabric.readthedocs.io/zh_CN/latest/readwrite.html">https://hyperledger-fabric.readthedocs.io/zh_CN/latest/readwrite.html</a></p><h6 id="为什么fabric要设计读写集？"><a href="#为什么fabric要设计读写集？" class="headerlink" title="为什么fabric要设计读写集？"></a>为什么fabric要设计读写集？</h6><p><a href="https://zhuanlan.zhihu.com/p/269434367">https://zhuanlan.zhihu.com/p/269434367</a></p><p>Fabric采用非常新颖的execute-order-validate模式（如下图所示），与当时绝大多数的区块链不同。简单来说，大多数区块链采用的是order-execute模式，客户端直接向共识节点发送交易，共识节点相互之间通信，先就交易的执行顺序达成共识，再分别在本地执行交易，改变状态。而Fabric的方法则是，首先由客户端将交易提交给背书节点（endorser），背书节点执行之后将会得到这笔交易的读写集，之后将执行结果返回给客户端，客户端将其发送给order节点，order节点负责给所有交易排序，打包成块后发送给peer节点，peer节点将负责交易的validate和commit。validate过程保证交易执行结果正确上链，例如：背书节点执行交易事实上是以并行的模式执行，在不同交易执行过程中，读写集可能会存在依赖关系，而order节点将交易强制改为串行执行，在轮到一些交易commit时，其依赖的读集已经被先前的交易修改过，有这样冲突的交易需要被重新执行，才能得到正确的读写集。</p><p><img src="/images/fabric.assets/image-20221120152325225.png" alt="image-20221120152325225"></p><h6 id="fabric论文翻译"><a href="#fabric论文翻译" class="headerlink" title="fabric论文翻译"></a>fabric论文翻译</h6><p><a href="https://boenn.github.io/2018/04/15/fabric%E6%95%B4%E7%90%86/">https://boenn.github.io/2018/04/15/fabric%E6%95%B4%E7%90%86/</a></p><h6 id="fabric设计哲学-Order-Execute-VS-execute-order-validate"><a href="#fabric设计哲学-Order-Execute-VS-execute-order-validate" class="headerlink" title="fabric设计哲学 Order-Execute VS execute-order-validate"></a>fabric设计哲学 Order-Execute VS execute-order-validate</h6><p><a href="https://htzkw.com/article/14084.html">https://htzkw.com/article/14084.html</a></p><p><a href="https://medium.com/bsos-taiwan/deep-dive-on-hyperledger-fabric-ed0c8578da2e">https://medium.com/bsos-taiwan/deep-dive-on-hyperledger-fabric-ed0c8578da2e</a></p><blockquote><p>少数执行，多数验证</p></blockquote><p><img src="/images/fabric.assets/image-20221120153201004.png" alt="image-20221120153201004"></p><p><img src="/images/fabric.assets/image-20221121100021249.png" alt="image-20221121100021249"></p><h6 id="fabric-交易过程"><a href="#fabric-交易过程" class="headerlink" title="fabric 交易过程"></a>fabric 交易过程</h6><p><a href="https://juejin.cn/post/6844904126308941838">https://juejin.cn/post/6844904126308941838</a></p><p><a href="https://juejin.cn/post/6844904113705074696">https://juejin.cn/post/6844904113705074696</a></p><p><a href="https://blog.csdn.net/qq_34611579/article/details/107015830">https://blog.csdn.net/qq_34611579/article/details/107015830</a></p><blockquote><p>1.peer 本地接收client请求，执行交易，生成读写集，发送给order</p><p>2.order排序，确定交易顺序，生成block发送回peer，</p><p>3.peer对交易进行验证，用有效的交易（的读写集）更新本地状态，无效的忽略，将block（无效有效都在block中）加到区块链末尾</p></blockquote><p><img src="/images/fabric.assets/image-20221121110203933.png" alt="image-20221121110203933"></p><p>论文fabric++</p><p><a href="https://dl.acm.org/doi/10.1145/3299869.3319883">https://dl.acm.org/doi/10.1145/3299869.3319883</a></p><blockquote><p><img src="/images/fabric.assets/image-20221121104851096.png" alt="image-20221121104851096"></p><p>1.模拟阶段：client 将某个交易提交给peer，可能要发给多个peer,peer根据背书策略在本地副本进行交易执行（并行），执行过程中记录读写集合，返回读写集 + 签名。若客户端收到多个读写集相等，则可以生成事务，发送给order节点</p><p>2.排序阶段：接收好多事务，建立全局顺序，基本上按照到达时间。打包后发送给所有peer,所有peer收到的块中的事务顺序都一样，但收到块的时间可能不一样</p><p>3.验证阶段：peer检查1.是否满足背书策略2.读写集合是否合法3.是否存在交易冲突，冲突的事务在模拟时已经被执行，标记为无效，等到同步时这个无效事务不会被记录</p><p>4.提交阶段：每个peer将根据块中有效事务更改本地世界状态</p></blockquote><h6 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h6><p><a href="https://juejin.cn/post/6844904126308941838">https://juejin.cn/post/6844904126308941838</a></p><h6 id="区块链扩容方案"><a href="#区块链扩容方案" class="headerlink" title="区块链扩容方案"></a>区块链扩容方案</h6><p>zk-rollup <a href="https://ethereum.org/en/developers/docs/scaling/zk-rollups/">https://ethereum.org/en/developers/docs/scaling/zk-rollups/</a></p><p><a href="https://support.token.im/hc/zh-tw/articles/900004123646-Vitalik-Rollup-%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97-%E7%B2%BE%E9%81%B8-">https://support.token.im/hc/zh-tw/articles/900004123646-Vitalik-Rollup-%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97-%E7%B2%BE%E9%81%B8-</a></p><p><img src="/images/fabric.assets/image-20221125145321862.png" alt="image-20221125145321862"></p><p><a href="https://blog.chain.link/blockchain-scalability-approaches-zh/">https://blog.chain.link/blockchain-scalability-approaches-zh/</a></p><p>以太坊扩容愿景:<a href="https://ethereum.org/en/developers/docs/scaling/">https://ethereum.org/en/developers/docs/scaling/</a></p><p>(强推)一看就懂的区块链扩容方案全解</p><p><a href="https://www.bitpush.news/articles/3004698">https://www.bitpush.news/articles/3004698</a></p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/458886840">https://zhuanlan.zhihu.com/p/458886840</a></p><p><img src="/images/fabric.assets/image-20221125151948016.png" alt="image-20221125151948016"></p></blockquote><h6 id="fabric中的“账户”"><a href="#fabric中的“账户”" class="headerlink" title="fabric中的“账户”"></a>fabric中的“账户”</h6><p><a href="https://blog.csdn.net/JohnnyMartin/article/details/104130239">https://blog.csdn.net/JohnnyMartin/article/details/104130239</a></p><h6 id="fabric最新中文文档"><a href="#fabric最新中文文档" class="headerlink" title="fabric最新中文文档"></a>fabric最新中文文档</h6><p><a href="https://hyperledger-fabric.readthedocs.io/zh_CN/latest/identity/identity.html">https://hyperledger-fabric.readthedocs.io/zh_CN/latest/identity/identity.html</a></p><h6 id="fabric如何部署智能合约"><a href="#fabric如何部署智能合约" class="headerlink" title="fabric如何部署智能合约"></a>fabric如何部署智能合约</h6><blockquote><p>fabric的智能合约并不是每个节点存储一份。和以太坊不同，需要涉及到通道的概念，之后再看。</p></blockquote><p>Fabric由客户端（Client）、对等节点（Peer）与排序服务（Ordering Service）这三种主要角色构成，它们会组成一个「通道」（Channel）并共同维护一份帐本，只有该通道的组成节点可以读取该帐本的资料。</p><p>组织使用链代码定义来就链代码的参数达成一致，然后才能在通道上使用它。每个想要使用链码来背书交易或查询分类帐的渠道成员都需要为其组织批准链码定义。一旦有足够多的通道成员批准了链码定义以满足生命周期认可政策（默认设置为通道中的大多数组织），<strong>链码定义就可以提交给通道</strong>。提交定义后，第一次调用链代码（或者，如果需要，执行 Init 函数）将在通道上启动链代码。</p><p><img src="/images/fabric.assets/image-20221123214105987.png" alt="image-20221123214105987"></p><blockquote><p><img src="/images/fabric.assets/image-20221122114005271.png" alt="image-20221122114005271"></p><p>只是在本地副本模拟，并生成读写集，所有的交易都有一个识别符、一个提案和一个被一群组织签名的响应。<strong>所有交易，无论是否有效，都会被记录在区块链上，但仅有效交易会更新世界状态。</strong></p><p><a href="https://hyperledger-fabric.readthedocs.io/zh_CN/latest/smartcontract/smartcontract.html">https://hyperledger-fabric.readthedocs.io/zh_CN/latest/smartcontract/smartcontract.html</a></p></blockquote><h6 id="可验证性计算"><a href="#可验证性计算" class="headerlink" title="可验证性计算"></a>可验证性计算</h6><p>TEE</p><blockquote><p><strong>可信执行环境，英文简称为TEE (Trusted Execute Environment)。</strong>根据“可信”的定义，可信执行环境指的是满足如下条件的程序执行平台：这个平台里的软硬件资源永远按照预期的方式工作，不会受平台控制者或者其它任何第三方的影响，这些资源包括了寄存器、内存、中断等。因为这些基本资源永远按照设计者预期工作，从而确保了在里面运行的程序行为的可控。</p></blockquote><p><a href="https://www.openmpc.com/article/368">https://www.openmpc.com/article/368</a></p><blockquote><p><strong>SGX的优势：</strong></p><ul><li>全加密，任何离开CPU寄存器的数据都会被自动、强制加密，CPU缓存以及物理内存内的数据都不例外。</li><li>不同 Enclave实例之间实现硬件隔离，不会相互影响。</li><li>多线程运行，可以充分发挥CPU的计算能力。</li><li>无需TEE OS，避免对OS依赖。</li><li>TEE和REE相互之间可主动向对方发起接口调用，全双工工作。</li><li>TEE和REE相互之间的调用由CPU硬件指令实现，无需依赖第三方模块。</li><li>TEE资源隶属于REE进程资源的一部分，遵循操作系统的进线程调度逻辑，可避免TEE抢占 CPU导致整体系统异常。</li><li>远程证明有CPU硬件支持，安全性高</li></ul><p><strong>SGX的劣势：</strong></p><ul><li>运行时会独占部分物理内存。</li><li>基于SGX架构，TEE内无法直接提供任何硬件IO的能力。</li><li>远程证明依赖Intel的证明服务，会有一定局限。</li><li>任何TEE程序要加载运行起来，需要Intel颁发的数字证书，有厂商依赖</li><li><img src="/images/fabric.assets/image-20221126170634371.png" alt="image-20221126170634371"></li></ul></blockquote><h6 id="区块链并发控制"><a href="#区块链并发控制" class="headerlink" title="区块链并发控制"></a>区块链并发控制</h6><p><a href="https://developer.aliyun.com/article/738930">https://developer.aliyun.com/article/738930</a></p><blockquote><p>以太坊不支持并发，fabric支持</p><ul><li>所有节点都需要更新账本，因此所有节点都需要执行验证步骤。 但并不是所有的节点都需要执行智能合约。Hyperledger Fabric 使用背书策略来定义哪些节点需要执行交易。这意味着指定的 链码（智能合约）不必开放给所有的节点 —— 那些不在背书策略中 的节点不需要由访问链码的权限。</li><li><img src="/images/fabric.assets/image-20221121102406691.png" alt="image-20221121102406691"></li><li><img src="/images/fabric.assets/image-20221122103402524.png" alt="image-20221122103402524"></li></ul></blockquote><h6 id="基于属性加密技术（Attribute-Based-Encryption-ABE）"><a href="#基于属性加密技术（Attribute-Based-Encryption-ABE）" class="headerlink" title="基于属性加密技术（Attribute-Based Encryption,ABE）"></a>基于属性加密技术（Attribute-Based Encryption,ABE）</h6><h6 id="链上数据的含义？世界状态存在区块链上吗？什么叫存在区块链上？"><a href="#链上数据的含义？世界状态存在区块链上吗？什么叫存在区块链上？" class="headerlink" title="链上数据的含义？世界状态存在区块链上吗？什么叫存在区块链上？"></a>链上数据的含义？世界状态存在区块链上吗？什么叫存在区块链上？</h6><p><a href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/articles/3_features/33_storage/data_chain_or_database.html">https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/articles/3_features/33_storage/data_chain_or_database.html</a></p><blockquote><p>链上数据是直接或间接由区块链共识产生的数据</p><p>数据都是存在本地数据库中</p><p>交易驱使状态改变</p></blockquote><h6 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h6><p>快照隔离</p><p><a href="https://0x98k.com/2020-09-29-db-transaction">https://0x98k.com/2020-09-29-db-transaction</a></p><p><a href="https://xie.infoq.cn/article/51925121bc6e2bf9620f46bff">https://xie.infoq.cn/article/51925121bc6e2bf9620f46bff</a></p><p><a href="https://blog.csdn.net/songchuwang1868/article/details/97630005">https://blog.csdn.net/songchuwang1868/article/details/97630005</a></p><p><a href="https://blog.csdn.net/qq_30154571/article/details/121891711">https://blog.csdn.net/qq_30154571/article/details/121891711</a></p><p>（强推）快照隔离解释：<a href="https://zhuanlan.zhihu.com/p/437847549">https://zhuanlan.zhihu.com/p/437847549</a></p><p><a href="https://zhuanlan.zhihu.com/p/440149077">https://zhuanlan.zhihu.com/p/440149077</a></p><p>raft协议</p><p><a href="https://www.cnblogs.com/xybaby/p/10124083.html">https://www.cnblogs.com/xybaby/p/10124083.html</a></p>]]></content>
    
    
    <categories>
      
      <category>blockchain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fabric</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Blockchain scaling</title>
    <link href="/2022/12/21/Blockchain%20scaling/"/>
    <url>/2022/12/21/Blockchain%20scaling/</url>
    
    <content type="html"><![CDATA[<h4 id="区块链扩展调研"><a href="#区块链扩展调研" class="headerlink" title="区块链扩展调研"></a>区块链扩展调研</h4><h5 id="Rollup"><a href="#Rollup" class="headerlink" title="Rollup"></a>Rollup</h5><p>rollup是区块链layer2扩容方案之一，rollup本质上是指一个单独的区块链，用以太坊为例，rollup受以太坊智能合约管理，rollup执行交易并处理数据，以太坊接收数据并存储结果，相当于以太坊的草稿纸。rollup计算快的原因在于它产生新区块的方式并不像传统区块链那么复杂，但以太坊可以<strong>审查</strong>其处理结果，所以可以保证安全性。「将智能合约计算移到链下，同时仅在链上存储尽可能少的交易数据。」在 Rollup 中，只有计算（数据处理）处于链下状态。Rollup 处理的每笔交易仍将其输入数据（正式名称为「调用数据」）存储在以太坊上。「审查过程」究竟如何运作取决于 Rollup 是 Optimistic 机制还是零知识机制。在rollup中，以太坊共识才是最终结果的仲裁者，rollup不需要共识机制，与之对比，侧链解决方案中侧链的交易可以是最终的。</p><p><a href="https://learnblockchain.cn/article/2392">https://learnblockchain.cn/article/2392</a></p><p>区块链性能提升方案</p><p>区块链1层网络：是指区块链基础网络，比特币、以太坊。</p><p>Layer 1 区块链旨在提供区块链的基本功能。任何区块链的主要目标都是优化去<em>中心化、安全性</em>和<em>可扩展性</em>。然而，这种平衡很难达到，这就是为什么将同时实现这三者的概念称为<strong>区块链三难困境</strong>。</p><p>早期的 L1 链（即比特币和以太坊）优先考虑去中心化和安全性，代价是网络随着采用率的提高<strong>而扩展</strong>的能力。这启发了 L1 开发人员要么修改他们的设计以优先考虑扩展，要么在“链下”开发其他解决方案。</p><p>L1 链可以通过调整其原生架构来提高扩展性的方式有限。这些包括：</p><ul><li><p><strong>增加块大小：</strong>块越大，每个块中可以“容纳”更多交易，从而提高网络速度。缺点是保护网络（<strong><a href="https://www.bitstamp.net/learn/crypto-101/what-are-bitcoin-blockchain-nodes/">节点</a></strong>）的计算机必须增加其硬件要求，这有集中化的风险。</p></li><li><p><strong>改变共识机制</strong>：依赖于权益证明 (PoS) 共识机制的区块链通常比基于工作量证明 (PoW) 的链更快且资源密集度更低。然而，一些人认为这是以低安全性和中心化为代价的。</p></li><li><p><strong>分片</strong>：第 1 层链可以将其数据<em>拆分</em>为预先指定数量的不同数据组件（称为<strong><a href="https://www.bitstamp.net/learn/blockchain/what-is-sharding-on-ethereum/">分片</a>）</strong>，从而帮助缓解网络拥塞并提高交易速度。然而，分片链之间的通信可能很复杂，导致区块链的安全性较差。</p></li></ul><p>第 1 层要素</p><ul><li>第 1 层指的是基础区块链，在该区块链上生成区块、完成交易，并使用原生加密货币硬币支付交易费用并奖励网络安全人员。最受欢迎的 L1 链是比特币和以太坊。</li><li>区块链三难困境指出，L1 链通常无法同时实现去中心化、安全性和可扩展性。因此，即使通过调整它们的架构，L1 也有很大的局限性。</li><li>像第 2 层解决方案这样的扩展解决方案旨在解决一些 L1 无法适应增加使用的问题。同时，第 0 层区块链为特定于应用程序的 L1 链提供平台，第 3 层指的是支持区块链互操作性的协议。</li></ul><p>2层综述：<a href="https://mp.weixin.qq.com/s/syovS0br4dMB9Ryf0EeFaQ">https://mp.weixin.qq.com/s/syovS0br4dMB9Ryf0EeFaQ</a></p><p>区块链扩展有很多角度可以考虑，大致分为以下几种</p><p><img src="/images/Blockchain scaling.assets/image-20221221164441931.png" alt="image-20221221164441931"></p><h5 id="1-Scalable-blockchains-—-A-systematic-review-综述"><a href="#1-Scalable-blockchains-—-A-systematic-review-综述" class="headerlink" title="1 Scalable blockchains — A systematic review 综述"></a>1 Scalable blockchains — A systematic review 综述</h5><p>将区块链扩展分为水平和垂直</p><p>horizontal (node and client scalability)<br>vertical (throughput, block generation rate, latency, and storage)scalability</p><p><img src="/images/Blockchain scaling.assets/image-20221222210944185.png" alt="image-20221222210944185" style="zoom:50%;"></p><p>被许可的区块链通常有三个主要特征，即治理结构、私有交易和认证过程。</p><p>不可能三角</p><blockquote><p>无限扩展：系统的输出能够随着节点数量的增加而增加。<br>去中心：所有节点的地位都是一致的，不假设某个或者某些节点比其他节点更有能力或者更为可信。<br>安全：对于中本聪共识，能够有1/2的容错；对于BFT共识，能有1/3的容错</p></blockquote><p>实际上，“诚实大多数”并不是天然成立的。但究竟诚实大多数的假设成立的条件是什么，<strong>怎样的激励机制才能在非许可的网络里保证诚实大多数</strong>，这个问题时至今日仍旧是共识算法研究的一个未解之谜。</p><h5 id="区块链分片（上中下）"><a href="#区块链分片（上中下）" class="headerlink" title="区块链分片（上中下）"></a>区块链分片（上中下）</h5><p><a href="https://mp.weixin.qq.com/s/5s_2JqOAol00t1MzPh_O7g">https://mp.weixin.qq.com/s/5s_2JqOAol00t1MzPh_O7g</a><br><a href="https://mp.weixin.qq.com/s/ujV18k14nP7sNxPJbJ1z_w">https://mp.weixin.qq.com/s/ujV18k14nP7sNxPJbJ1z_w</a><br><a href="https://mp.weixin.qq.com/s/Fs4cbZeegHtogPzozFYN8A">https://mp.weixin.qq.com/s/Fs4cbZeegHtogPzozFYN8A</a></p><p>根据网络分片，随机分片，根据应用分片，最后都会变成同样的问题，美国的节点可以不相信中国分片的验证结果。趋于中心化，这种自上而下的思路与区块链思想有悖。</p><p>打包者负责：其他分片算法中，小红只管将交易提交给矿工，矿工负责进行后续的步骤，包括在本分片达成共识，在跨片账本达成共识，并将共识的结果作为证据发给目标分片的验证节点，在目标分片达成共识。</p><p>交易者负责：这笔交易的发起者，也就是小红，<strong>有义务提供这个智能合约里面规定的证据来完成这笔交易</strong> （Chainspace）</p><p>在分片中如果只有提交的矿工（下图小刚）能够获得交易费，那么跨分片矿工（小兰，Bob）为啥要配合工作。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/UrYDA9tqpqWaXuRChBz3Wec4l1ZyOjlg6nW4agPJ4o6RNJJkL2Kqs6fj0CxAlTPtQEynMO1CD35aMrqwS4mumg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="Layer2-扩容方案对比"><a href="#Layer2-扩容方案对比" class="headerlink" title="Layer2 扩容方案对比"></a>Layer2 扩容方案对比</h4><ol><li><p>区块链去中心化的特性,使得存储和计算性能受限,需要进行扩容(Scaling)</p></li><li><p>扩容可以分为</p><ol><li><p>On- chain, Layer1。对区块链本身的性能提升.</p><ol><li><p>共识。中心化换性能。 Avalanche、 Solana。</p><blockquote><p>修改共识共识不像以太坊那样去中心化，雪崩协议</p></blockquote></li><li><p>Sharding. 分库分表、并行计算。ETH2.0、Near</p></li></ol></li><li><p>Off-chain, Layer2。链下计算，结果上链；离线批处理</p></li></ol></li><li><p>各种 Layer2扩容方案的区别主要在于其保证 State Validity(SV)和Data Availablility(DA)的方式不同</p><ol><li><p>SV，作恶</p><ol><li><p>如何保证 Layer2 State的正确:</p><blockquote><p>ZK Proof?？Fraud Proof？PoA多签？Light Cilent?</p></blockquote></li><li><p>防止Layer2的无效状态回传到主链</p></li><li><p>举例：Solana Wormhole Bridge漏洞，导致Solana上 WHETH被凭空增发,最终将 Ethereum上质押的ETH提走</p></li></ol></li><li><p>DA，跑路</p><ol><li><p>跑路如何保证 Layer2 State的持久化:存去中心化的 Layer1？存中心化的 Layer2？</p></li><li><p>防止Layer2停止维护数据丢失导致资产锁死</p></li><li><p>举例：StarkEx为State的存储方式提供多种选择</p><p><img src="/images/Blockchain scaling.assets/image-20221223152831558.png" alt="image-20221223152831558"></p></li></ol></li></ol></li></ol><h5 id="StateChannel"><a href="#StateChannel" class="headerlink" title="StateChannel"></a>StateChannel</h5><blockquote><p>安全性高，TPS一般，不支持智能合约，目前用的少</p><p><a href="https://www.nichanank.com/blog/2018/9/27/scalability-pt-2-state-channels-counterfactual-instantiation">https://www.nichanank.com/blog/2018/9/27/scalability-pt-2-state-channels-counterfactual-instantiation</a></p></blockquote><h5 id="Sidechain"><a href="#Sidechain" class="headerlink" title="Sidechain"></a>Sidechain</h5><ol><li><p>原理:Two-way- pegged Cross— chain bridge,主链质押 Token,侧链生成 Wrapped Token。主链Lock侧链Mint,侧链Bun主链 Withdraw。</p></li><li><p>DA &amp; SV</p><ol><li>DA:数据存在 Layer2,由侧链的 Validators保证DA</li><li>SV(多种方案安全性由强到弱)<ol><li>Light Client Bridge(例如Near的 Rainbow bridge):任何人可以将侧链的 State Root同步到主链,主链合约实现侧链的轻客户端，验证 State root保证SV</li><li>Plasma Bridge(例如 Polygon的):侧链 Validators定期将State root同步到主链,主链通过 Fraud proof保证SV</li><li>Multi- signature Bridge(大多数):桥的 Validators定期将State root 或Burn Event 同步到主链，主链检查多签保证SV</li></ol></li></ol></li></ol><blockquote><p>假设了Two-way-pegged Cross-chain Bridge的都可以视作侧链，用于通过Wrapped Token扩容主链的处理能力</p><p>侧链可以支持智能合约，TPS高</p></blockquote><h5 id="Rollup-1"><a href="#Rollup-1" class="headerlink" title="Rollup"></a>Rollup</h5><p><a href="https://blog.matter-labs.io/zkporter-a-breakthrough-in-l2-scaling-ed5e48842fbf">https://blog.matter-labs.io/zkporter-a-breakthrough-in-l2-scaling-ed5e48842fbf</a></p><ol><li><p>原理&amp;DA&amp;SV</p><ol><li><p>DA</p><ol><li><p>Rollup: Layer2的数据压缩后上传到 Layer1,由 Layer1保证DA</p><ol><li>Address用树上的序号表示</li><li>value用科学计数法表示</li><li>ZK  rollup省去前面，Optimistic Rollup 不省略</li></ol></li><li><p>Validium:数据不上传到 Layer1，由多个 Validator托管(其实属于 Sidechain类别,但由于是Rollup衍生出来的方案，所以大家更愿意与Rollup一起讨论比较)</p></li><li><p>Volition&amp; zkPorter:用户可以选择数据是否上传到 Layer1（比较贵）（上传以太坊或者自己维护的侧链）</p><p><img src="https://miro.medium.com/max/1050/0*kLYhO4auKt0hpKSf" alt="img"></p></li></ol></li><li><p>SV</p><ol><li>ZK Rollup:定期同步 State Root及其 Validity Proof(zK证明)到 Layer1, Layer1用合约验证 Proof保证SV</li><li>Optimistic Rollup:定期同步 State Root到 Layer1, Layer1通过 Fraud proof保证SV</li></ol></li></ol></li><li><p>项目：<a href="https://l2beat.com/">https://l2beat.com/</a></p></li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol><li>侧链是性能和兼容性最好的。虽然桥的安全性依赖于PoA,但是Validate通常大量持币,从经济角度保证了安全性。</li><li>Rollup因为其安全性高,成为了后起之秀。性能和兼容性尚可,需要继续开发以进一步优化。<ol><li>zkSync的 ZKEVM(兼容)</li><li>Ethereum社区的 ZKEVM(兼容),V神主导的 Sharding+ Rollup(性能</li><li>Stark Ware的caio(兼容)、 Starnet(性能)</li></ol></li><li>市场对扩容抱有很大的期待,可以预期还将继续诞生新的方案和项目,已有的项目会因为落地而迎来市场(比如开发中的这些)。</li></ol><p><a href="https://blog.chain.link/blockchain-scalability-approaches-zh/">https://blog.chain.link/blockchain-scalability-approaches-zh/</a></p><h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><p>以太坊上的游戏使得以太坊交易速度变慢</p><blockquote><p>One prominent example is the <strong>CryptoKitties</strong> game, which allows users to purchase, collect, breed, and sell virtual cats. The craze around the game was so intense that it has once managed to significantly slow down all transaction processing on Ethereum.</p><p> <a href="https://www.bbc.com/news/technology-42237162">https://www.bbc.com/news/technology-42237162</a>.</p></blockquote><p>研究以太坊智能合约的论文：<a href="https://link.springer.com/article/10.1007/s10664-019-09796-5">https://link.springer.com/article/10.1007/s10664-019-09796-5</a></p><p>谷歌big query上的以太坊数据集Ethereum dataset in Google BigQuery</p><p>以太坊浏览器：<a href="https://etherscan.io/">https://etherscan.io/</a></p><p>Dapp状态：<a href="https://www.dappt.io/">https://www.dappt.io/</a></p><p>代币市值：<a href="https://coinmarketcap.com/">https://coinmarketcap.com/</a></p><p>以太坊虚拟机：<a href="https://ethereum.org/zh/developers/docs/evm/">https://ethereum.org/zh/developers/docs/evm/</a></p><p>DAPP</p><blockquote><p>任何依赖一个或多个智能合约作为其后端的应用程序都被称为<em>去中心化应用程序</em>（ÐApp）。因此，ÐApps 与后端代码在中央服务器上运行的更传统的应用程序形成对比。ÐApps 的前端可以用任何编程语言实现。通常，它是结合 HTML5、CSS 和web3.js（以太坊的 Javascript API）来实现的。</p></blockquote><p>合约活跃性不平衡，每个合约对以太坊的影响不一样，比如CryptoKitties在某一时间吸引大量以太坊交易</p><blockquote><p>blockchain utilization fairness (e.g., preventing a single contract from utilizing most of the processing power of the blockchain).</p></blockquote><p>论文：Off-chaining Models and Approaches to Off-chain Computations</p><p>链下模型和链下计算方法</p>]]></content>
    
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读笔记</title>
    <link href="/2022/12/03/SE-note/"/>
    <url>/2022/12/03/SE-note/</url>
    
    <content type="html"><![CDATA[<h3 id="论文阅读笔记-VAL-Volume-and-Access-Pattern-Leakage-Abuse-Attack-with-Leaked-Documents-ESORICS’22）-5"><a href="#论文阅读笔记-VAL-Volume-and-Access-Pattern-Leakage-Abuse-Attack-with-Leaked-Documents-ESORICS’22）-5" class="headerlink" title="[论文阅读笔记]VAL: Volume and Access Pattern Leakage-Abuse Attack with Leaked Documents(ESORICS’22）[5]"></a>[论文阅读笔记]VAL: Volume and Access Pattern Leakage-Abuse Attack with Leaked Documents(ESORICS’22）[5]</h3><blockquote><p>论文题目：利用泄露文档进行基于访问和体积模式的推理攻击</p></blockquote><p>[TOC]</p><h3 id="1-研究背景"><a href="#1-研究背景" class="headerlink" title="1 研究背景"></a>1 研究背景</h3><h4 id="可搜索加密（Searchable-Encryption-SE）"><a href="#可搜索加密（Searchable-Encryption-SE）" class="headerlink" title="可搜索加密（Searchable Encryption, SE）"></a><strong>可搜索加密（Searchable Encryption, SE）</strong></h4><p>​        在云计算时代下，海量数据的存储和计算都能够交付给云端的算力。云端的开放和共享性给用户带来了很大的便利，节约了大量的资源和时间。但于此同时，数据的不断增加带来了不可避免的隐私问题。用户希望能够将数据交由云服务器存储和管理的同时又不向云服务器泄露任何与数据相关的信息。常见的方法就是将数据进行加密后上传，这样确实保护了隐私，但是对于在数据库中的搜索能力却下降了。为了解决这个问题，可搜索加密应运而生。<br>​    2000年Song(S&amp;P’2000)[1]等人提出<strong>可搜索加密（Searchable Encryption, SE）</strong></p><blockquote><p>S E: 将已加密数据文件存储在一个不可信服务器上，在对文件进行检索时，希望只获得包含某个特定关键词 w 的一部分文档。服务器可以在加密文件上进行查找并只返回可能包含关键词 w 的文档，而无法获得除此之外的其他信息。</p><p>总结：可搜索加密就是主要解决如何在密文中进行高效检索的问题。</p></blockquote><p>传统方案举例</p><ul><li>Alice 希望将文件存储到云服务器, 出于隐私需求, Alice 可以通过传统加密方式预先加密好的文件并上传, 但只有 Alice 拥有密钥；</li><li>当 Alice 希望查找含有某一关键词的文件时,由于服务器对密文一无所知, Alice 需要从服务器上下载全部文件并一一解密以获得想要的文件, 这一方式显然效率极低。</li><li>SE的工作就是保留加密数据的搜索功能，让Alice能在密文中直接检索</li></ul><p>SE 分类</p><blockquote><p>对称可搜索加密技术(Searchable Symmetric Encryption, SSE)<br>公钥可搜索加密技术(Public key Encryption with Keyword Search, PEKS)</p></blockquote><p>目前<strong>基于索引构建对称可搜索加密</strong>是一个主流的研究方案，基本流程如下图所示</p><ol><li>用户选择对称加密算法对文件进行加密，构建索引结构，保证索引对应加密文件，发送给服务器</li><li>用户生成查询陷门发送给服务器，服务器返回对应的密文</li><li>用户用自己的私钥进行解密，获得明文</li></ol><p><img src="/images/SE-note.assets/image-20221203164759260.png" alt="image-20221203164759260" style="zoom: 33%;"></p><h3 id="2-前置知识"><a href="#2-前置知识" class="headerlink" title="2 前置知识"></a>2 前置知识</h3><h4 id="Leakage-泄露"><a href="#Leakage-泄露" class="headerlink" title="Leakage 泄露"></a><strong>Leakage 泄露</strong></h4><p><strong>泄露</strong>就是用户在与服务器交互的过程中无意间透露的信息。如果该信息被统计分析，很可能造隐私泄露。</p><blockquote><p>可泄露的信息例如：用户发送的查询关键词，服务器返回的密文，以及二者之间的对应关系；用户查询某一关键词的频率；服务器返回密文的大小等等。</p></blockquote><p>泄露分为被动攻击/主动攻击</p><ul><li><p>被动攻击：服务器仅收集泄露文本、统计查询关键词等，监听用户和服务器的行为，试图窥探数据库信息-（推理攻击）</p></li><li><p>主动攻击：主动攻击者可以将带有选定关键词的文档上传到服务器，以匹配查询关键词-(文件注入攻击[2]/选择关键词[3])</p></li></ul><p>被动攻击又称为<strong>推理攻击</strong></p><blockquote><p>​        文献[3]首次介绍了一种基于一定先验知识、利用数据访问模式泄露实施的通用攻击模型。攻击过程实际上是将用户搜索时行为模式和搜索习惯作为服务器额外信息。如通过监视用户与服务器之间的数据交互，记录搜索结果集合与陷门之间进行频率统计分析，结合公开数据库信息或已泄露文档信息进行比较，从而推理出更多有用信息。实验结果表明，攻击恢复关键词的成功率能够达到60%～80%.</p><p>​        这种基于Leakage-Abuse思想的攻击，刘文心等人[4]将其统称为<strong>推理攻击</strong>。</p></blockquote><p><strong><em>这次要分享的论文关注的就是被动攻击，针对被动攻击，主要的方法就是对用户的行为模式进行监视，与已经公开的数据库进行对比分析。</em></strong></p><p> 被动攻击3种模式</p><blockquote><p>access pattern 访问模式 ：观察server对查询的响应-&gt;query → document identifier-&gt;服务器数据类型<br>search pattern 搜索模式：统计查询的频率<br>volume pattern 体积模式：观察server返回的密文文档的大小</p></blockquote><h4 id="Attack-攻击"><a href="#Attack-攻击" class="headerlink" title="Attack 攻击"></a><strong>Attack 攻击</strong></h4><p>前提：已经泄露的文件/关键词作为辅助知识</p><p>目标：将已知关键词与用户发送的查询陷门匹配 + 将已泄露文档与服务器响应的文档匹配</p><p>已有工作</p><blockquote><p>Islam等人：根据泄漏知识创建共出现矩阵，将查询映射到关键词<br>Cash等人：泄漏文件中的总出现次数，可以将查询匹配到特定的关键词<br>Blackstone等人：SubgraphVL攻击<br>Ning等人：LEAP(CCS’21)[7]攻击，结合IKK攻击的共出现矩阵+count攻击的唯一计数</p></blockquote><h3 id="3-关键技术内容"><a href="#3-关键技术内容" class="headerlink" title="3 关键技术内容"></a>3 关键技术内容</h3><h4 id="本文contribution"><a href="#本文contribution" class="headerlink" title="本文contribution"></a>本文contribution</h4><p><u><strong>在SE框架下，改进了LEAP 的匹配技术，设计了一种新的体积+访问模式的推理攻击(VAL-Attack)</strong></u></p><p><strong>VAL-attack 攻击策略</strong></p><h4 id="前提假设"><a href="#前提假设" class="headerlink" title="前提假设"></a><strong>前提假设</strong></h4><ol><li>假设泄漏级别为L2（泄露级别详见相关文献对比），即攻击者不知道查询关键词在文档响应中的频率或位置</li><li>假设攻击者可以访问SE方案中使用的所有查询和响应</li><li>攻击者可以访问存储在服务器上的一些未加密文件</li><li>攻击者无法访问任何现有的关键词匹配查询，只知道泄露文件中出现的关键词</li></ol><h4 id="攻击者目标"><a href="#攻击者目标" class="headerlink" title="攻击者目标"></a><strong>攻击者目标</strong></h4><p>1）将尽可能多的加密文档标识符与泄漏的文档匹配<br>2）将查询与关键词匹配，以便了解服务器上存储的内容</p><p><div>            <!--块级封装-->    <center>    <!--将图片和文字居中-->        符号定义    <!--标题-->        <br>        <!--换行-->    <img <img src="/images/SE-note.assets/image-20221204113913812.png" alt style="zoom:50%;">    </center></div></p><h4 id="攻击步骤-3步"><a href="#攻击步骤-3步" class="headerlink" title="攻击步骤(3步)"></a>攻击步骤(3步)</h4><blockquote><ol><li><p>准备两个字典（存储匹配的文档 + 存储匹配的关键词）</p></li><li><p>攻击者构建矩阵AB</p><script type="math/tex; mode=display">  A（m^′×n^′），B (m×n) (m^′≤m,n^′≤n)</script></li><li><p>开始匹配（递归地在A、B矩阵中不断寻找映射，找到后存入1的字典）</p></li></ol></blockquote><ol><li><p>准备两个字典（存储匹配的文档 + 存储匹配的关键词）</p></li><li><p>攻击者构建矩阵AB</p><script type="math/tex; mode=display">A（m^′×n^′），B (m×n) (m^′≤m,n^′≤n)</script></li><li><p>开始匹配（递归地在A、B矩阵中不断寻找映射，找到后存入1的字典）</p></li></ol><h5 id="一、准备字典-构建攻击矩阵"><a href="#一、准备字典-构建攻击矩阵" class="headerlink" title="一、准备字典 + 构建攻击矩阵"></a>一、准备字典 + 构建攻击矩阵</h5><p><div>            <!--块级封装-->    <center>    <!--将图片和文字居中-->    <img src="/images/SE-note.assets/fig1.png" alt="构建矩阵" style="zoom: 33%;">    <br>        <!--换行-->    攻击矩阵A B    <!--标题-->    </center></div></p><blockquote><p>A矩阵是$m’行n’列，d1,,,dn’表示泄露文档，w1,,,,wm’表示关键词$<br>B矩阵是$m行n列，ed1,,,edn表示密文，q1,,,,qm表示查询令牌$<br>由于泄露文档只是服务器存储所有密文的一部分 $m’&lt;=m,n’&lt;=n$<br>$M 和 M$’ 是对称矩阵，分别由$A^T \cdot A,B^T \cdot B $计算而来，其数值含义是泄露文档(密文)i和j中共同出现的关键词(查询陷门)的个数</p></blockquote><h5 id="二、开始匹配（5步）"><a href="#二、开始匹配（5步）" class="headerlink" title="二、开始匹配（5步）"></a>二、开始匹配（5步）</h5><h6 id="1-用唯一列总和来匹配文档"><a href="#1-用唯一列总和来匹配文档" class="headerlink" title="1 用唯一列总和来匹配文档"></a>1 用唯一列总和来匹配文档</h6><p>（与Count attack [6]中的技术类似）<br>Count attack 计数攻击：假设攻击者已知每个keyword w,对应在数据集中匹配的文档数量count(w)如果某一查询 q 对应唯一的count(q)，且存在count(w)==count(q),则查询q匹配关键词w</p><p><div>            <!--块级封装-->    <center>    <!--将图片和文字居中-->    <img src="/images/SE-note.assets/fig2.png" alt style="zoom: 33%;">    </center></div><br>统计矩阵A、B中的每一列的列总和，根据矩阵A B 内容的含义（为1表示该关键词在某文档中出现过），列总和就是统计某一泄露文档/密文中的关键词/查询陷门的个数，如果A矩阵的某个列总和是唯一的，并且B中也有，那么这个泄露文档和该密文可以匹配。</p><h6 id="2-根据体积-关键词数量匹配文档"><a href="#2-根据体积-关键词数量匹配文档" class="headerlink" title="2 根据体积 + 关键词数量匹配文档"></a>2 根据体积 + 关键词数量匹配文档</h6><p>每个文档有两个属性：关键词数量 +文档大小</p><p><div>            <!--块级封装--> <center>    <!--将图片和文字居中--> <img src="/images/SE-note.assets/fig3.png" alt style="zoom: 100%;"> </center></div><br>1）若服务器上密文(|edj|, vj)的组合是唯一的，并且泄漏文件中存在该组合，则密文edj与泄露文件dj匹配</p><p><div>            <!--块级封装--> <center>    <!--将图片和文字居中--> <img src="/images/SE-note.assets/fig4.png" alt style="zoom: 100%;"> </center></div><br>2）若1）中组合不唯一，进一步根据关键词进行匹配（假设Acr/Bcr的行根据已经匹配的关键词排序，但初始阶段还不存在已经匹配的查询和关键词，故该步骤之后再运行）<br>分析：比如在泄露文件中大小和关键词的组合是[120，15]，如果这个组合是唯一的并且在服务器文件中也有[120，15]那么这两个文件可以匹配，如果不唯一，如上图，有好几个相同的模式，那我们就按照关键词进行匹配，对应列的每一位都要匹配才能将两个文件匹配，不过前提是行已经是匹配后的关键词和查询，但目前还没有匹配过，该步骤之后会重新调用。</p><h6 id="3-根据共出现矩阵匹配文档"><a href="#3-根据共出现矩阵匹配文档" class="headerlink" title="3 根据共出现矩阵匹配文档"></a>3 根据共出现矩阵匹配文档</h6><p><img src="/images/SE-note.assets/fig5.png" alt style="zoom: 33%;"></p><p>$M、M’$的含义是共同出现的关键词的数量，现在若有一个未匹配的密文edx,和一个未匹配的泄露文档dy, 我们先在共出现文档中找到已经匹配的文档，比如d2和ed2匹配，那我们分别检查dy和d2的共出现值，看它是不是和ed2与edx一致，如果一样，则继续用下一对一句匹配的文档，总结来说就是看这两个文档相对于已经匹配的文档的共出现值是否完全一样，如果一样，说明这两个文档匹配。</p><h6 id="4-匹配关键词"><a href="#4-匹配关键词" class="headerlink" title="4 匹配关键词"></a>4 匹配关键词</h6><p><img src="/images/SE-note.assets/fig6.png" alt style="zoom: 45%;"></p><p>从A，B矩阵中提取出已经匹配t个的文档，一一对应排列（矩阵$A_c,B_c$），观察每一行，如果存在唯一行，则关键词和查询可以匹配，如果不唯一，进一步分析。<br><img src="/images/SE-note.assets/image-20221208142713198.png" alt="image-20221208142713198"><br>举例子如上图。</p><ul><li>在矩阵 $B_c$中$q_3$有唯一的行，且$A_c$中有对应的一行$w_1$，则查询$q_3$就和$w_1$匹配</li><li>像$q_1,q_2$对应$w_2,w_m$，不唯一，则计算一下行总和，行总和反应了该关键词在文档中出现的次数，一般来说应该是在服务器文档中出现的次数较多，此时$q_2＜{w_m}’ $, 所以$q_1$匹配${w_m}’$<h6 id="5-根据已经匹配的关键词匹配文档"><a href="#5-根据已经匹配的关键词匹配文档" class="headerlink" title="5 根据已经匹配的关键词匹配文档"></a>5 根据已经匹配的关键词匹配文档</h6><img src="/images/SE-note.assets/fig7.png" alt style="zoom: 45%;"></li></ul><p>第5步是从A，B矩阵中提取已经匹配的t个关键词的行，然后查找唯一列，从而继续匹配文档</p><h6 id="整体算法"><a href="#整体算法" class="headerlink" title="整体算法"></a><strong>整体算法</strong></h6><p><img src="/images/SE-note.assets/fig8.png" alt style="zoom: 45%;"><br>总体算法过程以及其简短描述如上图，整个过程其实就是在找<strong>某一种唯一模式，或者模式组合，试图匹配更多的文档和关键词，并且之前匹配得到的信息作为之后匹配的基础知识，然后不断迭代直到不再有新的匹配出现。</strong></p><h3 id="4-实验分析"><a href="#4-实验分析" class="headerlink" title="4 实验分析"></a>4 实验分析</h3><p><strong>数据集</strong><br>Enron数据集-收集150个用户发送的邮件文件夹- 30109封电子邮件<br>Lucene邮件列表- 2002-2011年Lucene项目中的“java用户”邮件列表- 50,667个文档<br>Wiki百科文章<br><strong>预处理</strong>：提取邮件标题关键字、收件人姓名等，用python中NLTK语料库提取关键字集合（5000）<br><strong>初始数据</strong><br>服务器文件n – 数据集的文件<br>关键字m-5000个关键字集合<br>攻击者仅知道$n^′$个泄露文件（由泄露百分比决定）<br>以此构建矩阵$A（m^′×n^′），B (m×n) (m^′≤m,n^′≤n)$<br><strong>实验设置</strong><br>选择0.1%，0.5%，1%，5%，10%，30%作为泄漏百分比<br>选择较低的百分比与LEAP攻击的结果进行比较<br><img src="/images/SE-note.assets/image-20221208151156960.png" alt="image-20221208151156960" style="zoom:50%;"><br><img src="/images/SE-note.assets/image-20221208151219848.png" alt="image-20221208151219848" style="zoom:50%;"><br><strong>实验结果</strong><br>1）泄漏百分比达到5%VAL - attack 文件恢复率 98% 关键词恢复率93%<br>2）Enron 泄露百分比为10%即3010个文件，4962个关键词匹配2950个文件（98%）和4909个查询（99%）<br><img src="/images/SE-note.assets/image-20221208162407516.png" alt="image-20221208162407516" style="zoom:50%;"><br><img src="/images/SE-note.assets/image-20221208162428503.png" alt="image-20221208162428503" style="zoom:50%;"><br><strong>对比实验</strong><br>LEAP and SubgraphVL是目前性能最好的攻击，实验与二者进行对比，在文档恢复上性能比较好，但在关键词恢复上差别不是很大。<br><strong>对抗性能</strong><br><img src="/images/SE-note.assets/image-20221208162850548.png" alt="image-20221208162850548" style="zoom: 50%;"><br>对抗策略：推理攻击主要就是利用文档关键词、大小等匹配。所以防范的最直接的思路就是体积隐藏，填充和混淆。利用体积隐藏，通过体积填充的手段让服务器返回的密文看上去大小无差别；或者利用假的查询令牌进行混淆。以上几种方式能够很好的防范推理攻击，但是体积隐藏（浪费存储空间）和混淆（过滤假令牌）会花费更多存储开销和计算。如上表所示，在单一对策下，val-attack仍然可以恢复大部分文档，但是在组合的对策下就几乎恢复不了文档。</p><h3 id="5-相关文献分析"><a href="#5-相关文献分析" class="headerlink" title="5 相关文献分析"></a>5 相关文献分析</h3><h4 id="泄露级别L1-L4"><a href="#泄露级别L1-L4" class="headerlink" title="泄露级别L1~L4"></a>泄露级别L1~L4</h4><p>2015David (CCS’15)[6]将泄露级别分为四种等级L1~L4<br><img src="/images/SE-note.assets/image-20221216213758042.png" alt="image-20221216213758042" style="zoom: 33%;"><br>L4：泄露keyword出现总数，按照文档位置<br>L3：泄露了keyword出现的频率，因为附加了关键词<br>L2：泄露每个keyword在文档中泄露的频率，但不按照文档顺序<br>L1：更复杂混淆机制，提供更强安全，只泄露已经被搜索过的<br>什么类型的SE会有L2泄露——EDESE，其特点：密文 + keyword ,上传到服务器</p><blockquote><p>EDESE 可搜索加密方案：ShadowCrypt利用了一种名为“高效可部署、高效可搜索加密”(EDESE)的加密方法，它的特点是<strong>将加密令牌和密文绑定</strong></p></blockquote><h4 id="IKK-Attack-NDSS’12-8"><a href="#IKK-Attack-NDSS’12-8" class="headerlink" title="IKK Attack(NDSS’12)[8]"></a>IKK Attack(NDSS’12)[8]</h4><p>提出SE可以借助足够的先验知识而被破解，即首次提出根据泄露进行推理攻击。</p><ul><li>对SE的首次成功实验攻击</li><li>查询恢复攻击</li><li>L1泄漏 &amp;（几乎）完整文档知识&amp;部分查询知识<h4 id="Count-Attack-CCS’15-6"><a href="#Count-Attack-CCS’15-6" class="headerlink" title="Count Attack (CCS’15)[6]"></a>Count Attack (CCS’15)[6]</h4></li><li>查询恢复攻击</li><li>L1泄漏部分文档知识<h4 id="LEAP-SIGSAC’21-7"><a href="#LEAP-SIGSAC’21-7" class="headerlink" title="LEAP(SIGSAC’21)[7]"></a>LEAP(SIGSAC’21)[7]</h4>LEAP –  针对EDESE方案提出一种新的推理攻击，构建攻击矩阵A ,B，并递归匹配</li><li>查询恢复攻击&amp;文档恢复攻击</li><li>L2泄漏&amp;部分文档知识<br>攻击假设：假设攻击者遵循EDESE加密（关键字使用带密钥的伪随机函数作为查询令牌进行加密，并附加到存储在服务器端的加密文档中。）<br>查询过程：</li></ul><ol><li>用户生成查询令牌，并向服务器发送包含查询令牌的查询请求;</li><li>服务器返回与查询请求中的查询令牌一起附加的加密文档；</li><li>由1、2可得 (1)加密的文档 + 查询令牌集合；(2)每个加密文档和每个查询令牌之间的关系，即查询令牌是否包含在加密文档中。<h3 id="6-总结思考"><a href="#6-总结思考" class="headerlink" title="6 总结思考"></a>6 总结思考</h3>&gt;<br>Count攻击：查询返回的文件数<br>SubgraphVL :唯一文件体积<br>LEAP攻击 ：共出现、查询返回文件数<br>Score ：score-attack 相似文档 + 关键词频率<br>Search14 ：搜索模式，发送到服务器的查询的频率模式<br>VAL-attack: 访问 + 体积 + 相似文件<br>&gt;<br><img src="/images/SE-note.assets/image-20221208202313623.png" alt="image-20221208202313623"><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4>2000年Song提出可搜索加密的概念，自被提出后，研究者们就致力于为数据库搜索的安全性提出新的攻击和防御方案。期间产生了前向安全和后向安全的可加密搜索方案，特别是在云计算广泛应用的当下，保证数据库的安全和用户隐私成为了亟待解决的课题。2012年针对可搜索加密的推理攻击被提出，这种利用先验知识的推理攻击被实验证明只要能够获得足够的先验知识（泄露的密文或者关键词），就能很大程度上恢复文档和关键词。随后在推理攻击的思想下，诞生了以上的攻击方案。研究者们在不断的探究可能的攻击方案/对应的解决方案的过程中，进一步推动数据库可加密搜索的安全性保证。本文的VAL-Attack基于前人的工作，特别是LEAP的思路，进一步提出了一个体积+关键词数量的组合模式，考虑了更全面的匹配方法，在文档恢复上取得了性能提升。更全面的攻击组合意味着更大的防范开销，给可搜索加密的安全提供了更完善的思路。<h4 id="论文优缺点"><a href="#论文优缺点" class="headerlink" title="论文优缺点"></a>论文优缺点</h4>这篇论文的优点是表达清晰，idea简洁；缺点是其攻击思路大体借鉴LEAP的论文（攻击矩阵AB），主要贡献是对LEAP进行了改进，没有源代码。<h4 id="个人想法"><a href="#个人想法" class="headerlink" title="个人想法"></a>个人想法</h4>对于推理攻击，核心思路是根据先验知识匹配泄露文档，目前已有的方案大多初始匹配是都带有一点猜测和概率匹配的做法，并且一般泄露文档相比于服务器密文来说数据量较少。思考是否能利用机器学习的相关算法，学习用户的访问特征等方法进行用户匹配等。可搜索加密不止在泄露文档上会被恶意方利用，在访问控制，服务器共谋等各个场景都存在着安全隐患，在可搜索加密领域还有许多工作可以做，尽可能考虑更多的安全威胁。</li></ol><h3 id="7-参考文献"><a href="#7-参考文献" class="headerlink" title="7 参考文献"></a>7 参考文献</h3><p>[1] <a href="https://ieeexplore.ieee.org/abstract/document/848445">Song D X, Wagner D, Perrig A. Practical techniques for searches on encrypted data[C]//Proceeding 2000 IEEE symposium on security and privacy. S&amp;P 2000. IEEE, 2000: 44-55.</a><br>[2] <a href="https://eprint.iacr.org/2016/172.pdf">ZHANG Yupeng, KATZ J, and PAPAMANTHOU C. All your queries are belong to us: The power of file-injection attacks on searchable encryption[C]. The 25th USENIX Security Symposium, Washington, USA, 2016: 707–720</a><br>[3] <a href="https://pdfs.semanticscholar.org/f78e/9ccbc823e3c82256035037d4cab6f7128f1e.pdf">Islam M S, Kuzu M, Kantarcioglu M. Access pattern disclosure on searchable encryption: ramification, attack and mitigation[C]//Ndss. 2012, 20: 12.</a><br>[4] <a href="http://jcs.iie.ac.cn/xxaqxb/ch/reader/create_pdf.aspx?file_no=20210205">刘文心, 高莹. 对称可搜索加密的安全性研究进展[J]. 信息安全学报, 2021, 6(2): 73–84. doi: 10.19363/J.cnki.cn10-1380/tn.2021.03.05.</a><br>[5] <a href="https://link.springer.com/chapter/10.1007/978-3-031-17140-6_32">Lambregts S, Chen H, Ning J, et al. VAL: Volume and Access Pattern Leakage-Abuse Attack with Leaked Documents[C]//European Symposium on Research in Computer Security. Springer, Cham, 2022: 653-676.</a><br>[6] <a href="https://doi.org/10.1145/2810103.2813700">Cash, D., Grubbs, P., Perry, J., Ristenpart, T.: Leakage-abuse attacks against searchable encryption. In: Ray, I., Li, N., Kruegel, C. (eds.) ACM CCS 2015, pp.668–679. ACM (2015).</a><br>[7] <a href="https://dl.acm.org/doi/abs/10.1145/3460120.3484540">Ning J, Huang X, Poh G S, et al. Leap: Leakage-abuse attack on efficiently deployable, efficiently searchable encryption with partially known dataset[C]//Proceedings of the 2021 ACM SIGSAC Conference on Computer and Communications Security. 2021: 2307-2320.</a><br>[8] <a href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=961487973d4b33f96406fddbfcf1235dc587571f">M. S. Islam, M. Kuzu, and M. Kantarcioglu. Access pattern disclosure on searchable encryption: Ramification, attack and mitigation. In 19th Annual Network and Distributed System Security Symposium, NDSS 2012. The Internet Society, 2012.</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VPP</title>
    <link href="/2022/11/28/VPP/"/>
    <url>/2022/11/28/VPP/</url>
    
    <content type="html"><![CDATA[<h4 id="VPP概念"><a href="#VPP概念" class="headerlink" title="VPP概念"></a>VPP概念</h4><h5 id="日本东芝VPP"><a href="#日本东芝VPP" class="headerlink" title="日本东芝VPP"></a>日本东芝VPP</h5><p><a href="https://www.global.toshiba/ww/products-solutions/renewable-energy/products-technical-services/vpp.html">https://www.global.toshiba/ww/products-solutions/renewable-energy/products-technical-services/vpp.html</a></p><blockquote><p>自东日本大地震以来，依赖大型发电厂的传统能源供应系统受到挑战，太阳能和风力等可再生能源等分布式能源的普及率不断提高。由于可再生能源的发电量在很大程度上取决于天气，因此随着其使用的扩大，能源供应将变得不稳定。能源服务的新概念作为维护电力供应稳定的解决方案而来。这意味着，例如，分布式电源和蓄电池等分散能源可以通过远程控制物联网设备和功能就好像它们是一个发电厂一样。</p><p>因此，需要根据不断变化的供需情况，实时控制分布在多个地域的发电和储能设施。为此，需要有优秀的远程控制分散设备的技术和更准确地预测电力需求和太阳能发电的技术。通过调整供需平衡VPP，可再生能源电力可以稳定使用。VPP预计将促进可再生能源的引入和扩展，并为脱碳社会做出贡献。</p></blockquote><h5 id="一文读懂虚拟电厂"><a href="#一文读懂虚拟电厂" class="headerlink" title="一文读懂虚拟电厂"></a>一文读懂虚拟电厂</h5><p><a href="https://m.in-en.com/article/html/energy-2315074.shtml">https://m.in-en.com/article/html/energy-2315074.shtml</a></p><blockquote><p>国内正处于新老电力系统的转型期，市场主体将从单一化向多元化转变，电力输送将从“发输配用”向“源网荷储”转变。尤其是双碳目标的确立后，分布式能源和储能的加入，让原有的电力系统变得更加复杂。而虚拟电厂就是一种相对省钱的解决思路。</p></blockquote><h5 id="Next-Kraftwerke-德国-大型的虚拟电厂运营商"><a href="#Next-Kraftwerke-德国-大型的虚拟电厂运营商" class="headerlink" title="Next Kraftwerke 德国-大型的虚拟电厂运营商"></a>Next Kraftwerke 德国-大型的虚拟电厂运营商</h5><p>虚拟电厂 (VPP) 是一个由分散式中型发电机组以及灵活的电力消费者和存储系统组成的网络。</p><p><a href="https://www.next-kraftwerke.com/knowledge/what-is-a-virtual-power-plant">https://www.next-kraftwerke.com/knowledge/what-is-a-virtual-power-plant</a></p><p><a href="https://www.next-kraftwerke.com/vpp/virtual-power-plant">https://www.next-kraftwerke.com/vpp/virtual-power-plant</a></p><blockquote><p>根据特定的市场环境，VPP 可以完成一系列任务。一般而言，目标是将风电场、太阳能公园和热电联产 (CHP) 装置等分布式能源资源联网，以监控、预测、优化和交易它们的电力。这样，可再生能源发电的波动可以通过增加和减少可控单元的发电量和功耗来平衡。但 VPP 不仅有助于稳定电网。它还为将可再生能源纳入市场创造了先决条件。<strong>个别小型工厂通常无法提供平衡服务或在电力交换方面提供灵活性。这是因为他们的发电概况差异太大，或者他们根本不符合市场的最低出价规模。</strong></p><p>该方案用中央控制系统来管理各方接入VPP</p><p><img src="/images/VPP.assets/image-20221215204829215.png" alt="image-20221215204829215"></p><p>设备如何加入VPP？</p><p><img src="/images/VPP.assets/image-20221215204943405.png" alt="image-20221215204943405"></p><p><img src="/images/VPP.assets/image-20221215205008799.png" alt="image-20221215205008799"></p></blockquote><h4 id="VPP目的"><a href="#VPP目的" class="headerlink" title="VPP目的"></a>VPP目的</h4><ul><li>小单位也能进入交易市场</li><li>风力、太阳发电等不规则电能，平衡电力市场（新能源加入发电侧）</li><li>保持整个电网，电流，电压的稳定，特别是日夜差异大（用电侧和发电侧均有波峰和波谷）</li><li>供给侧：发电量预测； 需求侧：控制平台</li></ul><h4 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h4><p><img src="/images/VPP.assets/image-20221216193150483.png" alt="image-20221216193150483"></p><p><img src="/images/VPP.assets/image-20221216193449378.png" alt="image-20221216193449378"></p><p><img src="/images/VPP.assets/image-20221216193623144.png" alt="image-20221216193623144"></p><p><a href="https://www.sciencedirect.com/science/article/pii/S0743731520303609">智能电网中基于区块链和ABE实现高效、隐私保护的能源交易</a> <strong>CCF B</strong></p><p>On Holistic Multi-Step Cyberattack Detection via a Graph-based Correlation Approach<a href="https://arxiv.org/pdf/2211.10971.pdf">https://arxiv.org/pdf/2211.10971.pdf</a></p><p>上下文检测涉及聚合来自各种来源（例如 IDS、防火墙等）的数据（例如，日志和事件数据），将数据规范化为通用格式，最后同步相关事件字段（例如时间戳）以进行进一步的数据处理并用于执行警报关联 [18]、[19]。除了数据收集之外，攻击建模对于上下文检测也很重要。对多阶段攻击建模的一种常见方法是创建其攻击图表示。它能够通过对攻击相关数据的关联和推理来提取上下文信息，以分类或推断攻击中涉及的实体之间的特征和关系 [20]。</p><p>国外VPP项目：<a href="https://www.solarquotes.com.au/battery-storage/vpp-comparison/">https://www.solarquotes.com.au/battery-storage/vpp-comparison/</a></p><h4 id="VPP-安全motivation"><a href="#VPP-安全motivation" class="headerlink" title="VPP 安全motivation"></a>VPP 安全motivation</h4><ol><li>针对新型电力系统应用场景，缺乏满足虚拟电厂海量终端轻量化使用需求的国产自主安全可控加密芯片；安全防护装置方面，安全防护装置属于硬加密方式，安全性高，但是种类繁多，不能在众多厂家设备之间形成统一标准，无法大规模应用。《面向区域统一电力市场的超大城市虚拟电厂关键技术研究综述》</li><li><p><img src="/images/VPP/image-20230305153701256.png" alt="image-20230305153701256"></p></li><li><p>虚拟电厂终端接入方式多样且计算资源有限，实时安全接入认证技术难度大，解决办法是基于AI的终端软硬件指纹生成技术和基于加密算法指令集优化的高效身份认证技术。VPP多方电力交易海量用户数据实时采集，业务共享，在保护隐私的基础上不影响VPP电厂数据的可用性。</p></li><li>用户画像，数据脱敏，动态聚合</li><li>虚拟电厂（VPP）是现代通信系统和智能技术的加持下微电网的一种变革形式。对于某些微电网，运营商必须应对DER问题[178]。VPP将所有DER集成到电网中，而不损失网络效率和弹性，为客户、生产商和电网运营商提供了许多新的优势和激励[179]。VPP是一个基于软件的智能电网网络，用于远程和自动发送和优化分布式能源（DER）。</li><li>VPP 会聚合不同类型的分布式发电技术，可再生能源风能水能太阳能等不可调度，所以需要存储设施。存储技术在平衡供应方面发挥着至关重要的作用，液压抽水蓄能、超导磁能、飞轮蓄能。(削峰填谷) VPP 通信技术。《Energy Sustainability–Survey on Technology and<br>Control of Microgrid, Smart Grid and Virtual Power Plant》</li></ol><p>数据安全：交易数据，用户数据</p><p>存储安全：数据共享，长期数据收集</p><p>防攻击安全：</p><p>访问安全：</p><p>DERs管理安全：</p>]]></content>
    
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常驻学习</title>
    <link href="/2022/11/20/%E8%87%AA%E4%B9%A0%E5%AE%A4/"/>
    <url>/2022/11/20/%E8%87%AA%E4%B9%A0%E5%AE%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="2022-常驻-关键词"><a href="#2022-常驻-关键词" class="headerlink" title="2022/常驻  关键词"></a>2022/常驻  关键词</h3><p>web3 </p><p>nft</p><p>侧信道</p><p>IP spoofing</p><p>schnorr</p><p>EDCSA （椭圆曲线数字签名算法）</p><p>MtA （Message Transfer Agent）</p><p>UC模型</p><h6 id="零知识证明"><a href="#零知识证明" class="headerlink" title="零知识证明"></a>零知识证明</h6><p><a href="https://zhuanlan.zhihu.com/p/152065162">https://zhuanlan.zhihu.com/p/152065162</a></p><p><a href="https://www.jianshu.com/p/7b772e5cdaef">https://www.jianshu.com/p/7b772e5cdaef</a></p><p>交互式：零知识证明是一种基于概率的验证方式，验证者（<code>verifier</code>）基于一定的随机性向证明者（<code>prover</code>)提出问题，如果证明者都能给出正确回答，则说明证明者大概率拥有他所声称的“知识”。零知识证明并不是数学意义上的证明，因为它存在小概率的误差，欺骗的证明者有可能通过虚假的陈诉骗过验证者。换句话说，零知识证明是概率证明而不是确定性证明，但是也存在技术能将误差降低到可以忽略的值。</p><p>“零知识证明利用了类似这种电路机制来创建证明。”</p><p><img src="/images/自习室.assets/image-20221106214752949.png" alt="image-20221106214752949"></p><blockquote><p>零知识证明的定义为：证明者（<code>prover</code>）能够在不向验证者（<code>verifier</code>）提供任何有用的信息的情况下，使验证者（<code>verifier</code>）相信某个论断是正确的。</p><p>从零知识证明定义中可以提取到两个关键词：“不泄露信息”，“证明论断有效”，基于这两个特点扩展出零知识证明在区块链上的两大应用场景：</p><ul><li>隐私：在隐私场景中，我们可以借助零知识证明的“不泄露信息”特性，在不泄漏交易的细节（接收方，发送方，交易余额）的情况下证明区块链上的资产转移是有效的。</li><li>扩容：在扩容场景中，我们不太需要关注零知识证明技术的“不泄露信息”这个特性，我们的关注重点是它的“证明论断有效”这个特性，由于链上资源是有限的，所以我们需要把大量的计算迁移到链下进行，因此需要有一种技术能够证明这些在链下发生的动作是可信的，零知识证明正好可以帮助我们做链下可信计算的背书。</li></ul></blockquote><p>三明治攻击</p><p>Byzantine Agreement  拜占庭共识</p><h6 id="DID"><a href="#DID" class="headerlink" title="DID"></a>DID</h6><p>DID 按照w3C标准，就是一串有特定格式的字符串，持久化的<strong>数字标识符</strong>，一个DID关联一对公私钥</p><blockquote><ul><li>每个人可以有很多个DID身份，不同的应用场景下有不同的身份，匿名化或者加密</li><li>不仅用DID做认证，还可以交换数字凭证</li><li>没有中心化机构来管理，DID 注册制区块链或者分布式网络上（自己注册DID，要选择一个特定方案，实现特定身份）</li></ul><p>DID 有特定语法：method 由特定公司实现，去DID备案，规范实现具体的标识符（由具体实现决定）</p><p><img src="/images/自习室.assets/image-20221015164830257.png" alt="image-20221015164830257"></p><p>DID方法规范主要定义：DID标识符、DID document 元素,CURD方法</p><p>DID 和 DID document 是键值对形式<img src="/images/自习室.assets/image-20221015165300295.png" alt="image-20221015165300295" style="zoom:50%;"></p><p>DID 文档里面有哪些元素</p><p>公钥、服务端点、签名、认证方法、时间戳</p><p>去中心凭证认证过程</p><p>由三个实体：颁发人 issuer、持有人holder、验证人verifier</p><p>issuer通过区块链颁发、holder打包成可验证表达、验证人验证该凭证-由holder出示、由issuer颁发（整个过程去中心化，DID、公钥都在链上公开）</p><p>did 在面对不同情况时，可能需要提供不同颁发人颁发的各种凭证，才能通过某服务验证方的验证。比如:游戏中，身份验证，只要昵称；金融理财，需要实名，所以只有DID不行，需要KYC凭证</p><p>DID优点：</p><ul><li>你的数字身份由自己控制</li><li>凭证不会被利用，就是出示凭证后对方只能验证，不像传统身份，输入身份密码等信息</li><li>DID 标识符和现实中个人信息是完全分离的，标识符公开上链，凭证可以个人安全存储，根据需要来使用</li><li>DID 面对不同场景，不同应用程序，可以提供不同凭证，不同于传统中心化身份系统，许多账号关联在一起</li><li>w3c/DIF /IETF/Oasis</li></ul></blockquote><hr><p><strong>verifiable credential</strong> —  有了身份验证，每个数字身份背后都要有可验证凭证，在did身份上的可认证凭据，关于DID持有人的身份信息的声明/凭证</p><p><strong>DID auth</strong>（did 认证） —-有了密钥对（身份），如何实现去中心的<strong>身份认证机制</strong></p><p><strong>DKMS</strong> — 如何<strong>管理DID中的公私钥对</strong>，密钥的管理和安全使用</p><p><strong>DID </strong>== SSI （去中心数字身份，did就是一对<strong>公私钥</strong>）— w3C</p><p>DID 可以基于区块链实现/DLT 实现</p><p><img src="/images/自习室.assets/image-20221015162139074.png" alt="image-20221015162139074" style="zoom:50%;"></p><p><img src="/images/自习室.assets/image-20221014205111213.png" alt="image-20221014205111213" style="zoom:50%;"></p><p>hhh</p><p><img src="/images/自习室.assets/image-20221014163752772.png" alt="image-20221014163752772"></p><h6 id="虚拟机-以太坊虚拟机"><a href="#虚拟机-以太坊虚拟机" class="headerlink" title="虚拟机/以太坊虚拟机"></a>虚拟机/以太坊虚拟机</h6><h6 id="IPFS"><a href="#IPFS" class="headerlink" title="IPFS"></a>IPFS</h6><p><a href="https://www.youtube.com/watch?v=cIJVg19RSsQ">https://www.youtube.com/watch?v=cIJVg19RSsQ</a></p><p>IPFS协议：7个子协议栈</p><blockquote><p><img src="/images/自习室.assets/image-20221114110244467.png" alt="image-20221114110244467" style="zoom:50%;"></p><p>UTP:bittorrent基于UPD协议改进的点对点协议</p><p>路由：基于DHT技术</p><p>块交换：bitswap协议</p><p>bitswap信用：协议鼓励节点多存储和传播数据，即便自己不需要（追踪节点信用额度，负债率（sigmod函数））</p><p>bitswap策略：每个节点可以使用不同的策略，bit_torrent使用默认策略为tit-for-tat，第三方策略bittyrant等。协议功能：</p><p><img src="/images/自习室.assets/image-20221114111440807.png" alt="image-20221114111440807" style="zoom:50%;"></p><p>bitswap账本：记录和其他节点的交换信息的账本，每次建立连接，节点都要交换账本信息</p><p>默克尔DAG-git数据结构的演变</p><p>默克尔树中主要存储文件数据</p><p>地址用CID</p><p>数据结构用DAG（有向无环图）</p><p><img src="/images/自习室.assets/image-20221112111007281.png" alt="image-20221112111007281" style="zoom:50%;"></p><p><img src="/images/自习室.assets/image-20221112111241329.png" alt="image-20221112111241329" style="zoom:50%;"></p><p><img src="/images/自习室.assets/image-20221112111155122.png" alt="image-20221112111155122" style="zoom:50%;"></p><p>用hash,不可能有环</p><p><img src="/images/自习室.assets/image-20221112111530993.png" alt="image-20221112111530993" style="zoom:50%;"></p><p><img src="/images/自习室.assets/image-20221112112738619.png" alt="image-20221112112738619" style="zoom:50%;"> <img src="/images/自习室.assets/image-20221112112758557.png" alt="image-20221112112758557" style="zoom:50%;"><img src="/images/自习室.assets/image-20221112112946086.png" alt="image-20221112112946086" style="zoom:50%;"></p><p>IPFS文件的工作细节</p><p><img src="/images/自习室.assets/image-20221112150925099.png" alt="image-20221112150925099" style="zoom:50%;"><img src="/images/自习室.assets/image-20221112151046796.png" alt="image-20221112151046796" style="zoom:50%;"></p><p>将文件分成小块，组织成DAG，计算CID，最后返回的hash作为文件的CID，也是top of the tree </p><p>dag.ipfs.io</p><p><img src="/images/自习室.assets/image-20221112151222214.png" alt="image-20221112151222214" style="zoom:50%;"><img src="/images/自习室.assets/image-20221112152258302.png" alt="image-20221112152258302" style="zoom:50%;"></p><p><img src="/images/自习室.assets/image-20221112152807353.png" alt="image-20221112152807353" style="zoom:50%;"><img src="/images/自习室.assets/image-20221112153218052.png" alt="image-20221112153218052" style="zoom:50%;"></p></blockquote><h3 id="2022-衍生论文"><a href="#2022-衍生论文" class="headerlink" title="2022/衍生论文"></a>2022/衍生论文</h3><p>物联网 + 区块链</p><p>Blockchain-based decentralized trust management in vehicular networks.</p>]]></content>
    
    
    <categories>
      
      <category>blockchain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>差分隐私</title>
    <link href="/2022/05/14/Differential%20Privacy/"/>
    <url>/2022/05/14/Differential%20Privacy/</url>
    
    <content type="html"><![CDATA[<h1 id="差分隐私"><a href="#差分隐私" class="headerlink" title="差分隐私"></a>差分隐私</h1><p>差分隐私就是来防范差分攻击的，啥是差分攻击呢？类似于排除法？或者说逻辑推导</p><p>怎么才能不让这种奇奇怪怪的攻击者获取奇奇怪怪的知识呢？加入随机噪声，对查询结果加入噪声，相当于不能再用查询的结果去对比、分析出任何数据，阻断了对大数据的挖掘。</p><p>查询函数$f(x):x \rightarrow R  $, 随机噪声Y，最终查询结果为$M(x) = f(x)+Y$</p><p>对于任意两个相邻数据集a,b,对于任意输出集合S，应该满足：</p><script type="math/tex; mode=display">Pr[M(a)\in S] \leq e^{\varepsilon} Pr[M(b) \in S]</script><p>我们的目的是要让不同的查询出来的结果尽可能相似，分布尽可能相同，好让攻击者分不出来啥玩意。$\varepsilon$ 是隐私预算，其越小，隐私保护越好，二者分布越接近，但是加入的噪声越大，数据就变质了，不能继续用了</p><p><img src="/images/Differential Privacy.assets/v2-3fd3b3107ba5407f423e065f10d02a0a_720w.jpg" alt="img" style="zoom:25%;"></p><script type="math/tex; mode=display">Pr[M(a)\in S] \leq e^{\varepsilon} Pr[M(b) \in S] + \delta</script><p>加入了$\delta$ ,变成了松弛版本的差分隐私。</p><p><img src="/images/Differential Privacy.assets/v2-37cc48e2aa2d9da99c5aa28a3d4e733f_720w.jpg" alt="img" style="zoom:25%;"></p><p>对于每次查询，我们都加入一些扰动，一定量的噪音，可能呈拉普拉斯分布，也可能呈高斯分布</p><p>安全多方计算依靠复杂的通信和加密，不会对模型产生影响，但是差分隐私会对模型产生噪声，不过相应的不用付出很高的通信和计算代价，收敛速度可能会变慢</p><p>参考资料：<a href="https://blog.csdn.net/wenzhu2333/article/details/109892369">https://blog.csdn.net/wenzhu2333/article/details/109892369</a></p>]]></content>
    
    
    <categories>
      
      <category>cryptography</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Meta-Learning for Domain Generalization</title>
    <link href="/2022/04/18/Meta-Learning_forDG/"/>
    <url>/2022/04/18/Meta-Learning_forDG/</url>
    
    <content type="html"><![CDATA[<h4 id="【CVPR-2021-FedDG】"><a href="#【CVPR-2021-FedDG】" class="headerlink" title="【CVPR 2021 FedDG】"></a>【<strong>CVPR 2021 FedDG</strong>】</h4><p>元学习算法为 gradient-based meta-learning algorithm，来自<a href="https://arxiv.org/abs/1710.03463"><strong>Learning to Generalize: Meta-Learning for Domain Generalization（MLDG）</strong></a></p><h4 id="在FedDG中"><a href="#在FedDG中" class="headerlink" title="在FedDG中"></a>在<a href="https://arxiv.org/abs/2103.06030">FedDG</a>中</h4><p><img src="/images/Meta-Learning_forDG.assets/p3.png" style="zoom:50%;"></p><h4 id="在SMAL中"><a href="#在SMAL中" class="headerlink" title="在SMAL中"></a>在<a href="https://link.springer.com/chapter/10.1007/978-3-030-59713-9_46">SMAL</a>中</h4><p><img src="/images/Meta-Learning_forDG.assets/p2.png" style="zoom: 67%;"></p><p><strong>MLDG</strong>第一个提出将元学习用于DG, <strong>MLDG</strong> 描述的算法如下：</p><p><img src="/images/Meta-Learning_forDG.assets/p4.png" alt></p><p><strong>Meta-Train</strong> 阶段</p><blockquote><p>划分 $S -&gt; \overline S 、 V$</p><p> $\overline S$  用于元训练的域，$V$ 用于元测试的域</p><p>$Θ$​  模型的参数</p><p>$ \mathcal F$​  元训练的损失函数</p><p>$∇Θ$​ 是  $Θ$​ 关于 $\mathcal F$​​的梯度,参数更新公式为 $Θ′=Θ−α∇Θ$​</p></blockquote><p><strong>Meta-Test​</strong> </p><blockquote><p>与<strong>$Meta-Train$</strong> 阶段步骤相同，但是数据用的是测试域数据 $V$</p></blockquote><p><strong>Summary</strong> </p><blockquote><p>$α$ 是元训练的步长</p><p>$β$  是元训练和元测试之间的权重</p><p>使用梯度下降算法求解下式就可以得到<strong>Algorithm 1</strong>的第9行</p><p>$argminΘ \mathcal F(Θ)+β \mathcal G(Θ−αF′(Θ))$</p><p>$F$是来自元训练域损失的综合，$G$是来自元测试域损失的综合</p><p>$F′(⋅)$是训练损失 $F(Θ)$关于 $Θ$ 的梯度，即 $∇Θ$</p><p>“模型需要优化以使得在更新元训练域之后，模型在元测试域上的性能也很好”。</p></blockquote><p><strong>Final-Test</strong> </p><blockquote><p>收敛后，得到最终模型 $Θ$​</p></blockquote><h5 id="关于元学习的理解"><a href="#关于元学习的理解" class="headerlink" title="关于元学习的理解"></a>关于元学习的理解</h5><p>元学习，学会一个知道怎样初始化模型参数最好的算法，Learning to initialize</p><p><img src="/images/Meta-Learning_forDG.assets/p5.png" style="zoom:50%;"></p><p>Deep learning 总是在读数据 + 调参数 ，用很多GPU，看哪组参数效果好</p><p>超参数、网络架构能不能自己学习到？</p><h4 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a><strong>机器学习</strong></h4><ol><li>找一个function（内有未知参数 f(θ)）</li><li>定义loss函数L(θ) （将训练资料丢到f(θ)里面，将输出和正确lable算距离，所有距离总和为loss </li><li>找一个θ,使得L(θ)最小(梯度下降)</li></ol><h4 id="元学习"><a href="#元学习" class="headerlink" title="元学习"></a><strong>元学习</strong></h4><blockquote><p>步骤同机器学习，但是输出为一个function，比如输出一个分类器，我丢数据就能分类。</p><p>找𝜙时，还是要调learning rate，也就是参数还是要调，但是调好一个可以用到很多，其实就是向上套娃，换一个效率高的方式暴调参数</p></blockquote><ol><li><p>想让机器学什么，比如学 net architecture，initial parameters，learning rate 这些之前只能靠人工设定的，这些东西用𝜙表示，找 F(𝜙)</p></li><li><p>定义Loss function ，loss 是在训练集中的测试资料中跑出来的，所有的任务的loss加起来</p><blockquote><p>以任务为单位（每个任务分训练资料和测试资料）</p></blockquote></li><li><p>找一个𝜙，使得L(𝜙)最小</p><blockquote><p><img src="/images/Meta-Learning_forDG.assets/p6.png" style="zoom: 45%;"><img src="/images/Meta-Learning_forDG.assets/p7.png" style="zoom: 45%;"></p></blockquote></li></ol><blockquote><p>In typical ML, you compute the loss based on training examples<br>In meta, you compute the loss based on testing examples of training tasks. （训练集中划分的测试集）</p><p><a href="https://speech.ee.ntu.edu.tw/~hylee/ml/ml2021-course-data/meta_v3.pdf">李宏毅元学习PPT</a></p></blockquote><p>以<strong>FedDG</strong>中的为例子分析：</p><script type="math/tex; mode=display">\widehatθ^k= θ^k−β∇_{θ^k} \mathcal L_{seg}(x^k_i; θ^k), (4)</script><p>领域泛化综述：</p><p><a href="https://cloud.tencent.com/developer/article/1819333">https://cloud.tencent.com/developer/article/1819333</a></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对比学习</title>
    <link href="/2022/04/15/contrastive%20learning/"/>
    <url>/2022/04/15/contrastive%20learning/</url>
    
    <content type="html"><![CDATA[<h2 id="【ICML-2020】SimCLR-【CVPR-2021】FedDG"><a href="#【ICML-2020】SimCLR-【CVPR-2021】FedDG" class="headerlink" title="【ICML 2020】SimCLR + 【CVPR 2021】FedDG"></a>【ICML 2020】SimCLR + 【CVPR 2021】FedDG</h2><p>SimCLR 最终目的是最大化同一数据示例的不同增强视图之间的一致性来学习表示，即 max similar(v1,v2)</p><h3 id="一、SimCLR-基本步骤"><a href="#一、SimCLR-基本步骤" class="headerlink" title="一、SimCLR 基本步骤"></a>一、SimCLR 基本步骤</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">cont_loss_func</span> = losses.NTXentLoss(temperature)     <span class="hljs-comment">#对比损失</span><br></code></pre></td></tr></table></figure><h4 id="step-1-随机数据增强"><a href="#step-1-随机数据增强" class="headerlink" title="step 1. 随机数据增强"></a>step 1. 随机数据增强</h4><p>随机转换任何给定的数据示例，<strong>生成同一数据示例的两个相关视图</strong></p><p>将标签$y_i^k$ 做一系列变换，变成 $y_{i_ bd}^k$ 和 $y_{i_ bg}^k$​ (边界部分和背景部分的mask) ,对应代码：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">disc_contour, </span><span class="hljs-keyword">disc_bg, </span>cup_contour, cup_bg = _get_coutour_sample(mask_patch)<br></code></pre></td></tr></table></figure><p><img src="/images/contrastive learning.assets/image-20220417095937463.png" alt="image-20220417095937463"></p><h4 id="step-2-得到特征的表示（基础编码器）"><a href="#step-2-得到特征的表示（基础编码器）" class="headerlink" title="step 2.得到特征的表示（基础编码器）"></a>step 2.得到特征的表示（基础编码器）</h4><p>然后将 $l$​ 层的网络特征 $ Z_i^k$​按照mask提取出边界特征$h^k_{i_bd}$​和背景特征$h^k_{i_bg}$:</p><script type="math/tex; mode=display">h^k_{i\_bd} = \frac {\sum _{h,w} Z^k_i * y^k_{i\_bd} }{\sum _{h,w} y^k_{i\_bd}} ;h^k_{i\_bg} = \frac {\sum _{h,w} Z^k_i * y^k_{i\_bg} }{\sum _{h,w} y^k_{i\_bg}} (5)</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">extract_contour_embedding</span>(<span class="hljs-params">contour_list, embeddings</span>):</span><br><br>    average_embeddings_list = []<br>    <span class="hljs-keyword">for</span> contour <span class="hljs-keyword">in</span> contour_list:<br>        contour_embeddings = contour * embeddings<br>        average_embeddings = torch.<span class="hljs-built_in">sum</span>(contour_embeddings, (-<span class="hljs-number">1</span>,-<span class="hljs-number">2</span>))/torch.<span class="hljs-built_in">sum</span>(contour, (-<span class="hljs-number">1</span>,-<span class="hljs-number">2</span>))<br>        average_embeddings_list.append(average_embeddings)<br>    <span class="hljs-keyword">return</span> average_embeddings_list<br></code></pre></td></tr></table></figure><h4 id="step-3-投影头（此处不用，直接下游任务）"><a href="#step-3-投影头（此处不用，直接下游任务）" class="headerlink" title="step 3.投影头（此处不用，直接下游任务）"></a>step 3.投影头（此处不用，直接下游任务）</h4><h4 id="step-4-计算余弦相似度-计算损失"><a href="#step-4-计算余弦相似度-计算损失" class="headerlink" title="step 4.计算余弦相似度 + 计算损失"></a>step 4.计算余弦相似度 + 计算损失</h4><p>对边界特征$h^k_{i_bd}$和背景特征$h^k_{i_bg}$使用 $ InfoNCE$约束，用余弦相似度计算二者之间的相似度$ similar(h^k_{i_bd},h^k_{i_bg}) $​​ </p><script type="math/tex; mode=display">\mathscr l(h_m,h_p)=-log{\frac {exp(h_m \bigodot {h_p/{\tau}})} {\sum ^{2K}_{q=1,q \ne m} \mathbb F(h_m,h_q)·exp(h_m \bigodot h_q/\tau)},(6)}</script><p>SimCLR使用了一种对比损失，称为“<strong>NT-Xent损失</strong>”(<strong>归一化温度-尺度交叉熵损失</strong>)，此处便是判断$h_m$ 和 $h_p$ 特征之间的相似度，如果同为边界/背景特征则为正对，否则为负$\mathbb F(h_m,h_q)$</p><blockquote><p>来源：<a href="https://kevinmusgrave.github.io/pytorch-metric-learning/losses/#ntxentloss">NTXentLoss</a> <a href="https://paperswithcode.com/method/nt-xent">nt-xent</a></p></blockquote><p>$\text{sim}\left(\mathbf{u}, \mathbf{v}\right) = \mathbf{u}^{T}\mathbf{v}/||\mathbf{u}|| ||\mathbf{v}||$ denote the cosine similarity between two vectors $\mathbf{u}$ and $\mathbf{v}$ . Then the loss function for a positive pair of examples $\left(i, j\right)$ is :</p><script type="math/tex; mode=display">\mathbb{l}_{i,j} = -\log\frac{\exp\left(\text{sim}\left(\mathbf{z}_{i}, \mathbf{z}_{j}\right)/\tau\right)}{\sum^{2N}_{k=1}\mathbb{1}_{[k\neq{i}]}\exp\left(\text{sim}\left(\mathbf{z}_{i}, \mathbf{z}_{k}\right)/\tau\right)}</script><p>where $\mathcal{1}_{[k\neq{i}]} \in \{0, 1\} $is an indicator function evaluating to  $\mathcal{1}$ iff(if and only if)  $k\neq{i}$ and  $\tau$ denotes a temperature parameter. The final loss is computed across all positive pairs, both $\left(i, j\right)$  and $ \left(j, i\right)$ , in a mini-batch.<img src="../images/contrastive learning.assets/simclr-softmax-loss.png" alt="Calculation of Loss from softmax"></p><p>最后的边界损失，是所有正对损失的平均</p><script type="math/tex; mode=display">\mathcal L_{boundary}=\sum ^{2K}_{m=1} \sum ^{2K}_{p=m+1} \frac {(1- \mathbb F(h_m,h_p))·\mathscr l(h_m,h_p)} {B(K,2)\times 2},(7)</script><p>综上： </p><blockquote><ol><li><p>NTXentLoss 的输入：两个经过操作后得到的一维向量 $h_m，h_p$ </p></li><li><p>$\mathbb F(h_m,h_p)$ 正对时为0，存在边界损失，负对时为1 ，边界损失为0</p></li><li><p>B(K,2) 代表组合数，从K个数据集中任选两个</p></li></ol></blockquote><h3 id="二、对比学习到底在学习什么"><a href="#二、对比学习到底在学习什么" class="headerlink" title="二、对比学习到底在学习什么?"></a>二、对比学习到底在学习什么?</h3><p>对比学习的目标，对于任意数据 $x$,学习一个编码器 $f$ ，使得：</p><p><img src="/images/contrastive learning.assets/score-function-underlined.svg" alt="Contrastive Objective" style="zoom: 50%;"></p><p>对于FedDG来说，引入对比学习，就是为了通过对比损失的引导，学习能够更好的提取特征，更好的区分边界和背景，提高分割效果，训练更好的分割网络。</p><blockquote><p>由此可见，SimCLR看着有很多构件，比如Encoder、Projector、图像增强、InfoNCE损失函数，其实我们最后要的，只是Encoder，而其它所有构件以及损失函数，只是用于训练出高质量Encoder的辅助结构。</p><p><a href="https://zhuanlan.zhihu.com/p/367290573">对比学习（Contrastive Learning）:研究进展精要</a></p></blockquote><hr><p>参考：</p><p> <a href="https://amitness.com/2020/03/illustrated-simclr/">The Illustrated SimCLR Framework </a>  </p><p><a href="https://www.cnblogs.com/BlairGrowing/p/14852361.html">论文解读（SimCLR）《A Simple  Framework for Contrastive Learning of Visual  Representations》   </a></p><p><a href="https://blog.csdn.net/u011984148/article/details/106233313/">图解SimCLR框架，用对比学习得到一个好的视觉预训练模型</a></p><p><a href="https://zhuanlan.zhihu.com/p/396638256">[论文阅读]CVPR2021上的医学图像联邦学习文章：FedDG</a></p><p><a href="https://ankeshanand.com/blog/2020/01/26/contrative-self-supervised-learning.html">Contrastive Self-Supervised Learning</a></p><p><a href="https://zhuanlan.zhihu.com/p/141172794">对比学习（Contrastive Learning）</a></p><p><a href="https://zhuanlan.zhihu.com/p/367290573">对比学习（Contrastive Learning）:研究进展精要</a></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>增量学习 Federated Class Incremental Learning</title>
    <link href="/2022/04/04/Incremental_Learning/"/>
    <url>/2022/04/04/Incremental_Learning/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/Incremental_Learning.assets/image-20220406091741329.png" alt="image-20220406091741329"></p><span id="more"></span><p><a href="https://bbs.sffai.com/d/327-142/3">来源</a></p><p><img src="/images/Incremental_Learning.assets/image-20220407203827531.png" alt="image-20220407203827531"></p><p>已有工作：</p><ol><li><p>联邦持续学习</p><blockquote><p>提取任务之间共有的知识，本地用户可以利用其他用户知识</p></blockquote></li><li><p>上传中心服务器，服务器可以反推数据 上传embeding?? repretation?的通信，通信很大负担</p></li><li>共享数据，蒸馏 （共享数据怎么来？）旧模型蒸馏，什么时候切换旧模型去蒸馏？</li><li><img src="/images/Incremental_Learning.assets/image-20220407144037372.png" alt="image-20220407144037372"></li></ol><p>我们的工作：</p><ol><li>GLFC框架（Global-Local Forgetting Compensation）  a forgetting compensation framework</li><li>FCIL方法  每个本地用户，自己采集本地数据</li></ol><p>具体方法：</p><ol><li>新旧任务之间的梯度进行补偿  class-aware gradient compensation</li><li>从旧模型蒸馏类别之间语义信息，到新模型，保证对旧模型遗忘没那么快</li><li>代理服务器，和本地用户交流，为本地用户的训练选择最好的旧模型，以供本地用户蒸馏</li></ol><p> T 个任务，假设本地用户会存储旧类别数据，即 exemplar memory</p><p>假设旧类别的数据对每个旧类别来说，样本数量远小于当前任务的样本数量（存疑</p><p>联邦学习假设setting：</p><ol><li>假设数据独立同分布</li><li>假设有三种用户：So老用户（保持旧任务） +  Sb(从旧任务到新任务过渡) + Sn新用户（任务过渡时才会参与联邦学习）</li><li>服务器可以决定类别的数量，但是不知道任何本地用户的分布和序号，也不知道新类别什么时候到来</li></ol><p>目标：在新用户和新类持续到来的情况下学习一个更好的全局模型</p><p>non-iid 不平衡 ： </p><p>本地：</p><ul><li><p>不同用户之间的数据分布不一样</p></li><li><p>存储空间有限，旧类别数据量小 —》 遗忘   每个客户端不一样，所以对旧的遗忘 和 对新的学习速度都是不一样的</p><p><img src="/images/Incremental_Learning.assets/image-20220407194659706.png" alt="image-20220407194659706"></p></li></ul><p>本地训练loss设计：</p><ol><li><p>交叉熵损失 * 一个系数，样本小权重大，样本大权重小，平衡不同类别之间的损失</p><p><img src="/images/Incremental_Learning.assets/image-20220407195213471.png" alt="image-20220407195213471"></p></li><li><p>蒸馏损失 ，对当前训练数据</p><p><img src="/images/Incremental_Learning.assets/image-20220407201522899.png" alt="image-20220407201522899"></p></li></ol><p>全局：</p><ul><li>每一轮随机选取一部分用户参与训练</li><li>所以不能确定，对于当前任务，哪一轮全局模型效果最好，因为有一个蒸馏的过程，不知道如何选择哪个全局模型进行蒸馏</li></ul><p>全局补偿：任务转换检测</p><p>蒸馏需要确切知道任务过渡的时间，方法如下：</p><ol><li><p>当前类别之前见过吗？是否是新任务？ （ 但是non-iid ，可能只是某一用户没见过</p></li><li><p>效果变低时？performance reduction</p></li><li><p>(我们的方法)  不用1 2  ，用熵来检测（entropy-based detection）,交叉熵损失在训练时会下降，一旦检测到上升，就可能是新旧任务的过渡</p><p><img src="/images/Incremental_Learning.assets/image-20220407202014694.png" alt="image-20220407202014694"></p></li></ol><p>为蒸馏选择更好的旧模型</p><p>哪一轮的全局模型更好呢？怎么确定呢？每一轮只是随机选啊？</p><p>方法：一种交流手段，用户可以和代理服务器交换隐私信息，分享梯度，对梯度重构，重构出该梯度所对应的数据</p><p>但是梯度应该被隐私保护，所以引入一种加密，加 perturbed, 代理服务器再去测试哪一个模型更好</p><p><img src="/images/Incremental_Learning.assets/image-20220407202502841.png" alt="image-20220407202502841"></p><p><img src="/images/Incremental_Learning.assets/image-20220407202820253.png" alt="image-20220407202820253"></p><p><img src="/images/Incremental_Learning.assets/image-20220407202849072.png" alt="image-20220407202849072"></p><p>将来的几个问题：</p><ul><li>交换用户数据怎么保护隐私？：用梯度重构，并且加了perturbed,就算重构了也不是原始数据。 也可以加入一些密码学的操作。</li><li>任务过渡检测。用熵检测，遇到完全新任务效果好。但实际中过渡较平缓，熵增就不管用了。…..</li><li>联邦学习setting  新任务没有标签咋办？新任务来的快怎么高效训练？？</li></ul><p><img src="/images/Incremental_Learning.assets/image-20220407204321100.png" alt="image-20220407204321100"></p><p>当前联邦学习还不能适应流动的数据分布的到来</p><p>就是将联邦学习放到动态条件下</p><p>遗忘率？</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo + github 搭建个人博客</title>
    <link href="/2022/01/03/stepToblog/"/>
    <url>/2022/01/03/stepToblog/</url>
    
    <content type="html"><![CDATA[<h4 id="一、预备工具："><a href="#一、预备工具：" class="headerlink" title="一、预备工具："></a>一、预备工具：</h4><ul><li>Node.js下载：【它让JavaScript成为与PHP、Python、Perl、Ruby等服务端语言平起平坐的脚本语言。】安装教程：<a href="https://www.cnblogs.com/liuqiyun/p/8133904.html">https://www.cnblogs.com/liuqiyun/p/8133904.html</a></li><li>Git下载：<a href="https://github.com/git-for-windows/git/releases/download/v2.11.0.windows.3/Git-2.11.0.3-64-bit.exe【Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理】安装教程：https://www.cnblogs.com/xueweisuoyong/p/11914045.html">https://github.com/git-for-windows/git/releases/download/v2.11.0.windows.3/Git-2.11.0.3-64-bit.exe【Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理】安装教程：https://www.cnblogs.com/xueweisuoyong/p/11914045.html</a></li><li>github账号注册：<a href="https://www.bilibili.com/read/cv5107169/">https://www.bilibili.com/read/cv5107169/</a></li></ul><span id="more"></span><h4 id="二、查看版本-是否安装成功"><a href="#二、查看版本-是否安装成功" class="headerlink" title="二、查看版本/是否安装成功"></a>二、查看版本/是否安装成功</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">node -v<br>npm -v<br>git --version<br>npm install hexo-cli -g  (Hexo下载)<br>npm config get prefix <span class="hljs-comment">#查看npm安装路径</span><br>npm config <span class="hljs-built_in">set</span> prefix <span class="hljs-string">&quot;E:\Program Files\nodejs\node_global&quot;</span><br>npm config <span class="hljs-built_in">set</span> cache <span class="hljs-string">&quot;E:\Program Files\nodejs\node_cache&quot;</span>   <br>(npx) hexo -v<br></code></pre></td></tr></table></figure><h4 id="三、建一个github仓库-、SSH绑定"><a href="#三、建一个github仓库-、SSH绑定" class="headerlink" title="三、建一个github仓库 、SSH绑定"></a>三、建一个github仓库 、SSH绑定</h4><h5 id="1-在bash里面："><a href="#1-在bash里面：" class="headerlink" title="1.在bash里面："></a>1.在bash里面：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">生成ssh：ssh-keygen -t rsa -C <span class="hljs-string">&quot;邮件地址&quot;</span><br>打开电脑.ssh下 id_rsa.pub文件，拷贝 <br>github -&gt; setting -&gt;SSH and GPGkeys-&gt;new SSH key-&gt;粘贴进去<br></code></pre></td></tr></table></figure><p><img src="/images/stepToblog.assets/image-20220113163053501.png" alt="image-20220113163053501" style="zoom:50%;"></p><p><img src="/images/stepToblog.assets/image-20220113163412905.png" alt="image-20220113163412905" style="zoom: 50%;"></p><h5 id="2-测试ssh是否绑定成功："><a href="#2-测试ssh是否绑定成功：" class="headerlink" title="2.测试ssh是否绑定成功："></a>2.测试ssh是否绑定成功：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -T git@github.com <br></code></pre></td></tr></table></figure><h5 id="3-生成博客内容"><a href="#3-生成博客内容" class="headerlink" title="3.生成博客内容"></a>3.生成博客内容</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> -g hexo <span class="hljs-comment">#安装hexo</span><br>hexo init <span class="hljs-comment">#初始化hexo博客</span><br>hexo s <span class="hljs-comment"># 启动服务</span><br>hexo g <span class="hljs-comment"># 生成页面</span><br>hexo d <span class="hljs-comment"># 上传页面</span><br></code></pre></td></tr></table></figure><h5 id="4-发布博客配置-config-yml-里面"><a href="#4-发布博客配置-config-yml-里面" class="headerlink" title="4.发布博客配置 _config.yml 里面"></a>4.发布博客配置 _config.yml 里面</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">deploy: git<br>repository: 你的仓库地址<br>branch:  main<br></code></pre></td></tr></table></figure><h5 id="5-令牌"><a href="#5-令牌" class="headerlink" title="5.令牌"></a>5.令牌</h5><p>hexo d 后，等待输入用户名 + 密码</p><p>此时密码用令牌</p><p>令牌获取： github -&gt;setting-&gt;developer setting-&gt;添加令牌</p><h5 id="6-安装hexo-deployer-git自动部署发布工具"><a href="#6-安装hexo-deployer-git自动部署发布工具" class="headerlink" title="6.安装hexo-deployer-git自动部署发布工具"></a>6.安装hexo-deployer-git自动部署发布工具</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>7.新建页面/文章</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new page/post/draft + name<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>参数</th><th>功能</th><th>路径</th></tr></thead><tbody><tr><td>post</td><td>新建文章</td><td>/source/_posts/</td></tr><tr><td>draft</td><td>新建草稿</td><td>/source/_drafts/</td></tr><tr><td>page</td><td>新建页面（标签页，分类页等）</td><td>/source/</td></tr></tbody></table></div><h3 id="Hexo-Next主题文件结构"><a href="#Hexo-Next主题文件结构" class="headerlink" title="Hexo Next主题文件结构"></a>Hexo Next主题文件结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── .github            <span class="hljs-comment">#git信息</span><br>├── languages          <span class="hljs-comment">#多语言</span><br>|   ├── default.yml    <span class="hljs-comment">#默认语言</span><br>|   └── zh-Hans.yml      <span class="hljs-comment">#简体中文</span><br>|   └── zh-tw.yml      <span class="hljs-comment">#繁体中文</span><br>├── layout             <span class="hljs-comment">#布局，根目录下的*.ejs文件是对主页，分页，存档等的控制</span><br>|   ├── _custom        <span class="hljs-comment">#可以自己修改的模板，覆盖原有模板</span><br>|   |   ├── _header.swig    <span class="hljs-comment">#头部样式</span><br>|   |   ├── _sidebar.swig   <span class="hljs-comment">#侧边栏样式</span><br>|   ├── _macro        <span class="hljs-comment">#可以自己修改的模板，覆盖原有模板</span><br>|   |   ├── post.swig    <span class="hljs-comment">#文章模板</span><br>|   |   ├── reward.swig    <span class="hljs-comment">#打赏模板</span><br>|   |   ├── sidebar.swig   <span class="hljs-comment">#侧边栏模板</span><br>|   ├── _partial       <span class="hljs-comment">#局部的布局</span><br>|   |   ├── head       <span class="hljs-comment">#头部模板</span><br>|   |   ├── search     <span class="hljs-comment">#搜索模板</span><br>|   |   ├── share      <span class="hljs-comment">#分享模板</span><br>|   ├── _script        <span class="hljs-comment">#局部的布局</span><br>|   ├── _third-party   <span class="hljs-comment">#第三方模板</span><br>|   ├── _layout.swig   <span class="hljs-comment">#主页面模板</span><br>|   ├── index.swig     <span class="hljs-comment">#主页面模板</span><br>|   ├── page           <span class="hljs-comment">#页面模板</span><br>|   └── tag.swig       <span class="hljs-comment">#tag模板</span><br>├── scripts            <span class="hljs-comment">#script源码</span><br>|   ├── tags           <span class="hljs-comment">#tags的script源码</span><br>|   ├── marge.js       <span class="hljs-comment">#页面模板</span><br>├── <span class="hljs-built_in">source</span>             <span class="hljs-comment">#源码</span><br>|   ├── css            <span class="hljs-comment">#css源码</span><br>|   |   ├── _common    <span class="hljs-comment">#*.styl基础css</span><br>|   |   ├── _custom    <span class="hljs-comment">#*.styl局部css</span><br>|   |   └── _mixins    <span class="hljs-comment">#mixins的css</span><br>|   ├── fonts          <span class="hljs-comment">#字体</span><br>|   ├── images         <span class="hljs-comment">#图片</span><br>|   ├── uploads        <span class="hljs-comment">#添加的文件</span><br>|   └── js             <span class="hljs-comment">#javascript源代码</span><br>├── _config.yml        <span class="hljs-comment">#主题配置文件</span><br>└── README.md          <span class="hljs-comment">#说明文档</span><br></code></pre></td></tr></table></figure><h3 id="板娘在哪换"><a href="#板娘在哪换" class="headerlink" title="板娘在哪换"></a>板娘在哪换</h3><p><img src="/images/stepToblog.assets/image-20211112162544790.png" alt="image-20211112162544790"></p><h3 id="背景图"><a href="#背景图" class="headerlink" title="背景图"></a>背景图</h3><blockquote><p> <img src="/images/stepToblog.assets/image-20220408150543591.png" alt="image-20220408150543591"></p></blockquote><h3 id="版权信息"><a href="#版权信息" class="headerlink" title="版权信息"></a>版权信息</h3><blockquote><p>直接开启就好</p><p><img src="/images/stepToblog.assets/image-20211112162508323.png" alt="image-20211112162508323"></p></blockquote><h3 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h3><blockquote><p><img src="/images/stepToblog.assets/image-20211112162442591.png" alt="image-20211112162442591"></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>tool</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【论文翻译】FedDG</title>
    <link href="/2021/12/02/FedDG/"/>
    <url>/2021/12/02/FedDG/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="论文翻译-FedDG-Federated-Domain-Generalization-on-Medical-Image-Segmentation-via-Episodic-Learning-in-Continuous-Frequency-Space"><a href="#论文翻译-FedDG-Federated-Domain-Generalization-on-Medical-Image-Segmentation-via-Episodic-Learning-in-Continuous-Frequency-Space" class="headerlink" title="[论文翻译]FedDG: Federated Domain Generalization on Medical Image Segmentation via Episodic Learning in Continuous Frequency Space"></a>[论文翻译]<strong>FedDG: Federated Domain Generalization on Medical Image Segmentation via Episodic Learning in Continuous Frequency Space</strong></h3><blockquote><p>FedDG:通过在连续频率空间的<strong>Episodic Learning</strong> 的联邦域生成在医学图像分割上的应用</p></blockquote><h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a><strong>Abstract</strong></h4><p>​        Federated learning allows distributed medical institutions to collaboratively learn a shared prediction model with privacy protection. While at clinical deployment, the models trained in federated learning can still suffer from performance drop when applied to completely unseen hospitals outside the federation. In this paper, we point out and solve ==a novel problem setting== of federated domain generalization (FedDG), which aims to learn a federated model from multiple distributed source domains such that it can directly generalize to unseen target domains. We present a novel approach, named as ==Episodic Learning== in Continuous Frequency Space (ELCFS), for this problem by enabling each client to exploit multi-source data distributions under the challenging constraint of data decentralization. Our approach transmits the distribution information across clients in a privacy-protecting way through an effective continuous frequency space interpolation mechanism. With the transferred multi-source distributions, we further carefully  design a boundary-oriented episodic learning paradigm to expose the local learning to ==domain distribution shifts== and particularly meet the challenges of model generalization in medical image segmentation scenario. The effectiveness of our method is demonstrated with superior performance over state-of-the-arts and ==in-depth ablation experiments== on two medical image segmentation tasks. The code is available at  <a href="https://github.com/liuquande/FedDG-ELCFS">https://github.com/liuquande/FedDG-ELCFS</a>.</p><blockquote><p><strong>摘要</strong></p><p>​        联合学习允许分布式医疗机构协同学习具有隐私保护的共享预测模型。而在临床部署时，联邦学习训练的模型在应用于联邦之外完全看不见的医院时，仍然会遭受性能下降的困扰。本文提出并解决了一个新的联邦域泛化问题( FedDG )，该问题旨在从多个分布式源域学习一个联邦模型，使其能够直接泛化到不可观测的目标域。针对这个问题，我们提出了一种新的方法，称为连续频率空间中的情景学习( ELCFS )，使每个客户端能够在数据分散的挑战约束下利用多源数据分布。我们的方法通过有效的连续频率空间插值机制，以隐私保护的方式传输跨客户端的分布信息。随着转移的多源分布，我们进一步精心设计了一个面向边界的情景学习范式，以使局部学习能够适应领域分布的变化，并特别针对医学图像分割场景中模型泛化的挑战。我们的方法在两个医学图像分割任务上的性能均优于目前的研究现状和深度消融实验。代码可在<strong><a href="https://github.com/liuquande/FedDG-ELCFS">https://github.com/liuquande/FedDG-ELCFS</a></strong>获得。</p></blockquote><h4 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a><strong>1. Introduction</strong></h4><p>​        Data collaboration across multiple medical institutions is increasingly desired to build accurate and robust data-driven deep networks for medical image segmentation [7, 18, 50]. Federated learning (FL) [20] has recently opened the door for a promising privacy-preserving solution, which allows training a model on distributed datasets while keeping data locally. The paradigm works in a way that each local client(e.g., hospital) learns from their own data, and only aggregates the model parameters at a certain frequency at the central server to generate a global model. <code>怎么聚合？为什么聚合后可以适用于全局？</code>All the data samples are kept within each local client during federated training.</p><blockquote><p>1.引言</p><p>​        跨多个医疗机构的数据协作越来越希望构建精确、稳健的数据驱动的医学图像分割深度网络[  7、 18、 50 ]。联邦学习( Federation Learning，FL ) 最近开启了一个很有前途的隐私保护解决方案的大门，它允许在分布式数据集上训练一个模型同时保持数据在本地。该范式的工作方式是每个本地客户 ( 例如 ,医院 )从自身数据中学习，只在中心服务器以一定频率聚合模型参数，生成全局模型。在联邦训练过程中，所有的数据样本都保存在每个本地客户端。</p></blockquote><p><img src="/images/FedDG.assets/image-20211202135641019.png" alt="image-20211202135641019"></p><p>Figure 1. (a) The novel problem setting of federated domain generalization (FedDG), which aims to learn a federated model from multiple decentralized source domains such that it can directly generalize to completely unseen target domains. (b) Our main idea to tackle FedDG by transferring distribution information in frequency space and episodic learning at each local client.</p><blockquote><p>图1 .(a) 一个新的联邦域泛化问题( FedDG )，该问题旨在从多个分布式源域学习一个联邦模型，使其能够直接泛化到不可观测的目标域;(b)我们的主要想法是通过在频率空间中传输分布信息和在每个本地客户的Episodic Learning来处理FedDG。</p></blockquote><p>​        Although FL has witnessed some pilot progress on medical image segmentation tasks [4, 44, 49], all existing works only focus on improving model performance on the internal clients, while neglecting model generalizability onto unseen domains outside the federation. This is a crucial problem impeding wide applicability of FL models in real practice. The testing medical images encountered in unseen hospitals can differ significantly from the source clients in terms of data distributions, due to the variations in imaging scanners and protocols. How to generalize the federated model under such distribution shifts is technically challenging yet unexplored so far. In this work, we identify the novel problem setting of <em>Federated Domain Generalization</em> (FedDG),which aims to learn a federated model from multiple decentralized source domains such that it can directly generalize to completely unseen domains, as illustrated in Fig. 1 (a).</p><blockquote><p>​    尽管FL在医学图像分割任务方面取得了一些试点进展[  4、 44、 49 ]，但现有的所有工作都只注重提高内部客户端的模型性能，而忽略了模型在联邦之外的<strong>不可视领域的可推广性</strong>。这是阻碍FL模型在实际应用中广泛应用的关键问题。由于成像扫描仪和协议的不同，无法观察到的医院所遇到的测试医学图像在数据分布上会与源客户端产生明显差异。如何在这种分布移位下推广联邦模型，在技术上是具有挑战性的，但迄今为止还没有探索。在本工作中，我们识别了联邦域泛化( FedDG )的新颖问题设置，它旨在从多个分散的源域中学习一个联邦模型，使其能够直接泛化到完全看不见的域，如图1 ( a )所示。</p></blockquote><p>​    Unseen domain generalization (DG) is an active research topic with different methods being proposed [3, 8, 11, 24,25, 26, 29, 37, 43], but the federated paradigm with distributed data sources poses new challenges for DG. With the goal to extract representations that are robust to distribution shift, existing DG approaches usually require access to multi-source distributions in the learning process. For instance, adversarial feature alignment methods [26, 29] have to train the domain discriminator with samples from different source datasets. Meta-learning based methods [8, 24] need to use multi-source data of different distributions to construct virtual training and virtual testing domains within each minibatch. Whereas in federated paradigm, data are stored distributedly and the learning at each client can only access its local data. Therefore, current DG methods are typically not applicable in FedDG scenario. In addition, the local optimization would make model biased to its own data distribution, thus less generalizable to new target domains.<code>风格迁移？？？</code></p><blockquote><p>​        不可视领域泛化( DG )是一个活跃的研究课题，不同的方法被提出[  3、 8、 11、 24、 25、 26、 29、 37、 43 ]，但分布式数据源的联邦范式对DG提出了新的挑战。现有DG方法以提取对分布偏移具有鲁棒性的表示为目标，在学习过程中通常需要访问多源分布。例如，对抗特征对齐方法[  26,29 ]需要用来自不同源数据集的样本训练领域判别器。基于元学习的方法[  8,24 ]需要使用不同分布的多源数据在每个小批量数据内构建虚拟训练和虚拟测试域。而在联邦模式下，数据是分布式存储的，每个客户端的学习只能访问其本地数据。因此，目前的DG方法在FedDG场景中通常不适用。此外，局部优化会使模型偏向于自身的数据分布，从而对新的目标域的通用性较差。</p></blockquote><p>​        To solve this FedDG problem, <strong>our insight is to enable each client to access multi-source data distributions in a privacy-protecting way</strong>. The idea is motivated by the knowledge that <strong>the low-level distributions (i.e., style) and high level semantics of an image can be respectively captured by amplitude and phase spectrum in the frequency space</strong>, as revealed by visual psychophysics [13, 42, 57].<strong>We can consider exchanging these amplitude spectrum across clients to transmit the distribution information (cf. Fig. 1 (b)), while keeping the phase spectrum with core semantics locally for privacy protection.</strong> Based on this, we also devise a <code>continuous frequency space interpolation mechanism</code>, which interpolates between the local and transferred distributions for enriching the established multi-domain distributions for each local client.<code>怎么插值，啥意思?</code> This promotes the local training to gain domain-invariance benefiting from a dedicated dense distribution space. With these established distributions, we expose the local learning to domain distribution shifts via an episodic training paradigm to enhance the generalizability of local parameters. A novel meta-update objective function is designed to guide cross-domain optimization attending to the boundary area. This is notably important for medical image segmentation applications where generalization errors often come from imprecise predictions at ambiguous boundary of anatomies.</p><blockquote><p>​        为了解决联邦不可视域泛化的问题，我们提出以一种隐私保护的方式让每个客户端能够接触多种数据分布。该想法灵感来源于：这个想法的动机是，正如视觉心理物理学所揭示的那样，<strong>图像的低级分布（即样式）和高级语义可以分别通过频率空间中的振幅和相位谱</strong>来捕获[13，42，57]。为了解决这个FedDG问题，我们的见解是使每个客户端能够以隐私保护的方式访问多源数据分布。这一想法的动机是，图像的低级分布( 即 ,风格 )和高级语义可以分别由频率空间中的幅度和相位谱捕获，如视觉心理物理学所揭示的[  13,42,57 ]。我们可以考虑通过客户端上传分布信息交换这些振幅谱，同时保持本地这些带余核心语义 的频谱信息得到隐私保护。我们可以考虑在客户端之间交换这些幅度谱来传输分布信息(  cf .图 1 ( b  )，同时在本地保留具有核心语义的相位谱来进行隐私保护。基于此，我们设计了一个连续频率空间插值机制，能够为在本地和已上传分布中插值，为每个本地用户丰富已建立的多域联邦分布。这促使本地训练能够得到域不变性，有利于专用的密集的分布空间。利用这些已建立的分布，我们通过情景训练范式将局部学习暴露给域分布偏移，以增强局部参数的可泛化性。设计了一种新的元更新目标函数来指导关注边界区域的跨域优化。这对于医学图像分割应用尤其重要，因为泛化误差往往来自于解剖结构模糊边界处的不精确预测。</p></blockquote><p> Our main contributions are highlighted as follows:</p><ul><li>We tackle the novel and practical problem of  Federated Domain Generalization. To the best of our knowledge, this is the first work to improve generalizability on completely unseen domains for federated models.</li><li>We propose a privacy-preserving solution to learn the generalizable FL model under decentralized datasets, through an effective continuous frequency space interpolation mechanism across clients.</li><li>We present a novel boundary-oriented episodic learning scheme for the local training at a client, which exposes local optimization to ==domain shifts== and enhances model generalizability at ambiguous boundary area.</li><li>We conduct extensive experiments on two typical medical image segmentation tasks, i.e., retinal fundus image segmentation (four datasets) and prostate MRI segmentation (six datasets). Our achieved superior performance over state-of-the-arts and in-depth analytical experiments demonstrate the efficacy of our approach.</li></ul><blockquote><p>我们的主要贡献突出如下：</p><ul><li>我们攻克了联邦域泛化这一新颖而实际的问题。据我们所知，这是第一个改进联邦模型在完全看不见的域上的可推广性的工作。</li><li>我们提出了一种隐私保护方案，通过跨客户端的有效连续频率空间插值机制，学习分散数据集下的可推广FL模型。</li><li>我们提出了一种新颖的面向边界的情景学习方案用于客户端的局部训练，它将局部优化暴露给域转换，并增强了模型在模糊边界区域的泛化能力。</li><li>我们对两个典型的医学图像分割任务进行了广泛的实验，即视网膜眼底图像分割(四个数据集)和前列腺MRI分割(六个数据集)。我们取得了优于先进水平的性能，深入的分析实验证明了我们的方法的有效性。</li></ul></blockquote><h4 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a><strong>2. Related Work</strong></h4><h5 id="2-1-Federated-Learning-in-Medical-Imaging"><a href="#2-1-Federated-Learning-in-Medical-Imaging" class="headerlink" title="2.1. Federated Learning in Medical Imaging"></a><strong>2.1. Federated Learning in Medical Imaging</strong></h5><p>​        Federated learning [15, 20, 36, 56] provides a promising privacy-preserving solution for multi-site data collaboration, which develops a global model from decentralized datasets by aggregating the parameters of each local client while keeping data locally. Representatively, McMahan etal. [36] propose the popular federated averaging algorithm for communication-efficient federated training of deep networks. With the advantage of privacy protection, FL has recently drawn increasing interests in medical image applications [4, 18, 22, 27, 45, 49, 51]. Sheller et al. [49] is a pilot study to investigate the collaborative model training without sharing patient data for the multi-site brain tumor segmentation. Later on, Li et al. [27] further compare several weights sharing strategies in FL to alleviate the effect of data imbalance among different hospitals. However, these works all focus on improving performance on internal clients, without considering the generalization issue for unseen domains outside the federation, which is crucial for wide clinical usability. Latest literature has studied a related problem of unsupervised domain adaptation in FL paradigm [28, 41], whereas these methods typically require data from the target domain to adapt the model. In practice, it would be time consuming or even impractical to collect data from each new hospital before model deployment. Instead, our tackled new problem setting of FedDG aims to directly generalize the federated model to completely unseen domains, in which no prior knowledge from the target domain is needed.</p><blockquote><p>​        联邦学习[15,20,36,56]为多站点数据协作提供了一个很有前途的隐私保护解决方案，该解决方案通过聚合每个本地客户端的参数，同时在本地保存数据，从分散的数据集开发一个全局模型。典型地, 麦克马汉等等。[36]提出了一种流行的联合平均算法，用于深度网络的通信高效联合训练。随着隐私保护的优势，FL最近在医学图像应用中越来越受到关注[4,18,22,27,45,49,51]。Sheller等人的[49]是一项试点研究，旨在调查无需共享患者数据的协作模型训练用于多位点脑肿瘤分割。Li et al.[27]进一步比较了FL中的几种权重共享策略，以缓解不同医院之间数据不平衡的影响。然而，这些工作都关注于提高内部客户机的性能，而没有考虑联邦之外的未查看领域的泛化问题，而这对广泛的临床可用性至关重要。最新的文献研究了FL范式中无监督域适应的相关问题[28,41]，而这些方法通常需要目标域的数据来适应模型。在实践中，在模型部署之前从每个新医院收集数据将是耗时的，甚至是不切实际的。相反，我们处理的FedDG的新问题设置旨在直接将联邦模型泛化到完全不可见的领域，在这些领域中不需要来自目标领域的先验知识。</p></blockquote><h5 id="2-2-Domain-Generalization"><a href="#2-2-Domain-Generalization" class="headerlink" title="2.2. Domain Generalization"></a>2.2. Domain Generalization</h5><p>​        Domain generalization [5, 9, 12, 14, 43, 47, 58, 59] aims to learn a model from multiple source domains such that it can directly generalize to unseen target domains. Among previous efforts, some methods aim to learn domain-invariant representations by minimizing the domain discrepancy across multiple source domains [11,16, 26, 29, 32, 37, 38, 55]. For example, Motiian etal. [37] utilize a contrastive loss to minimize the distance between samples from the same class but different domains. Some other DG methods are based on meta-learning, which is an episodic training paradigm by creating meta-train and meta-test splits at each iteration to stimulate domain shift [1, 8, 24, 30]. Li et al. [30] employ meta-learning to learn an ==auxiliary loss== that guides the feature extractor to learn more generalized features. However, these methods typically require centralizing multi-domain data in one place for learning, which violates privacy protection in federated learning setting with decentralized datasets.</p><blockquote><p>​        域泛化 [5， 9， 12， 14， 43， 47， 58， 59] 旨在从多个源域中学习模型，以便它可以直接泛化到看不见的目标域。在以前的研究中，一些方法旨在通过最小化多个源域之间的域差异来学习域不变表示[11，16，26，29，32，37，38，55]。例如，Motiian etal。[37]利用对比损失来最小化来自同一类别但不同域的样本之间的距离。其他一些DG方法基于元学习，这是一种情节训练范式，通过在每次迭代时创建元训练和元测试拆分来刺激域转移[1，8，24，30]。Li等人[30]利用元学习来学习辅助损失，该损失指导特征提取器学习更广义的特征。但是，这些方法通常需要将多域数据集集中在一个学习位置，这违反了具有分散数据集的联合学习设置中的隐私保护。</p></blockquote><p>​         There are other methods tackling DG by manipulating deep neural network architectures [19, 23, 35], leveraging self-supervision signals [3, 54], designing training heuristics [17, 25], or conducting data augmentations [48, 53, 60,61], which are free from requirement of data centralization. Representatively, Carlucci et al. [3] adopt self-supervised learning by solving ==jigsaw puzzles==. Zhang et al. [60] conduct extensive data augmentations on each source domain by stacking a series of transformations. These approaches, when applied in FL paradigm, can helpfully act as regularizations for the local training with individual source domain data, yet hardly exploit the rich data distributions across domains. Our method instead, aims to transfer the distribution information across clients to make full use of the multi-source distributions towards FedDG. We also experimentally compare with these typical methods under the FL setting with superior performance demonstrated.</p><blockquote><p>​        处理DG的其他方法包括操纵深度神经网络架构[19,23,35]、利用自我监督信号[3,54]、设计训练启发式[17,25]或进行数据增强[48,53,60,61]，这些方法都不需要数据集中化。具有代表性的是，Carlucci等人通过拼图游戏采用自我监督学习。Zhang等人通过叠加一系列变换对每个源域进行广泛的数据增强。这些方法在FL范例中应用时，可以有效地作为个别源域数据的局部训练的规范化，但很难利用跨域的丰富数据分布。相反，我们的方法旨在跨客户端传递分发信息，以充分利用面向FedDG的多源分发。我们还与这些典型的方法进行了实验比较，在FL设置下显示了优越的性能。</p></blockquote><h4 id="3-Method"><a href="#3-Method" class="headerlink" title="3. Method"></a><strong>3. Method</strong></h4><p>​        We start with the formulation for federated domain generalization and its challenges in medical image segmentation scenario. We then describe the proposed method Episodic Learning in Continuous Frequency Space(ELCFS) to explicitly address these challenges. An overview of the method is shown in Fig. 2.</p><blockquote><p>​        我们从联合域泛化的公式及其在医学图像分割场景中的挑战开始。然后，我们描述了所提出的连续频率空间中的情景学习（ELCFS）方法，以明确解决这些挑战。该方法的概述如图2所示。</p></blockquote><p><img src="/images/FedDG.assets/image-20211204091653731.png" alt="image-20211204091653731"></p><p>Figure 2. Overview of our proposed episodic learning in continuous frequency space (ELCFS). The distribution information is exchanged across clients from frequency space with an continous interpolation mechanism, enabling each local client to access the multi-source distributions. An episodic training paradigm is then established to expose the local optimization to domain shift, with explicit regularization to promote domain-independent feature cohesion and separation at the ambiguous boundary region for improving generalizability.</p><blockquote><p>图2 .综述我们提出的连续频率空间的幕式学习( ELCFS )。分布信息通过频率空间的连续插值机制在客户端之间交换，使得每个本地客户端都能够访问多源分布。然后建立了一种情景训练范式，将局部优化暴露在领域转移中，并通过显式正则化来促进领域无关特征在模糊边界区域的凝聚和分离，以提高泛化能力。</p></blockquote><h5 id="3-1-Federated-Domain-Generalization"><a href="#3-1-Federated-Domain-Generalization" class="headerlink" title="3.1. Federated Domain Generalization"></a><strong>3.1. Federated Domain Generalization</strong></h5><p>​        <strong>Preliminaries:</strong> In FedDG, we denote$ (X,Y)$ as the joint image and label space of a task, $S =\{ S^1,S^2,…,S^K \}$ as the set of $K$ distributed source domains involved in federated learning. Each domain contains data and label pairs of $S^k= \{ ( x^k_i, y_i^k)\}^{N^k}_{i=1}$ ,  which are sampled from a domain specific distribution  $(X^ k, Y)$. The goal of FedDG is to learn a model  $f_θ : X → Y$ using the $K$  distributed source domains, such that it can directly generalize to a completely unseen testing domain $T$​ with a high performance.</p><p>​        Standard federated learning paradigm involves the communication between a central server and the $K$​ local clients. At each federated round $t$​, every client $k$​  will receive the same global model weights $θ$​ from the central server and update the model with their local data $S^k$​ for $E$​ epochs. The central server then collects the local parameters $ θ^k$​ from all clients and aggregates them to update the global model. This process repeats until the global model converges. In this work, we consider the most popular federated averaging algorithm (FedAvg) [36], which aggregates the local parameters with weights in proportional to the size of each local dataset to update the global model, i.e.,  $θ = {\sum ^K _{k=1}} \frac {N^k}Nθ^ k $​,where $N = {\sum ^K _{k=1}} N^k$​​​ . It is worth noting that our method can also be flexibly incorporated to other FL backbones.</p><blockquote><p>​        <strong>预备知识：</strong>在FedDG中，$ (X,Y)$表示任务的联合图像和标记空间，$S =\{ S^1,S^2,…,S^K \}$表示参与联合学习的K个分布式源域集合。每个域包含$S^k= \{ ( x^k_i, y_i^k)\}^{N^k}_{i=1}$的数据和标签对，这些数据和标签对是从特定域分布$(X^ k, Y)$中采样的。FedDG的目标是利用K个分布式源域学习一个模型$f_θ : X → Y$​，使其能够直接泛化到一个完全看不到的高性能的测试域T。</p><p>​        标准的联邦学习范式涉及中心服务器与K个本地客户端之间的通信。在每个联邦轮 t，每个客户端 k将从中央服务器收到相同的全局模型权值θ，并以它们的本地数据$S^k$更新模型，用于E 个 epochs。然后，中心服务器从所有客户端收集本地参数$ θ^k$，并将其聚合以更新全局模型。这个过程重复，直到全局模型收敛。在这项工作中，我们考虑了最流行的联邦平均算法( FedAvg ) ，它将局部参数按照每个局部数据集的大小按比例聚集起来，以更新全局模型，即$θ = {\sum ^K _{k=1}} \frac {N^k}Nθ^ k $，其中$N = {\sum ^K _{k=1}} N^k$​。值得注意的是，我们的方法也可以灵活地纳入其他FL骨干（网络）。</p></blockquote><p>​        <strong>Challenges:</strong> With the goal of unseen domain generalization, a model is expected to thoroughly investigate the multi-source data distributions to pursue domain-invariance of its learned latent space. However, the federated setting in the specific medical image segmentation scenario poses several challenges for that. ==<em>First</em>==, the multi-source data in FL are stored distributedly and the learning at each client can only access its individual local distribution, which constrains to make full use of the multi-source distributions to learn generalizable parameters. ==<em>Second</em>==, though FL has collaborated multi-source data, the medical images acquired from different clinical sites can present large heterogeneity. This leads to distinct distributions among the collaborative datasets, which is insufficient to ensure domain invariance in a more continuous distribution space to attain good generalizability in complex clinical environments. ==Third==, the structure of medical anatomises usually present high ambiguity around its boundary region, raising challenge for previous DG techniques that typically lacks assurance for the domain-invariance of features in such ambiguous region.</p><blockquote><p>​        <strong>挑战:</strong>以未知领域泛化为目标，期望模型深入研究多源数据分布，以追求其学习的潜在空间的领域不变性。然而，特定的医学图像分割场景中的联邦设置对此提出了一些挑战。==首先==，FL中的多源数据是分布式存储的，每个客户端的学习只能访问其单独的局部分布，这就限制了充分利用多源分布来学习可概化参数。==第二==,虽然FL合作了多源数据，但从不同临床站点获得的医学图像存在很大的异质性。这导致协同数据集之间存在不同的分布，这不足以确保在更连续的分布空间中具有领域不变性，从而在复杂的临床环境中获得良好的泛化性。 ==第三==，医学解剖的结构通常在其边界区域具有高度的模糊性，这对以往的DG技术提出了挑战，通常缺乏对这种模糊区域特征的域不变性的保证。</p></blockquote><h5 id="3-2-Continuous-Frequency-Space-Interpolation"><a href="#3-2-Continuous-Frequency-Space-Interpolation" class="headerlink" title="3.2. Continuous Frequency Space Interpolation"></a><strong>3.2. Continuous Frequency Space Interpolation</strong></h5><p>​        To address the restriction of decentralized datasets, the foundation of our solution is to exchange the distribution information across clients, such that each local client can get access to multi-source data distributions for learning generalizable parameters. Considering that sharing raw images is forbidden, <strong>we propose to exploit the information inherent in the frequency space, which enables to separate the distribution (i.e. style) information from the original images to be shared between clients without privacy leakage</strong>. </p><p>​        Specifically, given a sample  $x^k_i∈R^{H×W×C} $  (C = 3 for RGB image and C = 1 for grey-scale image) from the $k-th$ client, we can obtain its frequency space signal through fast Fourier transform [39] as:</p><script type="math/tex; mode=display">F(x^k_i)(u,v,c) = \sum ^{H−1}_{h=0} \sum ^{W-1}_{w=0} x^k_i(h, w,c)e^{−j2π(\frac hHu+ \frac wWv)} (1)</script><p>This frequency space signal  $F(x^k_i)$ can be further decomposed to an amplitude spectrum $ A^k_i ∈ R^{H×W×C}$ and  a phase spectrum $ P^k_i ∈ R^{H×W×C}$ which respectively reflect the low-level distributions (e.g. style) and high-level semantics (e.g. object) of the image. To exchange the distribution information across clients, we first construct a distribution bank $A = [A^1 , …, A^K]$, where each $ A^k = \{ A^k_i \}^{N^k}_{i=1}$ contains all amplitude spectrum of images from the <em>k</em>-th client,representing the distribution of $X^k$​ . This bank is then made accessible to all clients as shared distribution knowledge.</p><blockquote><p>​        为了解决分散数据集的限制，我们的解决方案的基础是在客户端之间交换分布信息，使得每个本地客户端都可以访问多源数据分布来学习可泛化的参数。考虑到不允许共享原始图像，我们提出利用频率空间中固有的信息，使分布(即风格)信息与原始图像分离，以便在客户端之间共享，而不造成隐私泄露。</p><p>​        具体来说，给定一个$k-th$客户端的样本$x^k_i∈R^{H×W×C} $ (  RGB图像 C = 3 ,灰度图像 C = 1 )，我们可以通过快速傅里叶变换得到其频率空间信号：</p><script type="math/tex; mode=display">F(x^k_i)(u,v,c) = \sum ^{H−1}_{h=0} \sum ^{W-1}_{w=0} x^k_i(h, w,c)e^{−j2π(\frac hHu+ \frac wWv)} (1)</script><p>这个频率空间信号$F(x^k_i)$可以进一步分解为一个幅度谱$ A^k_i ∈ R^{H×W×C}$和一个相位谱$ P^k_i ∈ R^{H×W×C}$，分别反映图像的低层分布(如样式)和高层语义(如对象)。为了在客户端之间交换分布信息，我们首先构造一个分布库$A = [A^1 , …, A^K]$，其中每个$ A^k = \{ A^k_i \}^{N^k}_{i=1}$包含来自k -th客户端的所有图像幅度谱，代表$X^k$​的分布。然后将该库作为共享分发知识，使所有客户都可以访问。</p></blockquote><p>​        Next, we design a continuous interpolation mechanism within the frequency space, aiming to transmit multi-source distribution information to a local client leveraging the distribution bank. As shown in the left part of Fig. 2, given a local image $x^k_i$ at client $k$, we can replace some low-frequency component of its amplitude spectrum with the ones in distribution bank $A$, while its phase spectrum is unaffected to preserve the semantic content. As an outcome, we can generate images with transformed appearances exhibiting distribution characteristics of other clients. More importantly, we continuously interpolate between amplitude spectrum of local data and the transferred amplitude spectrum of other domains. In this way, we can enrich the established multi domain distributions for each local client, benefiting from a dedicated dense space with smooth distribution changes. Formally, this is achieved by randomly sampling an amplitude spectrum item $ A^n_j (n \neq k)$ from the distribution bank,then synthesize a new amplitude spectrum by interpolating between $A^k_i$ and $A^n_j$ . Let  $ M = \mathbb{1}_{(h,w)}∈[−αH:αH,−αW:αW]$ be a binary mask which controls the scale of low-frequency component within amplitude spectrum to be exchanged, whose value is 1 at the central region and 0 elsewhere. Denote $λ$ as the interpolation ratio adjusting the amount of distribution information contributed by $A^k_i$ and $A^n_j$ , the generated new amplitude spectrum interacting distributions for local client $k$ and external client $n$ is represented as:</p><script type="math/tex; mode=display">A^{k→n}_{i,λ} = (1−λ)A^k_i∗(1−M) + λA^n_j∗M.(2)</script><blockquote><p>​        接下来，我们设计了一个在频率空间内的连续插值机制，旨在利用分布库将多源分布信息传输到本地客户端。如图2左侧所示，给定客户端$k$上的局部图像$x^k_i$，我们可以用分布库 $A$替换其幅谱中的低频分量，而相位谱不受影响，保留语义内容。因此，我们可以生成具有改变外观的图像，显示其他客户端的分布特征。更重要的是，我们不断地在本地数据的振幅谱和其他域的传输振幅谱之间进行插值。这样，我们可以丰富每个本地客户建立的多域分布，得益于专用的密集空间，分布变化平稳。正式地说，这是通过从分布库中随机抽样一个振幅谱项$A^n_j (n \neq k)$，然后通过插值$A^k_i$和$A^n_j$，合成一个新的振幅谱来实现的。设$ M = \mathbb{1}_{(h,w)}∈[−αH:αH，−αW:αW]$为二元掩模，控制振幅谱内低频分量的交换比例，其中心区域值为1，其他区域值为0。其中$λ$为调整$A^k_i$和$A^n_j$贡献的分布信息量的插补比，本地客户$k$和外部客户$n$产生的新的振幅谱相互作用分布表示为:</p><script type="math/tex; mode=display">A^{k→n}_{i,λ} = (1−λ)A^k_i∗(1−M) + λA^n_j∗M.(2)</script></blockquote><p>After obtaining the interpolated amplitude spectrum $A^{k→n}_{i,λ}$​ ,we then combine it with the original phase spectrum to generate the transformed image via inverse Fourier transform $ F^{−1}$​​ as follows:</p><script type="math/tex; mode=display">x^{k→n}_{i,λ}=F^{−1}(A^{k→n}_{i,λ},P_i^k), (3)</script><p>where the generated image $x^{k→n}_{i,λ}$ preserves the original semantics of $x^k_i$ while carrying a new distribution interacted between $X^k$ and $X^n$. In our implementation, the interpolation ratio $λ$ will be dynamically sampled from [0.0,1.0] to generate images via a continuous distribution space. As intuitive examples shown in Fig. 2, our interpolation operation allows the generated samples to bridge the intermediate space between distinct distributions across domains. Note that the method described above does not require heavy computations, thus can be performed online as the local learning goes on. Practically, for each input $x^k_i$ ,we will sample an amplitude spectrum $A^n_j$ from the distribution bank for each external client $n \ne k$, and transform its image appearance as Eqs. (2-3). Through this, we obtain $K−1$ transformed images $ \{ x^{k→n}_{i,λ} \}  _ {n \ne k} $ of different distributions, which share the same semantic label as $x^k_i$ . For ease of denotation, we represent these transformed images as $t^k_i$ hereafter, i.e. $t^k_i =\{ x^{k→n}_{i,λ} \}_{n \ne k}$. Furthermore, this approach does not violate the privacy concern since the phase spectrum containing core semantics are retained at each client throughout the whole process, and the raw images cannot be reconstructed with the amplitude spectrum alone [46].</p><blockquote><p>在得到插值幅度谱$A^{k→n}_{i,λ}$之后，我们将其与原始相位谱结合，通过逆傅里叶变换$ \mathcal F^{−1}$生成变换图像，如下所示：</p><script type="math/tex; mode=display">x^{k→n}_{i,λ}=\mathcal F^{−1}(A^{k→n}_{i,λ},P_i^k), (3)</script><p>其中，生成的图像$x^{k→n}_{i,λ}$保留了$x^k_i$原有的语义，同时在$X^k$和 $X^n$之间传递了一个新的分布。在我们的实现中，插值比 λ 将从[  0.0,1.0 ]中动态采样，通过连续的分布空间生成图像。如图2所示的直观示例，我们的插值操作允许生成的样本在跨域的不同分布之间架起中间空间。请注意，上面描述的方法不需要大量的计算，因此可以随着本地学习的进行在线执行。实际中，对于每个输入$x^k_i$，我们将为每个外部客户端  $n \ne k$从分布库中采样一个幅值谱$A^n_j$，并将其图像外观变换为Eqs.( 2 - 3 )。通过这种方法，我们得到了不同分布的$K−1$变换图像$ \{ x^{k→n}_{i,λ} \}  _ {n \ne k} $，它们具有与$x^k_i$相同的语义标签。为了便于表示，我们将这些变换后的图像表示为$t^k_i$，即$t^k_i =\{ x^{k→n}_{i,λ} \}_{n \ne k}$​ .此外，这种方法并不违反隐私关注，因为包含核心语义的相位谱在整个过程中保留在每个客户端，并且原始图像不能单独用幅度谱重建。</p></blockquote><h5 id="3-3-Boundary-oriented-Episodic-Learning"><a href="#3-3-Boundary-oriented-Episodic-Learning" class="headerlink" title="3.3. Boundary-oriented Episodic Learning"></a>3.3. Boundary-oriented Episodic Learning</h5><p>​        The above constructed continuous multi-source distributions at each local client provide the materials to learn generalizable local parameters. In the following, we carefully design a boundary-oriented episodic learning scheme for local training, by particularly meeting challenges of model generalization in medical image segmentation scenario.</p><p>​        <strong>Episodic learning at local client:</strong> We establish the local training as an episodic meta-learning scheme, which learns generalizable model parameters by simulating train/test domain shift explicitly. Note that in our case, the domain shift at a local client comes from the data generated from frequency space with different distributions. Specifically, in each iteration, we consider the raw input $x^k_i$ as meta-train and its counterparts $t^k_i$ generated from frequency space as meta-test presenting distribution shift (cf. Fig. 2). The meta-learning scheme can then be decoupled to two steps. First, the model parameters $θ^k$ are updated on meta-train with segmentation Dice loss  $\mathcal L_{seg}$:</p><script type="math/tex; mode=display">\widehatθ^k= θ^k−β∇_{θ^k} \mathcal L_{seg}(x^k_i; θ^k), (4)</script><p>where <em>β</em> denotes the learning rate for the inner-loop update. Second, a meta-update is performed to virtually evaluate the updated parameters $\widehatθ^k$​ on the held-out meta-test data $t^k_i$​ with a meta-objective $\mathcal  L _{meta}$​. Crucially, this objective is computed with the updated parameters $θ^k$​ , but optimized w.r.t the original parameters $θ^k$​ . Such optimization paradigm aims to train the model such that its learning on source domains can further fulfill certain properties that we desire in unseen domains, which are quantified by $\mathcal  L _{meta}$​.</p><blockquote><p>​        上述构造的连续多源分布在每个局部客户端提供了材料，以学习可泛化的局部参数。接下来，我们针对医学图像分割场景中模型泛化的挑战，精心设计了一种面向边界的episodic learning方案用于局部训练。</p><p>​        <strong>本地客户情景学习</strong>：我们将本地训练建立为情景元学习方案，通过显式模拟训练/测试域转换来学习可泛化的模型参数。请注意，在我们的案例中，本地客户机的域转换来自于从具有不同分布的频率空间生成的数据。具体来说，在每次迭代中，我们将原始输入$x^k_i$视为元训练，而从频率空间生成的对应项$t^k_i$视为表示分布偏移的元测试(参见参考资料图2 )。然后，元学习方案可以分解为两个步骤。首先，在分割Dice损失$\mathcal L_{seg}$的元训练集上更新模型参数$θ^k$：</p><script type="math/tex; mode=display">\widehatθ^k= θ^k−β∇_{θ^k} \mathcal L_{seg}(x^k_i; θ^k), (4)</script><p>其中 β表示内环更新的学习率。其次，使用元目标$\mathcal  L _{meta}$在保留的元测试数据$t^k_i$上执行元更新来虚拟评估更新后的参数$\widehatθ^k$。最重要的是，这个目标是用更新的参数$θ^k$计算的，但优化了原始参数$θ^k$。这种优化范式旨在训练模型，使其在源域上的学习能够进一步满足我们在未知域中所期望的某些属性，这些属性由$\mathcal  L _{meta}$量化。</p></blockquote><p>​        <strong>Boundary-oriented meta optimization:</strong> We define the $\mathcal  L _{meta}$ with considering specific challenges in medical image segmentation. Particularly, it is observed that the performance drop of segmentation results at unseen domains outside federation often comes from the ambiguous boundary area of anatomies. To this end, we design a new boundary-oriented objective to enhance the domain invariant boundary delineation, by carefully learning from the local data $x^k_i$ and the corresponding $t^k_i$ generated from frequency space with multi-source distributions.  ==The idea is to regularize the boundary-related and background-related features of these data to respectively cluster to a compact space regardless of their distributions while reducing the clusters overlap.==This is crucial, since if the model cannot project their features around boundary area with distribution-independent class-specific cohesion and separation, the predictions will suffer from ambiguous decision boundaries and still be sensitive to the distribution shift when deployed to unseen domains outside federation.         Specifically, we first extract the boundary-related and background-related features for the input samples. Given image $x^k_i$ with segmentation label $y_i^k$ , we can extract its binary boundary mask $y_{i_bd}^k$ and background mask $y_{i_bg}^k$ with morphological operations on $y_i^k$ . Here, the mask $y_{i_bg}^k$ only contains background pixels around the anatomy boundary instead of from the whole image, as we expect to enhance the discriminability for features around the boundary region. Let $Z_i^k$ denote the activation map extracted from layer $l$, which is interpolated with bilinear interpolation to keep consistent dimensions as $y_i^k$ . Then the boundary-related and background-related features of  $x^k_i$ can be extracted from $Z_i^k$ with masked average pooling over <em>$y_{i_bd}^k$</em> and  $y_{i_bg}^k$ as:</p><script type="math/tex; mode=display">h^k_{i\_bd} = \frac {\sum _{h,w} Z^k_i * y^k_{i\_bd} }{\sum _{h,w} y^k_{i\_bd}} ;h^k_{i\_bg} = \frac {\sum _{h,w} Z^k_i * y^k_{i\_bg} }{\sum _{h,w} y^k_{i\_bg}} (5)</script><p>where $*$ denote element-wise product. The produced $h^k_{i_bd}$ and  $h^k_{i_bg}$ are single-dimensional vectors, representing the averaged region-level features of the boundary and background pixels. By further performing the same operation for $K-1$ transformed images $t^k_i$ with different distributions transferred from the frequency space, we accordingly obtain together $K$  boundary-related and $K$ background-related features.</p><blockquote><p>​        <strong>面向边界的元优化</strong>：考虑到医学图像分割中的特定挑战，我们定义了$\mathcal  L _{meta}$。特别地，观察到分割结果在联邦之外的未知域上的性能下降往往来自于解剖学的模糊边界区域。为此，我们设计了一个新的面向边界的目标，通过仔细学习本地数据$x^k_i$和从具有多源分布的频率空间生成的相应 $t^k_i$，来增强域不变边界定界。其思想是将这些数据的边界相关特征和背景相关特征分别聚类到紧凑的空间中，不管它们的分布如何，同时减少聚类重叠。这一点至关重要，因为如果模型不能将它们的特性投影到与分布无关的类特定衔接和分离的边界地区，那么预测将面临模糊的决策边界，并且在部署到联邦到联邦之外的不可观察的域时，仍然对分布转移敏感。</p><p>​        具体来说，我们首先提取输入样本的边界相关和背景相关特征。给定具有分割标记 $y_i^k$的图像 $x^k_i$，可以在 $y_i^k$上用形态学运算提取其二值边界掩模$y_{i_bd}^k$和背景掩模 $y_{i_bg}^k$。在这里，掩模 $y_{i_bg}^k$只包含解剖边界周围的背景像素，而不是来自整个图像，因为我们期望增强对边界区域周围特征的区分能力。令$Z_i^k$表示从第l层提取的激活图，该图用双线性插值插值，保持与$y_i^k$一致的维数。然后从$Z_i^k$中提取与边界相关和背景相关的$x^k_i$特征，掩蔽平均池化过 $y_{i_bd}^k$ 和$y_{i_bg}^k$​为：</p><script type="math/tex; mode=display">h^k_{i\_bd} = \frac {\sum _{h,w} Z^k_i * y^k_{i\_bd} }{\sum _{h,w} y^k_{i\_bd}} ;h^k_{i\_bg} = \frac {\sum _{h,w} Z^k_i * y^k_{i\_bg} }{\sum _{h,w} y^k_{i\_bg}} (5)</script><p>其中*表示元素乘积。产生的$h^k_{i_bd}$和$h^k_{i_bg}$为一维向量，分别代表边界和背景像素的平均区域级特征。进一步对从频率空间传递的不同分布的$K- 1$变换图像$t^k_i$进行同样的运算，得到 K个边界相关特征和 K个背景相关特征。</p></blockquote><p>​        Next, we enhance the domain-invariance and discriminability of these features, by regularizing their intra-class cohesion and inter-class separation regardless of distributions. Here, we employ the well-established InfoNCE [6] objective to impose such regularization. Denote ($h_m$, $h_p$) as a pair of features, which is a positive pair if  $h_m$ and  $h_p$ are of the same class (both boundary-related or background related) and otherwise negative pair. In our case, the In foNCE loss is defined over each positive pair ($h_m$, $h_p$) within the  $2 × K$ region-level features as:</p><script type="math/tex; mode=display">\mathscr l(h_m,h_p)=-log{\frac {exp(h_m \bigodot {h_p/{\tau}})} {\sum ^{2K}_{q=1,q \ne m} \mathbb F(h_m,h_q)·exp(h_m \bigodot h_q/\tau)},(6)}</script><p>where $\bigodot $ denote the cosine similarity: $a\bigodot b = \frac {\langle a,b\rangle} {||a||_2||b||_2}$;the value of $ \mathbb F(h_m,h_q) $ is 0 and 1 for positive and negative pair respectively; $τ$ denotes the temperature parameter. The final loss $\mathcal L_{boundary}$ is the average of  $\mathscr l$​​ over all positive pairs:</p><script type="math/tex; mode=display">\mathcal L_{boundary}=\sum ^{2K}_{m=1} \sum ^{2K}_{p=m+1} \frac {(1- \mathbb F(h_m,h_p))·\mathscr l(h_m,h_p)} {B(K,2)\times 2},(7)</script><p>where $B(K,2)$ is the number of combinations.</p><p>​        <strong>Overall local learning objective:</strong> The overall meta objective is composed of the segmentation dice loss $\mathcal L_{seg}$ and the boundary-oriented objective $L_{boundary}$​ as:</p><script type="math/tex; mode=display">\mathcal L_{meta} = \mathcal L_{seg}(t^k_i;\widehatθ^k) + \gamma \mathcal L_{boundary}(x^k_i, t^k_i;\widehatθ^k). (8)</script><p>where $\widehatθ^k$ is the updated parameter from Eq. 4, $\gamma $ is a balancing hyper-parameter. Finally, both the inner-loop objective and meta objective will be optimized together with respect to the original parameter $θ^k$​ as:</p><script type="math/tex; mode=display">arg_{θ^k}min  \mathcal L_{seg}(x^k_i;θ^k)+\mathcal L_{meta}(x^k_i, t^k_i;\widehatθ^k).(9)</script><p>In a federated round, once the local learning is finished, the local parameters $θ^k$ from all clients will be aggregated at the central server to update the global model.</p><blockquote><p>​        接下来，我们通过正则化这些特征的类内聚和类间分离（无论分布如何）来增强这些特征的域不变性和可判别性。在这里，我们采用完善的InfoNCE [6]目标来实施这种正则化。表示 （$h_m$， $h_p$） 作为一对特征，如果 $h_m$ 和 $h_p$ 属于同一类（边界相关或背景相关），则为正对，否则为负对。在我们的例子中，In foNCE 损失在 2 × K$ 区域级特征内的每个正对（$h_m$，$​​h_p）上定义为：</p><script type="math/tex; mode=display">\mathscr  l \ (h_m,h_p)=-log{\frac {exp(h_m \bigodot {h_p/{\tau}})} {\sum ^{2K}_{q=1,q \ne m} \mathbb F(h_m,h_q)·exp(h_m \bigodot h_q/\tau)},(6)}</script><p>其中 $\bigodot $ 表示余弦相似性： $a\bigodot b = \frac {\langle a，b\rangle} {||a||_2||b||_2}$;对于正对和负对，$ \mathbb F(h_m,h_q) $ 的值分别为 0 和 1;$τ$ 表示温度参数。最终损失 $\mathcal L_{boundary}$是所有正对的 $\mathscr l$​ 的平均值：</p><script type="math/tex; mode=display">\mathcal L_{boundary}=\sum ^{2K}_{m=1} \sum ^{2K}_{p=m+1} \frac {(1- \mathbb F(h_m,h_p))·\mathscr l(h_m,h_p)} {B(K,2)\times 2},(7)</script><p>其中 $B（K，2）$ 是组合数。</p><p><strong>总体局部学习目标：</strong>整体元目标由分割骰子损失 $\mathcal L_{seg}$ 和面向边界的目标 $\mathcal L_{boundary}$ 组成:</p><script type="math/tex; mode=display">\mathcal L_{meta} = \mathcal L_{seg}(t^k_i;\widehatθ^k) + \gamma \mathcal L_{boundary}(x^k_i, t^k_i;\widehatθ^k). (8)</script><p>其中 $\widehatθ^k$​ 是从 Eq. 4 更新的参数，$\gamma $​是一个平衡超参数。最后，内循环目标和元目标将相对于原始参数 $θ^k$​ 一起优化为：</p><script type="math/tex; mode=display">arg_{θ^k}min  \mathcal L_{seg}(x^k_i;θ^k)+\mathcal L_{meta}(x^k_i, t^k_i;\widehatθ^k).(9)</script><p>在联合回合中，一旦本地学习完成，来自所有客户端的本地参数 $θ^k$​ 将在中央服务器上聚合以更新全局模型。</p></blockquote><h4 id="4-Experiments"><a href="#4-Experiments" class="headerlink" title="4. Experiments"></a><strong>4. Experiments</strong></h4><p>​    We extensively evaluate our method on two medical image segmentation tasks, i.e., the optic disc and cup segmentation on retinal fundus images [40], and the prostate segmentation on T2-weighted MRI [31]. We first conduct comparison with DG methods that can be incorporated in the federated paradigm, and then provide in-depth ablation studies to analyze our method.</p><blockquote><p>我们广泛评估了我们的方法在两个医学图像分割任务，即视网膜眼底图像的视盘和杯分割和T2加权MRI的前列腺分割。我们首先与可以纳入联邦范式的DG方法进行比较，然后提供深入的消融研究来分析我们的方法。</p></blockquote><h5 id="4-1-Datasets-and-Evaluation-Metrics"><a href="#4-1-Datasets-and-Evaluation-Metrics" class="headerlink" title="4.1. Datasets and Evaluation Metrics"></a>4.1. Datasets and Evaluation Metrics</h5><p>​    We employ <strong>retinal fundus images from 4 different clinical centers</strong> of public datasets [52, 10, 40] for optic<br>disc and cup segmentation. For pre-processing, we center crop a 800 × 800 disc region for these data uniformly, then resize the cropped region to 384×384 as network input. We further collect <strong>prostate T2-weighted MRI images from 6 different data sources</strong> partitioned from the public datasets [2, 21, 31, 33] for prostate MRI segmentation task. All the data are pre-processed to have similar field of view for the prostate region and resized to 384×384 in axial plane. We then normalize the data individually to zero mean and unit variance in intensity values. Note that for both tasks, the data acquired from different clinical centers present heterogeneous distributions due to the varying imaging conditions. The example cases and sample numbers of each data source are presented in ==Fig. 3== Data augmentation of random rotation, scaling, and flipping are employed in the two tasks. For evaluation, we adopt two commonly-used metrics of Dice coefficient (Dice) and Hausdorff distance(HD), to quantitatively evaluate the segmentation results on the whole object region and the surface shape respectively.</p><p><img src="/images/FedDG.assets/image-20220110110541204.png" alt="image-20220110110541204"></p><p>Figure 3. Example cases and slice number of each data source in fundus image segmentation and prostate MRI segmentation tasks.</p><blockquote><p>​    我们使用4个不同临床中心的公开数据集[  52、 10、 40 ]的视网膜眼底图像进行视盘和杯分割。为了进行预处理，我们对这些数据均匀地中心割出一个800×800的圆盘区域，然后将割出的区域调整为384×384作为网络输入。我们进一步从公共数据集[  2、 21、 31、 33 ]中分割的6个不同数据源中采集前列腺T2加权MRI图像，用于前列腺MRI分割任务。所有数据都经过预处理，使前列腺区域具有相似的视野，并在轴面上调整为384×384。然后将数据分别归一化为零均值和单位方差强度值。需要注意的是，对于这两个任务，由于成像条件的不同，来自不同临床中心的数据呈现异质性分布。各数据源的实例案例和样本数如图3所示。两个任务分别采用随机旋转、缩放和翻转的数据增强。为了评价，我们采用Dice系数( Dice )和Hausdorff距离( HD )两个常用的度量指标，分别对整个对象区域和表面形状上的分割结果进行定量评价。</p><p><img src="/images/FedDG.assets/image-20220110110541204.png" alt="image-20220110110541204"></p><p>图3. 在眼底图像分割和前列腺MRI分割任务中每个数据源的病例数和切片数</p></blockquote><h5 id="4-2-Implementation-Details"><a href="#4-2-Implementation-Details" class="headerlink" title="4.2. Implementation Details"></a><strong>4.2. Implementation Details</strong></h5><p>​        In the federated learning process, all clients use the same hyper-parameter settings, and the local model is trained using Adam optimizer with batch size of 5 and Adam momentum of 0.9 and 0.99. The meta-step size and learning rate are both set as $1e^{-3}$ . The interpolation ratio$λ$ in frequency space is randomly sampled within [0.0, 1.0], and we will investigate this parameter in the ablation study. The hyper-parameter <em>α</em> is empirically set as 0.01 to avoid artifacts on the transformed images. The activation map from the last two deconvolutional layers are interpolated and concatenated to extract the semantic features around boundary region, and the temperature parameter  $τ$ is empirically set as 0.05. The weight $γ$ is set as 0.1 and 0.5 in the two tasks to balance the magnitude of the training objectives. We totally train 100 federated rounds as the global model has converged stably, and the local epoch $E$ in each federated round is set as 1. The framework is implemented with Pytorch library, and is trained on two NVIDIA TitanXp GPUs.</p><blockquote><p>​        在联邦学习过程中，所有客户端使用相同的超参数设置，本地模型使用批大小为5、亚当动量为0.9和0.99的Adam优化器进行训练。元步大小和学习速率均设置为1e-3。频率空间的插值比λ在[  0.0,1.0 ]内随机采样，我们将在烧蚀研究中考察这一参数。为了避免变换后图像出现伪影，超参数α被经验设定为0.01。对最后两个反褶积层的激活图进行插值拼接，提取边界区域周围的语义特征，并将温度参数τ经验设定为0.05。在两个任务中权重γ分别设定为0.1和0.5，以平衡训练目标的大小。由于全局模型稳定收敛，我们共训练100个联邦轮，每个联邦轮的局部历元E设为1。该框架使用Pytorch库实现，并在两个NVIDIA TitanXp GPU上进行训练。</p></blockquote><h5 id="4-3-Comparison-with-DG-methods"><a href="#4-3-Comparison-with-DG-methods" class="headerlink" title="4.3. Comparison with DG methods"></a><strong>4.3. Comparison with DG methods</strong></h5><p>​        <strong>Experimental setting:</strong> In our experiments, we follow the practice in domain generalization literature to adopt the leave-one-domain-out strategy, i.e., training on $K-1$ distributed source domains and testing on the one left-out unseen target domain. This results in four generalization settings for the fundus image segmentation task and six settings for the prostate MRI segmentation task. We compare with recent state-of-the-art DG methods that are free from data centralization and can be incorporated into the local learning process in federated paradigm,including: <strong>JiGen [3]</strong> an effective self-supervised learning approach to learn general representations by solving jigsaw puzzles; <strong>BigAug [60]</strong> a method that performs extensive data transformations to regularize general representation learning; <strong>Epi-FCR [25]</strong> a scheme to periodically exchange partial model (classifier or feature extractor) across domains to expose model learning to domain shift; <strong>RSC [17]</strong> a method that randomly discards the dominating features to promote robust model optimization. For the implementation, we follow their public code or paper and establish them in the federated setting. We also compare with the baseline setting,i.e., learning a global model with the basic <strong>FedAvg [36]</strong> algorithm without any generalization technique.</p><p>​        <strong>Comparison results:</strong> ==Table 1== presents the quantitative results for retinal fundus segmentation. We see that different DG methods can improve the overall generalization performance more or less over FedAvg. This attributes to their regularization effect on the local learning to extract general representations. Compared with these methods, our ELCFS achieves higher overall performance and obtains improvements on most unseen sites in terms of Dice and HD for both optic disc and cup segmentation. This benefits from our frequency space interpolation mechanism which presents multi-domain distributions to local client. Specifically, for other DG methods, their local learning still can only access the individual distribution and fail to regularize the features towards domain-invariance in a diverse distribution space. In contrast, our method enables the local learning to take full advantages of the multi-source distributions and explicitly enhances the domain-invariance of features around the ambiguous boundary region. In addition, our ELCFS achieves consistent improvements over FedAvg across all unseen domain settings, with the overall performance increase of 2.02% in Dice and 2.86 in HD. For prostate MRI segmentation, the comparison DG methods generally perform better than FedAvg, but the improvements are relatively marginal. Our ELCFS obtains the highest Dice across all the six unseen sites and HD on most sites. Overall, our method improves over FedAvg for Dice from 85.57% to 87.39% and HD from 12.42 to 10.88, outperforming other DG methods. ==Fig. 4== shows the segmentation results with two cases from unseen domains for each task. It is observed that our method accurately segments the structure and delineates the boundary in images of unknown distributions, whereas other methods sometimes fail to do so.</p><p><img src="/images/FedDG.assets/image-20220110122610403.png" alt="image-20220110122610403"></p><p>Figure 4. Qualitative comparison on the generalization results of different methods in fundus image segmentation (top two rows) and prostate MRI segmentation (bottom two tows).</p><p>Table 1. Comparison of federated domain generalization results on Optic Disc/Cup segmentation from fundus images.</p><p><img src="/images/FedDG.assets/image-20220110121738512.png" alt="image-20220110121738512"></p><blockquote><p>​    <strong>实验设置：</strong> 在我们的实验中，我们遵循域泛化文献中的做法，采用”留一域”策略，即在$K-1$分布式源域上进行训练，并在一个遗漏的看不见的目标域上进行测试。这导致眼底图像分割任务的四个泛化设置和前列腺MRI分割任务的六个设置。我们将与最近最先进的DG方法进行了比较，这些方法不受数据集中化，并且可以以联合范式的形式纳入本地学习过程，包括：<strong>JiGen [3]</strong>一种有效的自我监督学习方法，通过解决拼图来学习一般表示;<strong>BigAug [60]</strong> 一种执行大量数据转换以规范化一般表示学习的方法;<strong>Epi-FCR [25]</strong> 一种跨域定期交换偏模型（分类器或特征提取器）的方案，以将模型学习暴露给域转移;<strong>RSC [17]</strong> 一种随机丢弃主导特征以促进稳健模型优化的方法。对于实现，我们遵循他们的公共代码或论文，并在联合设置中建立它们。我们还与基线设置进行比较，即使用基本的<strong>FedAvg [36]</strong>算法学习全局模型，而无需任何泛化技术。</p><p>​        <strong>比较结果：</strong> ==表1==给出了视网膜眼底分割的定量结果。我们看到，与FedAvg相比，不同的DG方法可以或多或少地提高整体泛化性能。这归因于它们的正则化对局部学习提取一般表示的影响。与这些方法相比，我们的ELCFS实现了更高的整体性能，并在大多数看不见的站点上获得了改进，包括用于视盘和杯子分割的骰子和HD。这得益于我们的频率空间插值机制，该机制向本地客户端呈现多域分布。具体而言，对于其他DG方法，它们的局部学习仍然只能访问单个分布，并且无法在多样化的分布空间中将特征正则化为域不变性。相比之下，我们的方法使局部学习能够充分利用多源分布，并显式增强模糊边界区域周围特征的域不变性。此外，我们的ELCFS在所有看不见的域设置中都实现了对FedAvg的持续改进，Dice的整体性能提高了2.02%，HD提高了2.86%。对于前列腺MRI分割，比较DG方法通常比FedAvg表现更好，但改进相对较小。我们的ELCFS在所有六个看不见的站点中获得最高的骰子，并在大多数站点上获得HD。总体而言，我们的方法比FedAvg的骰子从85.57%提高到87.39%，HD从12.42提高到10.88，优于其他DG方法。==图 4== 显示了每个任务中来自未见过的域的两个案例的分割结果。据观察，我们的方法准确地分割了结构并描绘了未知分布图像中的边界，而其他方法有时则无法做到这一点。    </p><p><img src="/images/FedDG.assets/image-20220110122610403.png" alt="image-20220110122610403"></p><p>图 4.不同方法在眼底图像分割（前两行）和前列腺MRI分割（下两拖）中的泛化结果的定性比较。</p><p>表 1.从眼底图像比较联合域泛化结果对视盘/杯分割的影响。</p><p><img src="/images/FedDG.assets/image-20220110121738512.png" alt="image-20220110121738512"></p></blockquote><h5 id="4-4-Ablation-Analysis-of-Our-Method"><a href="#4-4-Ablation-Analysis-of-Our-Method" class="headerlink" title="4.4. Ablation Analysis of Our Method"></a><strong>4.4. Ablation Analysis of Our Method</strong></h5><p>​        We conduct ablation studies to investigate four key questions regarding our ELCFS: <strong>1)</strong> the contribution of each component to our model performance, <strong>2)</strong> the benefit of the interpolation operation and the choice of <em>λ</em>, <strong>3)</strong> how the semantic feature space around the boundary region is influenced by our method, and <strong>4)</strong> how the numbers of participanting clients affect the performance of our method.</p><p>​        <strong>Contribution of each component:</strong> We first validate the effect of the two key components in our method, i.e. continuous frequency space interpolation (<strong>CFSI</strong>) and Boundary oriented Episodic Learning (<strong>BEL</strong>), by removing them respectively from our method to observe the model performance. As shown in ==Fig. 5==, removing either part will lead to decrease on the generalization performance in different unseen domain settings for the two tasks. This is reasonable and reflects how the two components play complementary roles to the performance of our method, i.e., the generated distributions from CFSI lays foundation for the learning of BEL, and the BEL inversely provides assurance to effectively exploit the generated distributions.</p><p><img src="/images/FedDG.assets/image-20220111102946631.png" alt="image-20220111102946631"></p><p>Figure 5. Ablation results to analyze the effect of the two components (i.e. CFSI and BEL) in our method.</p><p>​        <strong>Importance of continuous interpolation in frequency space:</strong> To analyze the effect of continuous interpolation mechanism in ELCFS , we use t-SNE [34] to visualize the distribution of generated images in fundus image segmentation. As shown in ==Fig. 6 (a)==, the pink points denote the local data of a client, and other points denote the transformed data that are generated with amplitude spectrum from different clients. It appears that fixing <em>λ</em> (left) will lead to several distinct distributions, while the continuous interpolation mechanism (right) can smoothly bridge the distinct distributions to enrich the established multi-domain distributions. This promotes the local learning to attain domain-invariance in adedicted dense distribution space.</p><p>​         We then analyze the effect of the choice of <em>λ</em> on our model performance, for which we conduct experiments with fixed values from 0.0 to 1.0 with a step size 0.2, and continuous sampling in range of [0.0, 0.5], [0.5, 1.0] and [0.0, 1.0]. As shown in ==Fig. 6 (b)==, compared with not transferring any distribution information (i.e., <em>λ</em> = 0), setting <em>λ &gt;</em> 0 as a fixed value can always improve the model performance. Besides, the continuous sampling can further improve the performance and the sampling range of [0.0, 1.0] yields the best results, which reflects the benefits of continuous distribution space for domain generalization.</p><p><img src="/images/FedDG.assets/image-20220111103151298.png" alt="image-20220111103151298"></p><p>Figure 6. (a) Visualization of t-SNE [34] embedding for the original fundus images at a local client (pink points) and the corresponding transformed images with amplitude spectrum from different clients (green, yellow, and blue points); (b) Generalization performance on optic disc segmentation under different settings of interpolation ratio <em>λ</em>, with fifixed value or continuous sampling from different ranges (with error bar from three independent runs).</p><p><img src="/images/FedDG.assets/image-20220111104708578.png" alt="image-20220111104708578"></p><p>Figure 7. (a) Cosine distance between the boundary-related and background-related features; (b) Generalization performance of our method with or without the boundary-oriented meta objective.</p><p><img src="/images/FedDG.assets/image-20220111104923190.png" alt="image-20220111104923190"></p><p>Figure 8. Curves of generalization performance on two unseen prostate datasets (i.e., site A and B) as the number of participating clients increases, using our proposed approach and FedAvg.</p><p>​        <strong>Discriminability at ambiguous boundary region:</strong> We plot the cosine distance between the boundary-related and background-related features, i.e., $ \mathbb E[h_{i _ bd} \bigodot  \ h_{i_ bg}]$, to ana-lyze how the semantic feature space around the boundary region is influenced by our method. In Fig. 7 (a), the two green lines denote the growth of feature distance in our ELCFS and the FedAvg baseline respectively, for samples drawn from the training source domains. We can see that ELCFS yields a higher feature distance, indicating that the features of the boundary and the surrounding background region can be better separated in our method. For the two yellow lines, sample features are drawn from the unseen domains. As expected, the distance is not as high as in source domain, yet our method also presents a clearly higher margin than FedAvg. We also quantitatively analyze the effect of $\mathcal L_{boundary}$ on the model performance. As observed from Fig. 7 (b), removing this objective from the meta optimization leads to consistent performance drops on the generalization performance in different tasks.</p><p>​        <strong>Effect of participating client number:</strong> We further analyze how the generalization performance of our method and FedAvg will be affected when different numbers of hospitals participating in federated learning. Fig. 8 shows the results on prostate MRI segmentation, in which we present the generalization results on two unseen sites with the client number gradually increasing from 1 to <em>K</em> <em>−</em>1. As expected, the models trained with single-source data cannot obtain good results when deployed to unseen domains. The generalization performance increases when more clients participating in the federated training, which is reasonable as aggregating data from multiple sources can cover a more comprehensive data distribution. Particularly, our ELCFS consistently outperforms FedAvg on all generalization settings with different client numbers, demonstrating the stable effificacy of our method to leverage distributed data sources to enhance the generalizability of federated learning model.</p><blockquote><p>我们进行消融研究以调查有关ELCFS的四个关键问题：<strong>1）</strong>每个组件对模型性能的贡献，<strong>2）</strong>插值操作的好处和<em>λ</em>的选择，<strong>3）</strong>边界区域周围的语义特征空间如何受到我们方法的影响，以及<strong>4）</strong>参与客户的数量如何影响我们方法的性能。</p><p><strong>每个组件的贡献：</strong> 我们首先验证了方法中两个关键组件（即连续频率空间插值（<strong>CFSI</strong>）和面向边界的情景学习（<strong>BEL</strong>））的影响，方法是分别从方法中删除它们以观察模型性能。如图 5 所示，删除任一部分都会导致两个任务在不同的未见过的域设置中的泛化性能降低。这是合理的，反映了这两个组件如何对我们方法的性能起到互补作用，即CFSI生成的分布为学习BEL奠定了基础，BEL反向提供了有效利用生成的分布的保证。</p><p><img src="/images/FedDG.assets/image-20220111102946631.png" alt="image-20220111102946631"></p><p>图 5.烧蚀结果用于分析我们方法中两种组分（即CFSI和BEL）的影响。</p><p><strong>连续插值在频率空间中的重要性：</strong> 为了分析连续插值机制在ELCFS中的作用，我们使用t-SNE [34]来可视化底图像分割中生成的图像的分布。如图 6 （a） 所示，粉红色点表示客户端的本地数据，其他点表示使用来自不同客户端的振幅频谱生成的转换数据。似乎固定 <em>λ</em>（左）将导致几个不同的分布，而连续插值机制（右）可以平滑地桥接不同的分布，以丰富已建立的多域分布。这促进了局部学习，以在受约束的密集分布空间中实现域不变性。然后，我们分析了选择 <em>λ</em> 对模型性能的影响，为此，我们进行了从 0.0 到 1.0 的固定值（步长为 0.2）的实验，并在 [0.0， 0.5]、[0.5， 1.0] 和 [0.0， 1.0] 的范围内进行连续采样。如图6（b）所示，与不传输任何分布信息（即<em>λ</em> = 0）相比，将<em>λ&gt;</em> 0设置为固定值总是可以提高模型性能。此外，连续采样可以进一步提高[0.0， 1.0]的采样范围的性能，产生最佳结果，从而反转连续分布空间的益处，用于域泛化。</p><p><img src="/images/FedDG.assets/image-20220111103151298.png" alt="image-20220111103151298"></p><p>图 6.（a） 在本地客户端（粉红色点）嵌入原始眼底图像的t-SNE[34]以及来自不同客户端（绿色，黄色和蓝色点）的振幅光谱的相应转换图像的可视化;（b） 在插值比<em>λ</em>的不同设置下，使用固定值或来自不同范围的连续采样（带有三次独立运行的误差线）下对视盘分割的泛化性能。</p><p><img src="/images/FedDG.assets/image-20220111104708578.png" alt="image-20220111104708578"></p><p>图 7.（a） 与边界有关的地物和与背景有关的地物之间的余弦距离;（b）有或没有面向边界的元目标的方法的泛化性能。</p><p><img src="/images/FedDG.assets/image-20220111104923190.png" alt="image-20220111104923190"></p><p>图 8.使用我们提出的方法和FedAvg，随着参与客户数量的增加，两个看不见的前列腺数据集（即站点A和B）的泛化性能曲线。</p><p><strong>模糊边界区域的可判别性：</strong> 我们绘制边界相关特征和背景相关特征（即 $E[<em>h**i bd</em> <em>h**i bg</em>]$）之间的余弦距离，以分析边界区域周围的语义特征空间如何受到我们方法的影响。在图 7 （a） 中，对于从训练源域中提取的样本，两条绿线分别表示 ELCFS 和 FedAvg 基线中特征距离的增长。我们可以看到ELCFS产生更高的特征距离，表明在我们的方法中边界的特征和周围的背景区域可以更好地分离。对于两条黄线，示例要素是从看不见的域中绘制的。正如预期的那样，距离并不像源域中那么高，但是我们的方法也呈现出明显高于FedAvg的裕量。我们还定量分析了<em>L**边界</em>对模型性能的影响。从图 7 （b） 中可以看出，从元优化中删除此目标会导致不同任务中泛化性能的持续性能下降。</p><p><strong>参与客户数量的影响：</strong> 我们进一步分析了当不同数量的医院参与联合学习时，我们的方法和FedAvg的泛化性能将如何影响。图8显示了前列腺MRI分割的结果，其中我们在两个看不见的部位上呈现了泛化结果，客户数量从1逐渐增加到<em>K</em> <em>−</em>1。正如预期的那样，使用单源数据训练的模型在部署到看不见的领域时无法获得良好的结果。当更多客户端参与联合训练时，泛化性能会提高，这是合理的，因为聚合来自多个源的数据可以涵盖更全面的数据分布。特别是，我们的ELCFS在具有不同客户端编号的所有泛化设置上始终优于FedAvg，证明了我们利用分布式数据源来增强联合学习模型的泛化性的方法的稳定有效性。</p></blockquote><h4 id="5-Conclusion"><a href="#5-Conclusion" class="headerlink" title="5. Conclusion"></a><strong>5. Conclusion</strong></h4><p>​        We have proposed a novel problem setting of federated domain generalization, and presented a novel approach for it with continuous frequency space interpolation and a boundary-oriented episodic learning scheme. The superior effificacy of our method is demonstrated on two important medical image segmentation tasks. Our solution has opened a door in federated learning to enable local client access multi-source distributions without privacy leakage, which has great potential to address other problems encountered in FL, e.g., data heterogeneity. The proposed learning scheme for encouraging boundary delineation is also generally extendable to other segmentation problems.</p><blockquote><p>​        提出了一种新的联邦域泛化问题集，并提出了一种具有连续频率空间插值和边界导向的情景学习方案的新方法。我们的方法的优越有效性在两个重要的医学图像分割任务中得到了证明。我们的解决方案为联合学习打开了一扇门，使本地客户端能够在没有隐私泄漏的情况下访问多源发行版，这对于解决FL中遇到的其他问题（例如数据异构性）具有很大的潜力。为鼓励边界划定而提出的学习方案通常也可扩展到其他分割问题。</p></blockquote><h4 id="6-Acknowledgement"><a href="#6-Acknowledgement" class="headerlink" title="6. Acknowledgement"></a><strong>6. Acknowledgement</strong></h4><p>​        This work was supported by Key-Area Research and Development Program of Guangdong Province, China (2020B010165004); National Natural Science Foundation of China with Project No. U1813204; Hong Kong Innovation and Technology Fund (Project No. ITS/311/18FP and GHP/110/19SZ).</p><blockquote><p>​        这项工作得到了广东省重点区域研究与发展计划（2020B010165004）的支持;国家自然科学基金项目编号U1813204;香港创新科技基金（项目编号：香港创新科技基金）ITS/311/18FP 和 GHP/110/19SZ）。</p></blockquote><h4 id="附录A：术语"><a href="#附录A：术语" class="headerlink" title="附录A：术语"></a>附录A：术语</h4><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>cosine similarity</td><td>余弦相似性</td></tr><tr><td>interpolation</td><td>插值</td></tr><tr><td>domain-invariance</td><td>域不变性</td></tr><tr><td>episodic training paradigm</td><td></td></tr><tr><td>generalizability</td><td>可泛化性</td></tr><tr><td>privacy-preserving</td><td>隐私保护</td></tr><tr><td>prostate</td><td>前列腺</td></tr><tr><td>pilot study</td><td>初步研究；预备试验；试点</td></tr><tr><td>brain tumor</td><td>脑肿瘤；</td></tr><tr><td>unsupervised</td><td>adj. 无人监督的,无人管理的</td></tr><tr><td>prior knowledge</td><td>先验知识</td></tr><tr><td>iteration</td><td>迭代</td></tr><tr><td>auxiliary loss</td><td>辅助损失</td></tr><tr><td>self-supervision</td><td>自我监督</td></tr><tr><td>heuristics</td><td>n. 启发(法)，探索法</td></tr><tr><td>data augmentations</td><td>数据增强</td></tr><tr><td>stacking a series of transformations</td><td>堆叠一系列转换</td></tr><tr><td>stack</td><td>vi. 堆积，堆叠</td></tr><tr><td>regularization</td><td>n. 规则化,调整</td></tr><tr><td>local optimization</td><td>局部优化;</td></tr><tr><td>explicit regularization</td><td>显式正则化</td></tr><tr><td>continous interpolation mechanism</td><td>连续插值机制</td></tr><tr><td>preliminary</td><td>准备工作；初步行动</td></tr><tr><td>converge</td><td>趋同，趋于一致，融合，收敛</td></tr><tr><td>latent space</td><td>潜在空间</td></tr><tr><td>heterogeneity</td><td>n. 异质性;不均匀性;不纯一性</td></tr><tr><td>Fourier transform</td><td>傅里叶变换</td></tr><tr><td>information inherent</td><td>固有的信息</td></tr><tr><td>phase spectrum</td><td>相位谱</td></tr><tr><td>amplitude spectrum</td><td>振幅谱；振幅频谱</td></tr><tr><td>semantics</td><td>n. 语义学</td></tr><tr><td>decouple</td><td>解耦</td></tr><tr><td>cluster</td><td>聚类</td></tr><tr><td>quantify</td><td>[V] 确定…的数量;用数量来表示；量化</td></tr><tr><td>delineation</td><td>圈定、界定</td></tr><tr><td>overlap</td><td>n. 重叠；重复</td></tr><tr><td>morphological operation</td><td>形态学操作</td></tr><tr><td>element-wise product</td><td>元素积</td></tr><tr><td>aggregate</td><td>vt. &amp; vi. (使)聚集</td></tr><tr><td>generalization</td><td>泛化、概览</td></tr><tr><td>decentralization</td><td>n. 分散,地方分权,排除集中</td></tr><tr><td>in-depth ablation</td><td></td></tr><tr><td>adversarial feature alignment</td><td>对抗性特征对齐</td></tr><tr><td>dedicated dense</td><td>专用密集的</td></tr><tr><td>retinal fundus</td><td>视网膜眼底</td></tr><tr><td>heterogeneity</td><td>n. 异质性;不均匀性;不纯一性</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td></tr></tbody></table></div><hr><h4 id="附录B：生词"><a href="#附录B：生词" class="headerlink" title="附录B：生词"></a>附录B：生词</h4><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>promote</td><td>encourage sth 促进</td></tr><tr><td>dedicated</td><td>专用的</td></tr><tr><td>dense</td><td>密集的</td></tr><tr><td>enhance</td><td>大大提高；显著提高:</td></tr><tr><td>objective</td><td>客观的</td></tr><tr><td>paradigm</td><td>范式</td></tr><tr><td>expose</td><td>充分暴露</td></tr><tr><td>notably</td><td>特别;尤其</td></tr><tr><td>imprecise</td><td>不精确；好像不确切</td></tr><tr><td>anatomies</td><td>解剖学</td></tr><tr><td>ambiguous</td><td>含糊不清的;</td></tr><tr><td>tackle</td><td>处理，解决(难题或任务)</td></tr><tr><td>decentralize</td><td>分散;下放…的权力</td></tr><tr><td>extensive</td><td>广泛的;全面的;包罗万象的</td></tr><tr><td>state-of-the-arts</td><td>技术发展最新水平</td></tr><tr><td>demonstrate</td><td>证明;论证;表明;说明</td></tr><tr><td>aggregate</td><td>合计;总计;汇集；</td></tr><tr><td>representatively</td><td>典型的</td></tr><tr><td>investigate</td><td>调查;审查；</td></tr><tr><td>collaborative</td><td>合作的;协作的；</td></tr><tr><td>alleviate</td><td>减轻，缓解痛苦等</td></tr><tr><td>whereas</td><td>但是，然而</td></tr><tr><td>discrepancy</td><td>差异;不符;不一致;出入</td></tr><tr><td>utilize</td><td>利用；使用</td></tr><tr><td>contrastive</td><td>adj. 对比的</td></tr><tr><td>stimulate</td><td>刺激;激励;促使;促起</td></tr><tr><td>violate</td><td>违反，违背</td></tr><tr><td>manipulate</td><td>摆布，操纵，</td></tr><tr><td>leverage</td><td>vt. 促使…改变，利用</td></tr><tr><td>adopt</td><td>采取；采纳；采用</td></tr><tr><td>cohesion</td><td>团结;凝聚力</td></tr><tr><td>denote</td><td>意思是;指代</td></tr><tr><td>thoroughly</td><td>adv. 彻底地；认真仔细地</td></tr><tr><td>distinct</td><td>adj. 截然不同的, 完全分开的</td></tr><tr><td>insufficient</td><td>不充分的;不足的;缺乏的；</td></tr><tr><td>invariance</td><td>n. 不变性,恒定性</td></tr><tr><td>anatomises</td><td>解剖结构</td></tr><tr><td>ambiguity</td><td>含糊不清；不明确；模棱两可</td></tr><tr><td>exploit</td><td>充分运用；发挥</td></tr><tr><td>leakage</td><td>漏出物,渗漏物</td></tr><tr><td>decompose</td><td>(使) (死去的动植物)腐烂;使分解</td></tr><tr><td>synthesize</td><td>vt. 综合, 使合成</td></tr><tr><td>ratio</td><td>比;比率;比例；</td></tr><tr><td>intuitive</td><td>直觉的;凭直觉获知的</td></tr><tr><td>denotation</td><td>n. 指示</td></tr><tr><td>hereafter</td><td>adv. 今后,从此以后,此后</td></tr><tr><td>violate</td><td>违反，违背，</td></tr><tr><td>counterparts</td><td>n. 与对方地位相当的人, 与另一方作用相当的物</td></tr><tr><td>regularize</td><td>vt. 调整；使有秩序；使合法化</td></tr><tr><td>crucially</td><td>adv. 至关重要地;关键地</td></tr><tr><td>w.r.t</td><td>abbr. With respect to 关于</td></tr><tr><td>property</td><td>[N-COUNT 可数名词] 特性；性质；性能；属</td></tr><tr><td>to this end</td><td>因此</td></tr><tr><td>compact</td><td>小而紧凑的；</td></tr><tr><td>project</td><td>[VERB 动词] 投射；放映</td></tr><tr><td>product</td><td>乘积</td></tr><tr><td>collaborative</td><td>adj. 合作的,协作的,协力完成的</td></tr><tr><td>neglect</td><td>[VERB 动词] 忽视;忽略</td></tr><tr><td>impede</td><td>[VERB 动词] 妨碍;阻碍;</td></tr><tr><td>adversarial</td><td>对立的；敌对的；</td></tr><tr><td>devise</td><td>vt. 想出；计划；设计；发明</td></tr><tr><td>present</td><td>清晰地表述；有条理地提出:</td></tr><tr><td>discrepancy</td><td>[N-VAR 可变名词] 差异;不符;不一致;出入；</td></tr><tr><td>manipulate</td><td>操纵</td></tr><tr><td>proportional</td><td>[ADJ 形容词] 与…成比例的</td></tr><tr><td>incorporate</td><td>[VERB 动词] 包含;吸收；</td></tr><tr><td>flexibly</td><td>有弹性地；灵活地</td></tr><tr><td>latent</td><td>adj.隐藏的，潜在的</td></tr><tr><td>insufficient</td><td>[ADJ 形容词] 不充分的;不足的;缺乏的</td></tr><tr><td>retinal</td><td>[ADJ 形容词] 视网膜的；</td></tr><tr><td>variance</td><td>[N-VAR 可变名词] 差异;不同；</td></tr><tr><td>intensity</td><td>高强度</td></tr><tr><td>heterogeneous</td><td>由不同成分组成的;成分混杂的；</td></tr><tr><td>joint</td><td>[ADJ 形容词] 联合的；共同的；共享的；</td></tr><tr><td>inherent</td><td>[ADJ 形容词] 内在的;固有的;生来就有的；</td></tr><tr><td>decomposed</td><td>[V-ERG 及物/不及物动词] (使) (死去的动植物)腐烂;使分解</td></tr><tr><td>empirically</td><td>adv. 以经验为主地</td></tr></tbody></table></div><p>困难 &amp; 解决：</p><ol><li><p>数据集准备，文件的遍历</p></li><li><p>train_ELCFS 路径 dataset</p></li><li><pre><code class="hljs">dataloader = DataLoader(dataset, batch_size=batch_size, shuffle=True,  num_workers=1, pin_memory=True, worker_init_fn=worker_init_fn) # num_workers=0 不要子进程</code></pre></li><li><p><img src="/images/FedDG.assets/image-20220126201535533.png" alt="image-20220126201535533"></p></li><li><p>替换幅度谱，然后和相位谱重新生成图像，会不会出现根本就不可能有这种图像</p></li><li><p>训练中没有进行插值，是直接交换的幅度谱</p></li><li>留一域测试中并没有只用留的域测试，而是加载了所有的源域</li><li>二进制掩码M在幅度谱交换时并没有用到</li><li>并没有将所有插值后的图像用于meta-test</li><li>第一个模块，连续频域插值算法，提出元学习范式，使用当前客户端数据进行meta-train，使用k-1个插值数据进行meta-test；第二个模块，边界介导的情景学习，第一步利用原MASK生成两个对比MASK，得到两个一维向量，然后构建基于对比学习的边界loss，结合dice loss一起构成meta test阶段的loss</li></ol><p>想法：</p><ol><li><p>用FATE开源框架实现联邦学习</p><blockquote><p><strong>开源平台</strong></p><p> 微众银行FATE<br> 谷歌TensorFlow Federated<br> 百度PaddleFL<br> 腾讯AngelFL<br> CMU LEAF<br> 字节FedLearner<br> 矩阵元Rosetta</p></blockquote></li><li><p>加密</p></li><li><p>恶意攻击（拜占庭问题</p></li></ol><blockquote><ol><li><p>降低算法通信次数，用少量的通信达到收敛。数据是IID的，已经被研究比较透彻了。联邦学习的困难在于数据不是IID的。</p></li><li><p>研究联邦学习中的隐私问题。联邦学习其实不会保护隐私，很容易从梯度、模型参数中反推出用户数据。提出攻击和防御的方法都可以发表出论文。</p></li><li><p>研究联邦学习的鲁棒性。比如有节点恶意发送错误的梯度给服务器，让训练的模型变差。设计新的攻击方法和防御方法都可以发表出来论文。</p></li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++基础算法</title>
    <link href="/2021/11/11/noteofc++/"/>
    <url>/2021/11/11/noteofc++/</url>
    
    <content type="html"><![CDATA[<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><code>1.memset数组初始化方式</code></p><p><code>#include&lt;cstring&gt;  memset函数在这个库中</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>];<br><span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-number">40</span>);(数组名， 初始化的参数，<span class="hljs-keyword">byte</span>的数量)<br>单位是字节<span class="hljs-keyword">byte</span> <span class="hljs-number">10</span>个<span class="hljs-keyword">int</span> <span class="hljs-number">40</span>个<span class="hljs-keyword">byte</span><br>从a开始的连续<span class="hljs-number">40</span>个<span class="hljs-keyword">byte</span>全部初始化为<span class="hljs-number">0</span>，也就实现了整个数组都为<span class="hljs-number">0</span> <br><span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> a)<br><br>数组复制<span class="hljs-function">memcpy</span><br><span class="hljs-function"><span class="hljs-title">memcpy</span><span class="hljs-params">(复制的目标数组，原数组，多长和memset一样)</span></span><br></code></pre></td></tr></table></figure><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c">例子：<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N =<span class="hljs-number">5</span>;<br><span class="hljs-keyword">char</span> g[N][N];<br><span class="hljs-keyword">char</span> backup[N][N];<br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; PII;<br><br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">turn_one</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-keyword">if</span>(g[x][y]==<span class="hljs-string">&#x27;+&#x27;</span>) g[x][y]=<span class="hljs-string">&#x27;-&#x27;</span>;<br><span class="hljs-keyword">else</span> g[x][y]=<span class="hljs-string">&#x27;+&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">turn_all</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">3</span>; i++)<br>    &#123;<br>        turn_one(x,i);<br>        turn_one(i,y);<br>    &#125;<br>    <br>    turn_one(x,y);<span class="hljs-comment">//消除重复的</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span><span class="hljs-comment">//返回x,y坐标的标号，为了可以按照字典序排序</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x*<span class="hljs-number">4</span>+y;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++) <span class="hljs-built_in">cin</span>&gt;&gt;g[i];<span class="hljs-comment">//读状态</span><br><br><span class="hljs-built_in">vector</span>&lt;PII&gt; res;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> op=<span class="hljs-number">0</span>;op&lt; <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">16</span> ; op++ )<span class="hljs-comment">//对16个位置的所有方案进行枚举</span><br>&#123;<br><span class="hljs-built_in">memcpy</span>(backup,g,<span class="hljs-keyword">sizeof</span> g);<br>        <span class="hljs-built_in">vector</span>&lt;PII&gt; temp;<br>        <br>        <span class="hljs-comment">//进行操作</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">3</span>;i++)<span class="hljs-comment">//依次根据op的方案，按照op每个位的指示进行操作</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">3</span>; j++)<br>                <span class="hljs-keyword">if</span>(op&gt;&gt;get(i,j)&amp;<span class="hljs-number">1</span>)<span class="hljs-comment">//get(i,j)移到某一位查看op指示的操作</span><br>                &#123;<br>                    temp.push_back(&#123;i,j&#125;);<span class="hljs-comment">//有操作即记录</span><br>                    turn_all(i,j);<br>                &#125;<br>        <span class="hljs-comment">//判断所有开关是否全开</span><br><br><span class="hljs-keyword">bool</span> unfinish=<span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">3</span>;i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">3</span>;j++)<br>    <span class="hljs-keyword">if</span>(g[i][j]==<span class="hljs-string">&#x27;+&#x27;</span>)<br>    unfinish=<span class="hljs-literal">true</span>;<br>    <br><span class="hljs-keyword">if</span>(!unfinish)<br>&#123;<br>    <span class="hljs-keyword">if</span>(res.empty()|| res.size()&gt; temp.size() )  res=temp;<br>&#125;<br><br><span class="hljs-built_in">memcpy</span>(g,backup,<span class="hljs-keyword">sizeof</span> g);<br>&#125;<br><span class="hljs-built_in">cout</span>&lt;&lt;res.size()&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> op :res ) <span class="hljs-built_in">cout</span>&lt;&lt;op.x+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;op.y+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p><code>2.#include &lt;cstring&gt;或&lt;string.h&gt;</code></p><p><code>getchar()吸收换行</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">输入：<br><span class="hljs-built_in">getline</span>(cin,s);<br>输出：<br><span class="hljs-built_in">puts</span>(s);  <span class="hljs-comment">//输出字符串s且换行</span><br></code></pre></td></tr></table></figure><h5 id="C"><a href="#C" class="headerlink" title="C"></a>C</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">char</span> s[N];<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s); <span class="hljs-comment">// 不能读取含空格、换行符的字符串</span><br>gets(s); <span class="hljs-comment">// 能读取含空格的字符串，同时自动去掉换行符\n</span><br>fgets(s, N, <span class="hljs-built_in">stdin</span>); <span class="hljs-comment">// 能读取含空格的字符串，但不会去掉换行符\n。【注意】</span><br>fgets的坑：<br>fgets会读入\n，因此遍历字符串时，应当用<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; str[i] != <span class="hljs-string">&#x27;\n&#x27;</span>; i++)，而不能用 <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; str[i]; i++)<br><br><span class="hljs-keyword">char</span> a[N], b[N];<br><span class="hljs-built_in">strlen</span>(a);<span class="hljs-comment">// O(N)复杂度，使用前最好用变量保存字符串长度。统计的长度不包括`\0`</span><br><span class="hljs-built_in">strcat</span>(a, b);<span class="hljs-comment">// 把字符串b拼接到a之后，拼接后的字符串保存在a中</span><br><span class="hljs-built_in">strcmp</span>(a, b);<span class="hljs-comment">// 根据字典排序比较字符串,a &lt; b 返回-1;a == b返回0;a &gt; b返回1</span><br><span class="hljs-built_in">strcpy</span>(b, a);<span class="hljs-comment">// 把字符串a的内容拷贝到字符串b,将字符串b复制给从a开始的字符数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; str[i]; i++) &#123;...&#125;<span class="hljs-comment">// 遍历字符串</span><br></code></pre></td></tr></table></figure><h5 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-built_in">string</span> str;<br><span class="hljs-built_in">cin</span> &gt;&gt; str; <span class="hljs-comment">// 不能读取含空格、换行符的字符串</span><br>getline(<span class="hljs-built_in">cin</span>, str); <span class="hljs-comment">// 能读取含空格的字符串，同时自动去掉换行符\n</span><br><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;a&#x27;</span>)</span></span>;<span class="hljs-comment">// 构造重复字符的字符串</span><br>str.empty();<span class="hljs-comment">// 判空</span><br>str.size()/length() ;<span class="hljs-comment">// 长度，与stelen()不同的是，这个复杂度是O(1)，不用额外的变量保存</span><br>str.c_str();<span class="hljs-comment">// 转成char数组，返回字符串所在字符数组的起始地址</span><br><span class="hljs-comment">// printf(“%s”, s.c_str());</span><br>str.substr(begin, length);  <span class="hljs-comment">// 子串, substr(起始下标，(子串长度))  返回子串</span><br>str.pop_back();<span class="hljs-comment">// 删除最后一个字符</span><br><span class="hljs-comment">// 字符串比较&quot;&gt;&quot;、&quot;&lt;&quot;</span><br><span class="hljs-comment">// 字符串拼接&quot;+&quot;</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch : str) &#123;...&#125;<span class="hljs-comment">// 遍历（不可修改字符）</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> &amp;ch : str) &#123;...&#125;<span class="hljs-comment">// 遍历（可修改字符）</span><br></code></pre></td></tr></table></figure><h5 id="字符串流"><a href="#字符串流" class="headerlink" title="字符串流"></a>字符串流</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><br><span class="hljs-built_in">string</span> s;<br><span class="hljs-function"><span class="hljs-built_in">stringstream</span> <span class="hljs-title">ssin</span><span class="hljs-params">(s)</span></span>;<br><span class="hljs-keyword">while</span>(ssin &gt;&gt; s) &#123;...&#125;<span class="hljs-comment">// 按空格拆分s，例如英语句子拆分单词</span><br><span class="hljs-comment">// 可用如下代码代替</span><br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; word) &#123;<br>    ...<br>&#125;<br><br>例如：<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">10010</span>;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> a[N];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> cnt;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;cnt;<br>    <span class="hljs-built_in">string</span> line;<br>    getline(<span class="hljs-built_in">cin</span>,line);  <span class="hljs-comment">//忽略第一行回车</span><br>    <span class="hljs-keyword">while</span>(cnt--)<br>    &#123;<br>        getline(<span class="hljs-built_in">cin</span>,line);<br>        <span class="hljs-function"><span class="hljs-built_in">stringstream</span> <span class="hljs-title">ssin</span><span class="hljs-params">(line)</span></span>;  <span class="hljs-comment">//从line读入</span><br>        <br>        <span class="hljs-keyword">while</span>(ssin&gt;&gt;a[n]) n++;  <span class="hljs-comment">//对读入数据量不确定的情况</span><br>    &#125;<br>    sort(a,a+n);<br>    <span class="hljs-keyword">int</span> res1,res2;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(a[i]==a[i<span class="hljs-number">-1</span>]) res1=a[i];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i]&gt;=a[i<span class="hljs-number">-1</span>]+<span class="hljs-number">2</span>) res2=a[i]<span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;res2&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;res1&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><h6 id="1-vector"><a href="#1-vector" class="headerlink" title="1.vector"></a>1.vector</h6><ul><li>vector是变长数组，类似java的ArrayList,支持随机访问，不支持在任意位置O(1)插入。为了保证效率，元素的增删一般应该在末尾进行。<ul><li>a.begin()返回的是vector第1个元素的地址，而a.end()返回的是最后一个元素的下一个位置的地址</li><li>a.end() - a.begin() == a.size()</li><li>*a.begin() == a[0]</li></ul></li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs arduino">声明<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span> 头文件</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; a;相当于一个长度动态变化的<span class="hljs-keyword">int</span>数组<br>vector&lt;<span class="hljs-keyword">int</span>&gt; b[<span class="hljs-number">233</span>];相当于第一维长<span class="hljs-number">233</span>，第二位长度动态变化的<span class="hljs-keyword">int</span>数组<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rec</span>&#123;</span>…&#125;;<br>vector&lt;rec&gt; c;自定义的结构体类型也可以保存在vector中<br><br>操作<br>    <span class="hljs-built_in">size</span>()   返回元素个数,返回vector的实际长度（包含的元素个数）<br>    <span class="hljs-built_in">empty</span>()  返回是否为空返回一个<span class="hljs-keyword">bool</span>类型，表明vector是否为空。<br>    注：二者的时间复杂度都是<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)。<br>    所有的STL容器都支持这两个方法，含义也相同，之后我们就不再重复给出。<br>    <span class="hljs-built_in">clear</span>()  清空<br>    <span class="hljs-built_in">begin</span>()/<span class="hljs-built_in">end</span>()<br>        <span class="hljs-number">1.b</span>egin函数返回指向vector中第一个元素的迭代器。<br>        <span class="hljs-number">2.</span>例如a是一个非空的vector，则*a.<span class="hljs-built_in">begin</span>()与a[<span class="hljs-number">0</span>]的作用相同。<br>        <span class="hljs-number">3.</span>所有的容器都视作一个“前闭后开”的结构，end函数返回vector的尾部，即第n个元素再往后的“边界”。<br>        <span class="hljs-number">4.</span>a.<span class="hljs-built_in">end</span>()与a[n]都是越界访问，其中n=a.<span class="hljs-built_in">size</span>()<br><br>    <span class="hljs-built_in">front</span>()/<span class="hljs-built_in">back</span>()<br>            front函数返回vector的第一个元素，等价于*a.<span class="hljs-built_in">begin</span>() 和 a[<span class="hljs-number">0</span>]<br>            back函数返回vector的最后一个元素，等价于*--a.<span class="hljs-built_in">end</span>() 和 a[a.<span class="hljs-built_in">size</span>() – <span class="hljs-number">1</span>]<br><br>    <span class="hljs-built_in">push_back</span>()/<span class="hljs-built_in">pop_back</span>()<br>            a.<span class="hljs-built_in">push_back</span>(x) 把元素x插入到vector a的尾部。<br>            b.<span class="hljs-built_in">pop_back</span>() 删除vector b的最后一个元素。   <br>    []<br>    支持比较运算，按字典序<br>    <br>遍历<br>遍历vector&lt;<span class="hljs-keyword">int</span>&gt;a，并输出它的所有元素。<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> I = <span class="hljs-number">0</span>; I &lt; a.<span class="hljs-built_in">size</span>(); I ++) cout &lt;&lt; a[i] &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = a.<span class="hljs-built_in">begin</span>(); it != a.<span class="hljs-built_in">end</span>(); it ++)<br>        cout &lt;&lt; *it &lt;&lt; endl;<br>        迭代器就像STL容器的“指针”，可以用星号“*”操作符解除引用。<br>        一个保存<span class="hljs-keyword">int</span>的vector的迭代器声明方法为：<br>        vector&lt;<span class="hljs-keyword">int</span>&gt;::iterator it;<br>注：vector的迭代器是“随机访问迭代器”，可以把vector的迭代器与一个整数相加减，其行为和指针的移动类似。可以把vector的两个迭代器相减，其结果也和指针相减类似，得到两个迭代器对应下标之间的距离。<br></code></pre></td></tr></table></figure><p><code>用法示例</code></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;vector&gt;<br><span class="hljs-comment">// 定义</span><br>vector&lt;<span class="hljs-built_in">int</span>&gt; a;<span class="hljs-comment">// 一维数组</span><br>vector&lt;<span class="hljs-built_in">int</span>&gt; b<span class="hljs-literal">[N]</span>;<span class="hljs-comment">// 二维数组</span><br><br><span class="hljs-comment">// 初始化</span><br>vector&lt;<span class="hljs-built_in">int</span>&gt; a(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;);<br><br><span class="hljs-comment">// 操作</span><br>a<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span>;<span class="hljs-comment">// 取值</span><br>a.size<span class="hljs-literal">()</span>;<span class="hljs-comment">// 长度</span><br>a.empty<span class="hljs-literal">()</span>;<span class="hljs-comment">// 判空</span><br>a.clear<span class="hljs-literal">()</span>;<span class="hljs-comment">// 清空</span><br><br>a.front<span class="hljs-literal">()</span>;<span class="hljs-comment">// 读取第1个元素</span><br>a.back<span class="hljs-literal">()</span>;<span class="hljs-comment">// 读取最后1个元素</span><br>a.push<span class="hljs-constructor">_back(<span class="hljs-params">x</span>)</span>;  <span class="hljs-comment">// 在末尾插入元素</span><br><span class="hljs-built_in">int</span> x = a.pop<span class="hljs-constructor">_back()</span>; <span class="hljs-comment">// 删除末尾元素并返回</span><br><br><span class="hljs-built_in">int</span>* p = lower<span class="hljs-constructor">_bound(<span class="hljs-params">a</span>, <span class="hljs-params">a</span> + <span class="hljs-params">a</span>.<span class="hljs-params">size</span>()</span>, x);  <span class="hljs-comment">// 查找数组在指定范围内大于等于x的元素地址（要求数组有序）</span><br><span class="hljs-built_in">int</span>* p = upper<span class="hljs-constructor">_bound(<span class="hljs-params">a</span>, <span class="hljs-params">a</span> + <span class="hljs-params">a</span>.<span class="hljs-params">size</span>()</span>, x);  <span class="hljs-comment">// 查找数组在指定范围内大于x的元素地址（要求数组有序）</span><br><br><span class="hljs-built_in">int</span> index = lower<span class="hljs-constructor">_bound(<span class="hljs-params">a</span>, <span class="hljs-params">a</span> + <span class="hljs-params">a</span>.<span class="hljs-params">size</span>()</span>, x); - a;  <span class="hljs-comment">// 查找数组在指定范围内大于等于x的元素下标（要求数组有序）</span><br><span class="hljs-built_in">int</span> index = upper<span class="hljs-constructor">_bound(<span class="hljs-params">a</span>, <span class="hljs-params">a</span> + <span class="hljs-params">a</span>.<span class="hljs-params">size</span>()</span>, x); - a;  <span class="hljs-comment">// 查找数组在指定范围内大于x的元素下标（要求数组有序）</span><br><br><span class="hljs-comment">// 遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; a.size<span class="hljs-literal">()</span>; i++) &#123;...&#125;<span class="hljs-comment">// 方式1，通过a[i]读取元素值</span><br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-built_in">int</span>&gt;::iterator i = a.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>; i &lt; a.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>; i++) &#123;...&#125;  <span class="hljs-comment">// 方式2（迭代器），通过*i读取元素值</span><br><span class="hljs-keyword">for</span> (auto i = a.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>; i &lt; a.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>; i++) &#123;...&#125;   <span class="hljs-comment">// 方式3（迭代器简化版）</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> x : a) &#123;...&#125;  <span class="hljs-comment">// 方式4，通过x读取元素值</span><br></code></pre></td></tr></table></figure><h6 id="2-pair"><a href="#2-pair" class="headerlink" title="2.pair"></a>2.pair<int, int></int,></h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">    first, 第一个元素<br>    second, 第二个元素<br>    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）<br>用法：<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> x first</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> y second</span><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; PII;<br>    <span class="hljs-built_in">vector</span>&lt;PII&gt; temp;<br>    temp.push_back(&#123;i,j&#125;);<span class="hljs-comment">//有操作即记录</span><br></code></pre></td></tr></table></figure><h6 id="3-queue"><a href="#3-queue" class="headerlink" title="3.queue"></a>3.queue</h6><ul><li>队列没有clear()方法<ul><li>优先队列插入时无序，输出时有序</li><li>优先队列存储自定义类型时，需要重载运算符</li><li>大根堆重载&lt;</li><li>小根堆重载&gt;</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span>头文件queue主要包括循环队列queue和优先队列priority_queue两个容器。</span><br>    <span class="hljs-built_in">size</span>()<br>    <span class="hljs-built_in">empty</span>()<br>    <span class="hljs-built_in">push</span>()  向队尾插入一个元素<br>    <span class="hljs-built_in">front</span>()  返回队头元素<br>    <span class="hljs-built_in">back</span>()  返回队尾元素<br>    <span class="hljs-built_in">pop</span>()  弹出队头元素<br>声明<br>queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>priority_queue&lt;<span class="hljs-keyword">int</span>&gt; q;<span class="hljs-comment">// 大根堆</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rec</span>&#123;</span>…&#125;; priority_queue&lt;rec&gt; q; <span class="hljs-comment">//大根堆中结构体rec中必须重载小于号</span><br>priority_queue&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; q;<span class="hljs-comment">// 小根堆</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rec</span>&#123;</span>…&#125;; priority_queue&lt;rec&gt; q; <span class="hljs-comment">//小根堆中结构体rec中必须重载大于号</span><br>priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;q;<br><br>循环队列 queue<br>push 从队尾插入<br>pop 从队头弹出<br>front 返回队头元素<br>back 返回队尾元素<br><br>优先队列 priority_queue<br>push把元素插入堆<br>pop 删除堆顶元素<br>top 查询堆顶元素（最大值）<br><br>只有queue，priority_queue，stack没有clear函数<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><br><span class="hljs-comment">/**************************************************</span><br><span class="hljs-comment">** 普通队列queue</span><br><span class="hljs-comment">***************************************************/</span><br><span class="hljs-comment">// 定义</span><br>queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br><br><span class="hljs-comment">// 操作</span><br>q.<span class="hljs-built_in">push</span>(x);<span class="hljs-comment">// 入队（末尾插入元素）</span><br><span class="hljs-keyword">int</span> x = q.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 出队（删除第1个元素）</span><br>a.<span class="hljs-built_in">front</span>();<span class="hljs-comment">// 查看队头元素</span><br>a.<span class="hljs-built_in">back</span>();<span class="hljs-comment">// 查看队尾元素</span><br><span class="hljs-comment">// a.clear()</span><br><br><span class="hljs-comment">/**************************************************</span><br><span class="hljs-comment">** 优先队列（堆）</span><br><span class="hljs-comment">***************************************************/</span><br><span class="hljs-comment">// 元素为基本类型</span><br>priority_queue&lt;<span class="hljs-keyword">int</span>&gt; a;<span class="hljs-comment">// 大根堆</span><br>priority_queue&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; b;   <span class="hljs-comment">// 小根堆</span><br><br><span class="hljs-comment">// 元素为自定义类型</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Rec</span> &#123;</span><br>    <span class="hljs-keyword">int</span> a, b;<br>    <span class="hljs-comment">// 大根堆需要自定义类重载&lt;号</span><br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-keyword">const</span> Rec&amp; t) <span class="hljs-keyword">const</span> &#123;<br>        <span class="hljs-keyword">return</span> a &lt; t.a;<br>    &#125;<br>    <span class="hljs-comment">// 小根堆需要自定义类重载&gt;号</span><br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt; (<span class="hljs-keyword">const</span> Rec&amp; t) <span class="hljs-keyword">const</span> &#123;<br>        <span class="hljs-keyword">return</span> a &gt; t.a;<br>    &#125;<br>&#125;<br>priority_queue&lt;Rec&gt; a;<span class="hljs-comment">// 大根堆</span><br>priority_queue&lt;Rec, vector&lt;Rec&gt;, greater&lt;Rec&gt;&gt; b;   <span class="hljs-comment">// 小根堆</span><br><span class="hljs-comment">// 操作</span><br>a.<span class="hljs-built_in">push</span>(x);<span class="hljs-comment">// 插入元素（位置不确定）</span><br>a.<span class="hljs-built_in">top</span>();<span class="hljs-comment">// 查看堆顶元素（大根堆是最大值，小根堆是最小值）</span><br>a.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">// 删除堆顶元素（大根堆是最大值，小根堆是最小值）</span><br></code></pre></td></tr></table></figure><h6 id="4-priority-queue-优先队列"><a href="#4-priority-queue-优先队列" class="headerlink" title="4.priority_queue, 优先队列"></a>4.priority_queue, 优先队列</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">5.</span><span class="hljs-built_in">priority_queue</span>, 优先队列，默认是大根堆<br>    size()<br>    empty()<br>    push()  插入一个元素<br>    top()  返回堆顶元素<br>    pop()  弹出堆顶元素<br>    定义成小根堆的方式：<span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; q;<br></code></pre></td></tr></table></figure><h6 id="5-stack栈"><a href="#5-stack栈" class="headerlink" title="5.stack栈"></a>5.stack栈</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><br>头文件<span class="hljs-built_in">stack</span>包含栈。声明和前面的容器类似。<br>    size()<br>    empty()<br>    push()  向栈顶插入一个元素<br>    top()  返回栈顶元素<br>    pop()  弹出栈顶元素<br><br>push 向栈顶插入<br>pop 弹出栈顶元素<br></code></pre></td></tr></table></figure><h6 id="6-deque-双端队列"><a href="#6-deque-双端队列" class="headerlink" title="6.deque, 双端队列"></a>6.deque, 双端队列</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span><br>双端队列<span class="hljs-built_in">deque</span>是一个支持在两端高效插入或删除元素的连续线性存储空间。它就像是<span class="hljs-built_in">vector</span>和<span class="hljs-built_in">queue</span>的结合。与<span class="hljs-built_in">vector</span>相比，<span class="hljs-built_in">deque</span>在头部增删元素仅需要O(<span class="hljs-number">1</span>)的时间；与<span class="hljs-built_in">queue</span>相比，<span class="hljs-built_in">deque</span>像数组一样支持随机访问。<br>    size()<br>    empty()<br>    clear()<br>    front()/back()<br>    push_back()/pop_back()<br>    push_front()/pop_front()<br>    begin()/end()<br>    []<br><br>    [] 随机访问<br>    begin/end，返回<span class="hljs-built_in">deque</span>的头/尾迭代器<br>    front/back 队头/队尾元素<br>    push_back 从队尾入队<br>    push_front 从队头入队<br>    pop_back 从队尾出队<br>    pop_front 从队头出队<br>    clear 清空队列<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span><br><span class="hljs-comment">// 定义</span><br><span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br><br><span class="hljs-comment">// 操作</span><br>q[i]<span class="hljs-comment">// 随机访问</span><br>q.begin();<span class="hljs-comment">// 队头元素地址，用*q.begin()读取元素</span><br>q.end();<span class="hljs-comment">// 队尾元素地址，用*q.end()读取元素</span><br>q.front();<span class="hljs-comment">// 队头元素值</span><br>q.back();<span class="hljs-comment">// 队尾元素值</span><br><br>push_back();<span class="hljs-comment">// 队尾插入元素</span><br>push_front();<span class="hljs-comment">// 队头插入元素</span><br>pop_back();<span class="hljs-comment">// 队尾删除元素</span><br>pop_front();<span class="hljs-comment">// 队头插入元素</span><br></code></pre></td></tr></table></figure><h6 id="7-set"><a href="#7-set" class="headerlink" title="7.set"></a>7.set</h6><ul><li>自定义类要求重载 &lt;<ul><li>find()、erase()、lower_bound()和upper_bound()都是O(logn)复杂度</li><li>count()是O(k+logn)复杂度<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs c++">set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列<br>    <span class="hljs-built_in">size</span>()<br>    <span class="hljs-built_in">empty</span>()<br>    <span class="hljs-built_in">clear</span>()<br>    <span class="hljs-built_in">begin</span>()/<span class="hljs-built_in">end</span>()<br>    ++, -- 返回前驱和后继，时间复杂度 <span class="hljs-built_in">O</span>(logn)<br><br>    set/<span class="hljs-function">multiset</span><br><span class="hljs-function">        <span class="hljs-title">insert</span><span class="hljs-params">()</span>  插入一个数</span><br><span class="hljs-function">        <span class="hljs-title">find</span><span class="hljs-params">()</span>  查找一个数</span><br><span class="hljs-function">        <span class="hljs-title">count</span><span class="hljs-params">()</span>  返回某一个数的个数</span><br><span class="hljs-function">        <span class="hljs-title">erase</span><span class="hljs-params">()</span></span><br><span class="hljs-function">            <span class="hljs-params">(<span class="hljs-number">1</span>)</span> 输入是一个数x，删除所有x   <span class="hljs-title">O</span><span class="hljs-params">(k + logn)</span></span><br><span class="hljs-function">            <span class="hljs-params">(<span class="hljs-number">2</span>)</span> 输入一个迭代器，删除这个迭代器</span><br><span class="hljs-function">        <span class="hljs-title">lower_bound</span><span class="hljs-params">()</span>/<span class="hljs-title">upper_bound</span><span class="hljs-params">()</span></span><br><span class="hljs-function">            <span class="hljs-title">lower_bound</span><span class="hljs-params">(x)</span>  返回大于等于x的最小的数的迭代器</span><br><span class="hljs-function">            <span class="hljs-title">upper_bound</span><span class="hljs-params">(x)</span>  返回大于x的最小的数的迭代器</span><br><span class="hljs-function">    map/multimap</span><br><span class="hljs-function">        <span class="hljs-title">insert</span><span class="hljs-params">()</span>  插入的数是一个pair</span><br><span class="hljs-function">        <span class="hljs-title">erase</span><span class="hljs-params">()</span>  输入的参数是pair或者迭代器</span><br><span class="hljs-function">        <span class="hljs-title">find</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        []  注意multimap不支持此操作。 时间复杂度是 <span class="hljs-title">O</span><span class="hljs-params">(logn)</span></span><br><span class="hljs-function">        <span class="hljs-title">lower_bound</span><span class="hljs-params">()</span>/<span class="hljs-title">upper_bound</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span></span><br><span class="hljs-function">头文件set主要包括set和multiset两个容器，分别是“有序集合”和“有序多重集合”，即前者的元素不能重复，而后者可以包含若干个相等的元素。set和multiset的内部实现是一棵红黑树，它们支持的函数基本相同。</span><br><span class="hljs-function"></span><br><span class="hljs-function">声明</span><br><span class="hljs-function">set&lt;<span class="hljs-keyword">int</span>&gt; s</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rec</span>&#123;</span>…&#125;; set&lt;rec&gt; s;<span class="hljs-comment">// 结构体rec中必须定义小于号</span><br>multiset&lt;<span class="hljs-keyword">double</span>&gt; s;<br><br><span class="hljs-built_in">size</span>()/<span class="hljs-built_in">empty</span>()/<span class="hljs-built_in">clear</span>()与vector类似<br><br>迭代器<br>set和multiset的迭代器称为“双向访问迭代器”，不支持“随机访问”，支持星号(*)解除引用，仅支持”++”和--“两个与算术相关的操作。<br>设it是一个迭代器，例如set&lt;<span class="hljs-keyword">int</span>&gt;::iterator it;<br>若把it++，则it会指向“下一个”元素。这里的“下一个”元素是指在元素从小到大排序的结果中，排在it下一名的元素。同理，若把it--，则it将会指向排在“上一个”的元素。<br><br>begin/end<br>返回集合的首、尾迭代器，时间复杂度均为<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)。<br>s.<span class="hljs-built_in">begin</span>() 是指向集合中最小元素的迭代器。<br>s.<span class="hljs-built_in">end</span>() 是指向集合中最大元素的下一个位置的迭代器。换言之，就像vector一样，是一个“前闭后开”的形式。因此--s.<span class="hljs-built_in">end</span>()是指向集合中最大元素的迭代器。<br><br>insert<br>s.<span class="hljs-built_in">insert</span>(x)把一个元素x插入到集合s中，时间复杂度为<span class="hljs-built_in">O</span>(logn)。<br>在set中，若元素已存在，则不会重复插入该元素，对集合的状态无影响。<br><br>find<br>s.<span class="hljs-built_in">find</span>(x) 在集合s中查找等于x的元素，并返回指向该元素的迭代器。若不存在，则返回s.<span class="hljs-built_in">end</span>()。时间复杂度为<span class="hljs-built_in">O</span>(logn)。<br><br>lower_bound/upper_bound<br>这两个函数的用法与find类似，但查找的条件略有不同，时间复杂度为 <span class="hljs-built_in">O</span>(logn)。<br>s.<span class="hljs-built_in">lower_bound</span>(x) 查找大于等于x的元素中最小的一个，并返回指向该元素的迭代器。<br>s.<span class="hljs-built_in">upper_bound</span>(x) 查找大于x的元素中最小的一个，并返回指向该元素的迭代器。<br><br>erase<br>设it是一个迭代器，s.<span class="hljs-built_in">erase</span>(it) 从s中删除迭代器it指向的元素，时间复杂度为<span class="hljs-built_in">O</span>(logn)<br>设x是一个元素，s.<span class="hljs-built_in">erase</span>(x) 从s中删除所有等于x的元素，时间复杂度为<span class="hljs-built_in">O</span>(k+logn)，其中k是被删除的元素个数。<br><br>count<br>s.<span class="hljs-built_in">count</span>(x) 返回集合s中等于x的元素个数，时间复杂度为 <span class="hljs-built_in">O</span>(k +logn)，其中k为元素x的个数。<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><br><br><span class="hljs-comment">// 定义</span><br>set&lt;<span class="hljs-keyword">int</span>&gt; s;<span class="hljs-comment">// 集合</span><br>multiset&lt;<span class="hljs-keyword">int</span>&gt; ms;<span class="hljs-comment">// 多重集合（允许元素重复）</span><br><br><span class="hljs-comment">// 操作</span><br>s.<span class="hljs-built_in">size</span>();<br>s.<span class="hljs-built_in">empty</span>();<br>s.<span class="hljs-built_in">claer</span>();<br><br>s.<span class="hljs-built_in">begin</span>();<br>s.<span class="hljs-built_in">end</span>();<br><br>s.<span class="hljs-built_in">insert</span>(x);<br>s.<span class="hljs-built_in">find</span>(x);<span class="hljs-comment">// 返回迭代器，可用if(s.find(x) == s.end())判断是否存在元素x</span><br>s.<span class="hljs-built_in">lower_bound</span>(x); <span class="hljs-comment">// 返回大于等于x的最小元素的迭代器</span><br>s.<span class="hljs-built_in">upper_bound</span>(x); <span class="hljs-comment">// 返回大于x的最小元素的迭代器</span><br><br>s.<span class="hljs-built_in">erase</span>(x);<span class="hljs-comment">// 删除x并返回迭代器</span><br>s.<span class="hljs-built_in">count</span>(x);<span class="hljs-comment">// 统计x出现的次数（普通集合只会返回0或1，多重集合可能返回大于1的数）</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br>map容器是一个键值对key-value的映射，其内部实现是一棵以key为关键码的红黑树。Map的key和value可以是任意类型，其中key必须定义小于号运算符。<br><br>声明<br>map&lt;key_type, value_type&gt; name;<br>例如：<br>map&lt;<span class="hljs-keyword">long</span>, <span class="hljs-keyword">long</span>, <span class="hljs-keyword">bool</span>&gt; vis;<br>map&lt;string, <span class="hljs-keyword">int</span>&gt; hash;<br>map&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;, vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; test;<br><br>size/empty/clear/begin/end均与set类似。<br><br>Insert/erase<br>与set类似，但其参数均是pair&lt;key_type, value_type&gt;。<br><br>find<br>h.<span class="hljs-built_in">find</span>(x) 在变量名为h的map中查找key为x的二元组。<br><br>用法：<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><br><span class="hljs-class">&#123;</span><br>string id;<br>string name;<br>string gender;<br><span class="hljs-keyword">int</span> age;<br>&#125;;<br>map&lt;string,student&gt; M;<br><span class="hljs-keyword">if</span>((M.<span class="hljs-built_in">find</span>(num))!=M.<span class="hljs-built_in">end</span>())<br>cout&lt;&lt;M[num].id&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;M[num].name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;M[num].gender&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;M[num].age&lt;&lt;endl<br>[]操作符<br>h[key] 返回key映射的value的引用，时间复杂度为<span class="hljs-built_in">O</span>(logn)。<br>[]操作符是map最吸引人的地方。我们可以很方便地通过h[key]来得到key对应的value，还可以对h[key]进行赋值操作，改变key对应的value。<br></code></pre></td></tr></table></figure></li></ul></li></ul><h6 id="8-哈希表"><a href="#8-哈希表" class="headerlink" title="8.哈希表"></a>8.哈希表</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs C++">  unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表<br>    和上面类似，增删改查的时间复杂度是 <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)<br>    不支持 <span class="hljs-built_in">lower_bound</span>()/<span class="hljs-built_in">upper_bound</span>()， 迭代器的++，--<br>    <br>举例：<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> y second</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/****哈希表做法******/</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; PII;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2500010</span>;<br><span class="hljs-keyword">int</span> n,m; <br>unordered_map&lt;<span class="hljs-keyword">int</span>,PII&gt; S;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-comment">//先枚举前两个</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c=<span class="hljs-number">0</span>;c*c&lt;=n;c++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> d=c;c*c+d*d&lt;=n; d++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> t=c*c+d*d;<br>            <span class="hljs-keyword">if</span>(S.<span class="hljs-built_in">count</span>(t)==<span class="hljs-number">0</span>) S[t]=&#123;c,d&#125;;<span class="hljs-comment">//只存第一个</span><br>        &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>; a*a&lt;=n;a++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> b=<span class="hljs-number">0</span>; a*a+b*b&lt;=n; b++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> t=n-a*a-b*b;<br>            <span class="hljs-keyword">if</span>(S.<span class="hljs-built_in">count</span>(t))<span class="hljs-comment">//查找是否在其中</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d %d\n&quot;</span>,a,b,S[t].x,S[t].y);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;        <br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>    <br>bitset, 圧位<br>    bitset&lt;10000&gt; s;<br>    ~, &amp;, |, ^<br>    &gt;&gt;, &lt;&lt;<br>    ==, !=<br>    []<br><br>​    <span class="hljs-built_in">count</span>()  返回有多少个<span class="hljs-number">1</span><br><br>​    <span class="hljs-built_in">any</span>()  判断是否至少有一个<span class="hljs-number">1</span><br>​    <span class="hljs-built_in">none</span>()  判断是否全为<span class="hljs-number">0</span><br><br>​    <span class="hljs-built_in">set</span>()  把所有位置成<span class="hljs-number">1</span><br>​    <span class="hljs-built_in">set</span>(k, v)  将第k位变成v<br>​    <span class="hljs-built_in">reset</span>()  把所有位变成<span class="hljs-number">0</span><br>​    <span class="hljs-built_in">flip</span>()  等价于~<br>​    <span class="hljs-built_in">flip</span>(k) 把第k位取反<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_set&gt;</span></span><br><br>unordered_set&lt;<span class="hljs-keyword">int</span>&gt; s;<span class="hljs-comment">// 哈希表</span><br>unordered_multiset&lt;<span class="hljs-keyword">int</span>&gt; s;<br><br>作者：yxc<br>链接：https:<span class="hljs-comment">//www.acwing.com/blog/content/404/</span><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h6 id="9-位运算"><a href="#9-位运算" class="headerlink" title="9.位运算"></a>9.位运算</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">   &amp; 与<br>   | 或<br>   ~ 非<br>   ^ 异或<br><br>&gt;&gt; 右移  右移k位等价于/<span class="hljs-number">2</span>^k<br>&gt;&gt; &lt;&lt; 左移  左移k位等价于*<span class="hljs-number">2</span>^k<br><br>常用操作：<br>(<span class="hljs-number">1</span>)求x的第k位数字  x &gt;&gt; k &amp; <span class="hljs-number">1</span> (个位是第<span class="hljs-number">0</span>位)<br>(<span class="hljs-number">2</span>)<span class="hljs-built_in">lowbit</span>(x) = x &amp; -x，返回x的最后一位<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h6 id="求二进制表示中1的个数"><a href="#求二进制表示中1的个数" class="headerlink" title="求二进制表示中1的个数"></a>求二进制表示中1的个数</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getone</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (x)<br>    &#123;<br>        <span class="hljs-keyword">if</span>( (x&gt;&gt;<span class="hljs-number">0</span> &amp; <span class="hljs-number">1</span>)  == <span class="hljs-number">1</span>) cnt++;<br>        x/=<span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><span class="hljs-number">2</span><br> <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-keyword">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>       <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(x) x -= <span class="hljs-built_in">lowbits</span>(x), res++;<br>        cout&lt;&lt;res&lt;&lt;endl;<br>    &#125;<br><span class="hljs-number">3</span><br><span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-keyword">int</span> x, s = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = x; i; i -= i &amp; -i) s ++ ;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, s);<br>    &#125;<br></code></pre></td></tr></table></figure><h6 id="10-常用库函数"><a href="#10-常用库函数" class="headerlink" title="10.常用库函数"></a>10.常用库函数</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++">(<span class="hljs-number">1</span>)reverse 翻转<br>   翻转一个vector：<br>   <span class="hljs-built_in">reverse</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br>   翻转一个数组，元素存放在下标<span class="hljs-number">1</span>~n：<br>   <span class="hljs-built_in">reverse</span>(a + <span class="hljs-number">1</span>, a + <span class="hljs-number">1</span> + n);<br><br>(<span class="hljs-number">2</span>)unique 去重<br>返回去重之后的尾迭代器（或指针），仍然为前闭后开，即这个迭代器是去重之后末尾元素的下一个位置。该函数常用于离散化，利用迭代器（或指针）的减法，可计算出去重后的元素个数。<br>把一个vector去重：<br><span class="hljs-keyword">int</span> m = <span class="hljs-built_in">unique</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>()) – a.<span class="hljs-built_in">begin</span>();<br>把一个数组去重，元素存放在下标<span class="hljs-number">1</span>~n：<br><span class="hljs-keyword">int</span> m = <span class="hljs-built_in">unique</span>(a + <span class="hljs-number">1</span>, a + <span class="hljs-number">1</span> + n) – (a + <span class="hljs-number">1</span>);<br><br>(<span class="hljs-number">3</span>)random_shuffle 随机打乱<br>用法与reverse相同<br><br>(<span class="hljs-number">4</span>)sort<br>对两个迭代器（或指针）指定的部分进行快速排序。可以在第三个参数传入定义大小比较的函数，或者重载“小于号”运算符。<br><br>把一个<span class="hljs-keyword">int</span>数组（元素存放在下标<span class="hljs-number">1</span>~n）从大到小排序，传入比较函数：<br><br><span class="hljs-keyword">int</span> a[MAX_SIZE];<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<span class="hljs-keyword">return</span> a &gt; b; &#125;<br><span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + <span class="hljs-number">1</span> + n, cmp);<br><br>把自定义的结构体vector排序，重载“小于号”运算符：<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rec</span>&#123;</span> <span class="hljs-keyword">int</span> id, x, y; &#125;<br>vector&lt;rec&gt; a;<br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-keyword">const</span> rec &amp;a, <span class="hljs-keyword">const</span> rec &amp;b) &#123;<br><span class="hljs-keyword">return</span> a.x &lt; b.x || a.x == b.x &amp;&amp; a.y &lt; b.y;<br>&#125;<br><span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br><br>(<span class="hljs-number">5</span>)lower_bound/upper_bound  二分<br>lower_bound 的第三个参数传入一个元素x，在两个迭代器（指针）指定的部分上执行二分查找，返回指向第一个大于等于x的元素的位置的迭代器（指针）。<br>upper_bound 的用法和lower_bound大致相同，唯一的区别是查找第一个大于x的元素。当然，两个迭代器（指针）指定的部分应该是提前排好序的。<br><br>在有序<span class="hljs-keyword">int</span>数组（元素存放在下标<span class="hljs-number">1</span>~n）中查找大于等于x的最小整数的下标：<br><span class="hljs-keyword">int</span> I = <span class="hljs-built_in">lower_bound</span>(a + <span class="hljs-number">1</span>, a + <span class="hljs-number">1</span> + n,. x) – a;<br><br>在有序vector&lt;<span class="hljs-keyword">int</span>&gt; 中查找小于等于x的最大整数（假设一定存在）：<br><span class="hljs-keyword">int</span> y = *--<span class="hljs-built_in">upper_bound</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), x);<br></code></pre></td></tr></table></figure><h3 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h3><h6 id="找最大最小"><a href="#找最大最小" class="headerlink" title="找最大最小"></a>找最大最小</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">maxv=<span class="hljs-built_in">max</span>(maxv,a[j]);<br>minv=<span class="hljs-built_in">min</span>(minv,a[j]);<br></code></pre></td></tr></table></figure><h6 id="把每一位数抠出来"><a href="#把每一位数抠出来" class="headerlink" title="把每一位数抠出来"></a>把每一位数抠出来</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> x=i;<br>   <span class="hljs-keyword">while</span>(x)<br>   &#123;<br>       <span class="hljs-keyword">int</span> t=x%<span class="hljs-number">10</span>;<br>       x/=<span class="hljs-number">10</span>;<br>       <span class="hljs-keyword">if</span>( t == <span class="hljs-number">2</span> || t == <span class="hljs-number">0</span>|| t==<span class="hljs-number">1</span> || t=<span class="hljs-number">9</span>) res+=i;<br>   &#125;<br></code></pre></td></tr></table></figure><h6 id="将数组变成数字"><a href="#将数组变成数字" class="headerlink" title="将数组变成数字"></a>将数组变成数字</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">把数组里的数字组合起来，例如a[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>,a[<span class="hljs-number">1</span>]=<span class="hljs-number">2</span>,a[<span class="hljs-number">3</span>]=[<span class="hljs-number">3</span>],想得到<span class="hljs-number">123</span>的话，只需要一重循环，循环内不断*<span class="hljs-number">10</span>+a[i]即可<br>   <span class="hljs-keyword">int</span> <span class="hljs-built_in">cut</span>(<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> e)<br>   &#123;<br>       <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s;i&lt;=e;i++)<br>       res=res*<span class="hljs-number">10</span>+st[i];<br>       <br>       <span class="hljs-keyword">return</span> res;<br>   &#125;<br></code></pre></td></tr></table></figure><h6 id="反序数"><a href="#反序数" class="headerlink" title="反序数"></a>反序数</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">0</span>)&#123;<br>        ans*=<span class="hljs-number">10</span>;<br>        ans+=(n%<span class="hljs-number">10</span>);<br>        n/=<span class="hljs-number">10</span>;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="10进制转x进制"><a href="#10进制转x进制" class="headerlink" title="10进制转x进制"></a>10进制转x进制</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n,x;<br>    <span class="hljs-keyword">char</span> s[<span class="hljs-number">105</span>];<br>    cin&gt;&gt;n&gt;&gt;x;<br>    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">int</span> w=n%<span class="hljs-number">10</span>;  <span class="hljs-comment">//将n逐位分解</span><br>        <span class="hljs-keyword">if</span>(w&lt;<span class="hljs-number">10</span>) s[cnt++]=w+<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">else</span> s[cnt++]=(w<span class="hljs-number">-10</span>)+<span class="hljs-string">&#x27;A&#x27;</span>;<br>        <br>        n/=x;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=cnt<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>    &#123;<br>        cout&lt;&lt;s[i];<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="x进制转10进制"><a href="#x进制转10进制" class="headerlink" title="x进制转10进制"></a>x进制转10进制</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> s[<span class="hljs-number">105</span>];<br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d&quot;</span>,&amp;s,&amp;x);<br>    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> len=<span class="hljs-built_in">strlen</span>(s);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>    &#123;<br>        ans=ans*x;  <span class="hljs-comment">//每次循环都往上乘</span><br>        <span class="hljs-keyword">if</span>(s[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span> ) ans+=s[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">else</span> ans+=(s[i]-<span class="hljs-string">&#x27;A&#x27;</span>)+<span class="hljs-number">10</span><br>    &#125;<br>    <br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="把“2019”变成-2019"><a href="#把“2019”变成-2019" class="headerlink" title="把“2019”变成 2019"></a>把“2019”变成 2019</h6><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">int <span class="hljs-attribute">x</span>=0;<br><span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=0;i&lt;str.size();i++) <span class="hljs-attribute">x</span>=x*10+str[i]-‘0’;*<br></code></pre></td></tr></table></figure><h6 id="分离年月日"><a href="#分离年月日" class="headerlink" title="分离年月日"></a>分离年月日</h6><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> <span class="hljs-built_in">year</span>=<span class="hljs-built_in">date</span>/<span class="hljs-number">10000</span>;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">month</span>=<span class="hljs-built_in">date</span>%<span class="hljs-number">10000</span>/<span class="hljs-number">100</span>;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">day</span>=<span class="hljs-built_in">date</span>%<span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><h6 id="检查日期合法性"><a href="#检查日期合法性" class="headerlink" title="检查日期合法性"></a>检查日期合法性</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> days[<span class="hljs-number">13</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check_valid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> date)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> year=date/<span class="hljs-number">10000</span>;<br>    <span class="hljs-keyword">int</span> month=date%<span class="hljs-number">10000</span>/<span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">int</span> day=date%<span class="hljs-number">100</span>;<br>    <br>    <span class="hljs-keyword">if</span>(month==<span class="hljs-number">0</span> || month&gt;<span class="hljs-number">12</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(day==<span class="hljs-number">0</span>||month!=<span class="hljs-number">2</span> &amp;&amp; day&gt;days[month]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">if</span>(month==<span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-keyword">int</span> leap=year%<span class="hljs-number">100</span> &amp;&amp; year%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>||year%<span class="hljs-number">400</span>==<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(day&gt;<span class="hljs-number">28</span> +leap ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="2001变成回文-2001002"><a href="#2001变成回文-2001002" class="headerlink" title="2001变成回文 2001002"></a>2001变成回文 2001002</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1000</span>; i&lt;<span class="hljs-number">10000</span>;i++)<span class="hljs-comment">//枚举回文数,回文日期</span><br>&#123;<br>    <span class="hljs-keyword">int</span> date=i,x=i;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;j++) date=date*<span class="hljs-number">10</span>+x%<span class="hljs-number">10</span>,x/=<span class="hljs-number">10</span>;<span class="hljs-comment">//每次取最后一个数字加到后面</span><br>    <span class="hljs-keyword">if</span>(date1&lt;=date &amp;&amp; date&lt;=date2 &amp;&amp; <span class="hljs-built_in">check_valid</span>(date)) res++;   <br>&#125;<br></code></pre></td></tr></table></figure><h6 id="自定义比较器"><a href="#自定义比较器" class="headerlink" title="自定义比较器"></a>自定义比较器</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sum</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> s,c,d;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> Sum &amp;t ) <span class="hljs-keyword">const</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(s!=t.s) <span class="hljs-keyword">return</span> s&lt;t.s;<br>        <span class="hljs-keyword">if</span>(c!=t.c) <span class="hljs-keyword">return</span> c&lt;t.c;<br>        <span class="hljs-keyword">return</span> d&lt;t.d;<br>    &#125;<br>&#125;sum[N];<br>用法：<span class="hljs-built_in">sort</span>(sum,sum+m);<br> <span class="hljs-number">2.</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(a%<span class="hljs-number">2</span>==b%<span class="hljs-number">2</span>)<br><span class="hljs-keyword">return</span> a&lt;b;<span class="hljs-comment">//同奇同偶 ，直接按照从小到大 </span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in"><span class="hljs-keyword">return</span></span> (a%<span class="hljs-number">2</span>)&gt;(b%<span class="hljs-number">2</span>);<span class="hljs-comment">//不同奇偶，奇数在前 </span><br>&#125;<br>用法：<span class="hljs-built_in">sort</span>(a,a+n,cmp);<br></code></pre></td></tr></table></figure><h6 id="手写栈和队列"><a href="#手写栈和队列" class="headerlink" title="手写栈和队列"></a>手写栈和队列</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">100010</span>;<br><br><span class="hljs-comment">/******栈******/</span><br><span class="hljs-keyword">int</span> stk[N],tt; <span class="hljs-comment">//tt是栈顶元素下标</span><br><span class="hljs-comment">//插入</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    stk[++tt] = x;<br>&#125;<br><span class="hljs-comment">//弹出</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>    tt --;<br>&#125;<br><span class="hljs-comment">//判断栈是否为空</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isempty</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tt &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//栈顶</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_top</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> stk[tt];<br>&#125;<br><span class="hljs-comment">/******队列******/</span><br><span class="hljs-comment">// hh 表示队头，tt表示队尾</span><br><span class="hljs-keyword">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br>q[ ++ tt] = x;  <span class="hljs-comment">// 向队尾插入一个数</span><br>hh ++ ;  <span class="hljs-comment">// 从队头弹出一个数</span><br>q[hh];  <span class="hljs-comment">// 队头的值</span><br><span class="hljs-keyword">if</span> (hh &lt;= tt)&#123;<span class="hljs-comment">// 判断队列是否为空</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="map用法"><a href="#map用法" class="headerlink" title="map用法"></a>map用法</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> <span class="hljs-title">student</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><br><span class="hljs-class">&#123;</span><br>string id;<br>string name;<br>string gender;<br><span class="hljs-keyword">int</span> age;<br>&#125;;<br><br>map&lt;string,student&gt; M;<br><span class="hljs-keyword">int</span> n,q;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br>student temp;<br>cin&gt;&gt;temp.id&gt;&gt;temp.name&gt;&gt;temp.gender&gt;&gt;temp.age;<br>M[temp.id]=temp;<br>&#125;<br><br>cin&gt;&gt;q;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;q;i++)<br>&#123;<br>string num;<br>cin&gt;&gt;num;<br><span class="hljs-keyword">if</span>((M.<span class="hljs-built_in">find</span>(num))!=M.<span class="hljs-built_in">end</span>())<br>cout&lt;&lt;M[num].id&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;M[num].name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;M[num].gender&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;M[num].age&lt;&lt;endl;<br><br><span class="hljs-keyword">else</span><br>cout&lt;&lt;<span class="hljs-string">&quot;No Answer!&quot;</span>&lt;&lt;endl;<br>&#125;<br>&#125;<br><br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> n,q;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n;<br>map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;M;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br><span class="hljs-keyword">int</span> temp;<br>cin&gt;&gt;temp;<br>M[temp]++;<br>&#125;<br>cin&gt;&gt;q;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;q;i++)<br>&#123;<br><span class="hljs-keyword">int</span> temp;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;temp);<br><span class="hljs-keyword">if</span>(M[temp]!=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find\n&quot;</span>);<br><span class="hljs-keyword">else</span><br>&#123;<br>M[temp]++;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;no\n&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="归并排序-快速排序"><a href="#归并排序-快速排序" class="headerlink" title="归并排序+快速排序"></a>归并排序+快速排序</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100020</span>;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> a[N];<br><span class="hljs-keyword">int</span> tmp[N];<br><span class="hljs-comment">//快排思想</span><br><span class="hljs-comment">//1.选择主元 2.按照大小分成左右,用swap交换，用i,j记录 3.递归操作</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[],<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( l &gt;= r ) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> i = l<span class="hljs-number">-1</span>,j = r+<span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>]; <span class="hljs-comment">//x为主元</span><br>    <span class="hljs-keyword">while</span>(i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(a[i] &lt; x );<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(a[j] &gt; x );<br>        <span class="hljs-keyword">if</span>(i &lt; j) <span class="hljs-built_in">swap</span>(a[i],a[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(a,l,j), <span class="hljs-built_in">quick_sort</span>(a,j+<span class="hljs-number">1</span>,r);<br>&#125;<br><br><span class="hljs-comment">//归并排序思路</span><br><span class="hljs-comment">//1 找中间数，将数组直接分半 2. 分别进行排序 3.合并</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> mid = l+r &gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(l,mid), <span class="hljs-built_in">merge_sort</span>(mid+<span class="hljs-number">1</span>,r);<br>    <span class="hljs-comment">//合并 ,i,j分别指向排序后的两个子数组开头</span><br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)&#123;<br>        <span class="hljs-comment">//哪个小存哪个</span><br>        <span class="hljs-keyword">if</span>(a[i] &lt;= a[j]) tmp[k++] = a[i++];<br>        <span class="hljs-keyword">else</span> tmp[k++] = a[j++];<br>    &#125;<br>    <span class="hljs-comment">//收尾工作</span><br>    <span class="hljs-keyword">while</span>(i&lt;=mid) tmp[k++] = a[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=r) tmp[k++] = a[j++];<br>    <br>    <span class="hljs-comment">//将tmp数组写回原数组 ,j指示tmp数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = l,j = <span class="hljs-number">0</span>; i&lt;=r; i++,j++) a[i] = tmp[j];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i ++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    &#125;<br>  <span class="hljs-comment">//  quick_sort(a,0,n-1);</span><br>    <span class="hljs-built_in">merge_sort</span>(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i ++)&#123;<br>       cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N =<span class="hljs-number">100010</span>,M= <span class="hljs-number">1000010</span>;<br><br><span class="hljs-keyword">char</span> p[N],s[M];<br><span class="hljs-keyword">int</span> ne[N];<br><span class="hljs-keyword">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;p+<span class="hljs-number">1</span>&gt;&gt;m&gt;&gt;s+<span class="hljs-number">1</span>; <span class="hljs-comment">//下标从1开始</span><br>    <br>    <span class="hljs-comment">//求next数组过程</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>,j=<span class="hljs-number">0</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(j &amp;&amp; p[i]!=p[j+<span class="hljs-number">1</span>]) j=ne[j];<br>        <span class="hljs-keyword">if</span>(p[i]==p[j+<span class="hljs-number">1</span>]) j++;<br>        ne[i] = j;<br>    &#125;<br>    <br>    <span class="hljs-comment">//匹配过程</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span> , j=<span class="hljs-number">0</span>; i&lt;=m; i++)  <span class="hljs-comment">//s串从头（1）开始匹配，p串每次试图往前走</span><br>    &#123;<br>        <span class="hljs-keyword">while</span>(j &amp;&amp; s[i]!= p[j+<span class="hljs-number">1</span>]) j=ne[j];<span class="hljs-comment">//如果j不是开始（无法后退），并且遇到不能匹配情况</span><br>        <span class="hljs-keyword">if</span>(s[i]==p[j+<span class="hljs-number">1</span>]) j++;<br>        <span class="hljs-keyword">if</span>(j==n)<br>        &#123;<br>            <span class="hljs-comment">//匹配成功</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,i-n);<br>            j=ne[j];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h6 id="从数组建立树"><a href="#从数组建立树" class="headerlink" title="从数组建立树"></a>从数组建立树</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 2. 有n个结点的完全二叉树存放在一维数组A[1..n]中，试据此建立一棵用二叉链表表示的二叉树 ，根由tree指向。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">200</span>;<br><span class="hljs-keyword">int</span> a[N] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;; <span class="hljs-comment">//下标从 1 开始</span><br><span class="hljs-keyword">int</span> n = <span class="hljs-number">5</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Tree</span>&#123;</span><br>    <span class="hljs-keyword">int</span> v;<br>    Tree *left;<br>    Tree *right;<br>&#125;;<br><br><span class="hljs-function">Tree * <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( u &gt; n ) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    Tree *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Tree</span>();<br>    p-&gt;v = a[u];<br>    p-&gt;right = <span class="hljs-built_in">build</span>(u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);  <span class="hljs-comment">//根据下标关系对应左右子树</span><br>    p-&gt;left = <span class="hljs-built_in">build</span>(u * <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">//先序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(Tree *t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(t)<br>    &#123;<br>        cout&lt;&lt;t-&gt;v&lt;&lt;endl;<br>        <span class="hljs-built_in">show</span>(t-&gt;left);<br>        <span class="hljs-built_in">show</span>(t-&gt;right);<br><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Tree *tree =  <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">show</span>(tree);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="835-Trie字符串统计"><a href="#835-Trie字符串统计" class="headerlink" title="\835. Trie字符串统计"></a>\835. Trie字符串统计</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2</span> * <span class="hljs-number">10010</span>;<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">char</span> str[N];<br><span class="hljs-keyword">int</span> son[N][<span class="hljs-number">26</span>],cnt[N],idx; <span class="hljs-comment">//下标是0的点，既是根节点，又是空节点</span><br><span class="hljs-comment">//son[N][26] 每个节点最多向外连26条边，存储的是每个节点的所有儿子</span><br><span class="hljs-comment">//cnt[N] 存储的是以当前这个点结尾的单词有多少个</span><br><span class="hljs-comment">//idx 当前用到的下标</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span> str[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; str[i]; i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> u = str[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!son[p][u]) son[p][u] = ++idx;<br>        p = son[p][u];<br>    &#125;<br>    cnt[p]++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">char</span> str[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; str[i]; i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> u = str[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!son[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        p = son[p][u];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-keyword">char</span> op[<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>,op,str);<br>        <span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;I&#x27;</span>) <span class="hljs-built_in">insert</span>(str);<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-built_in">query</span>(str)&lt;&lt;endl;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h5><blockquote><ol><li>存储结构</li></ol><p>(1) 开放寻址法</p><p>(2) 拉链法</p><p>例如：</p><p>将一个-109~109的数，映射到0~105</p><ol><li><p>一个哈希函数，一般情况，可以x mod 105</p></li><li><p>冲突</p><p>1.拉链法：开一个一维数组，存所有的hash值（<strong><em>\</em>添加和查找**</strong>操作）</p><p>​    添加就往槽里面插，冲突就拉一条链</p><p>​    删除的话就用一个bool数组记录，而不是真的删除</p><p>2.开放寻址法</p><p>只开一维数组，一条槽，但是长度开数据范围的2到3倍</p><p>添加时，遇到冲突，放下一个坑位</p><p>删除，先查找x，打个特殊标记</p></li></ol></blockquote><h6 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100003</span>;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> h[N],e[N],ne[N],idx; <span class="hljs-comment">//h是槽，每个槽都拉一个单链表</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//k是哈希值 </span><br>    <span class="hljs-keyword">int</span> k = (x % N + N) % N; <span class="hljs-comment">//+N % N 是为了让负数变成正数</span><br>    e[idx] = x;<br>    ne[idx] = h[k];<br>    h[k] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> k = (x % N + N) % N;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[k];i!=<span class="hljs-number">-1</span>; i=ne[i]) <span class="hljs-comment">//遍历那个槽上面的链表</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(e[i] == x)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>    <br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-keyword">char</span> op[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d&quot;</span>,op,&amp;x);<br>        <br>        <span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;I&#x27;</span>) <span class="hljs-built_in">insert</span>(x);<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(x)) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">200003</span>,null = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> h[N];<br><br><span class="hljs-comment">//如果存在返回位置，不存在返回应该存储的位置</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> k = (x % N + N) % N;<br>    <span class="hljs-keyword">while</span>( h[k] != null &amp;&amp; h[k]!=x)<br>    &#123;<br>        k++; <span class="hljs-comment">//坑位不对，往后走</span><br>        <span class="hljs-keyword">if</span>(k == N) k=<span class="hljs-number">0</span>;<span class="hljs-comment">//找到最后一个坑位了之后，返回第一个坑位找</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> k;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> h);<br>    <br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-keyword">char</span> op[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d&quot;</span>,op,&amp;x);<br>        <br>        <span class="hljs-keyword">int</span> k = <span class="hljs-built_in">find</span>(x);<br>        <span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;I&#x27;</span>) h[k] = x;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(h[k] != null ) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol><li>字符串哈希 ——快速判断两个字符串是否相同，用其hash值</li></ol><p>预处理出每个位置的hash</p><p>如何定义每个前缀的哈希值</p><p><strong><em>\</em>看作p进制，将字符串变成数字，然后取个模**</strong></p><p>完成将字符串映射到一个数字（0不可以）</p><p>假设没冲突</p><p>有经验值可以取</p><p>用unsigned long long 存储，不需要取模了</p><p>h数组表示前缀哈希值</p></blockquote><h6 id="841-字符串哈希"><a href="#841-字符串哈希" class="headerlink" title="\841. 字符串哈希"></a>\841. 字符串哈希</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ULL;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>,P=<span class="hljs-number">131</span>;<br><br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">char</span> str[N];<br>ULL h[N],p[N]; <span class="hljs-comment">//p[N]存储p的次方值</span><br><br><span class="hljs-function">ULL <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r] - h[l<span class="hljs-number">-1</span>] * p[r -l + <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%s&quot;</span>,&amp;n,&amp;m,str + <span class="hljs-number">1</span>);<br>    <br>    p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        p[i] = p[i<span class="hljs-number">-1</span>] * P;<br>        h[i] = h[i<span class="hljs-number">-1</span>] * P + str[i];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> l1,r1,l2,r2;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;l1,&amp;r1,&amp;l2,&amp;r2);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(l1,r1) == <span class="hljs-built_in">get</span>(l2,r2)) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="algorithm库"><a href="#algorithm库" class="headerlink" title="algorithm库"></a>algorithm库</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br>vector&lt;<span class="hljs-keyword">int</span>&gt; a;<br><br><span class="hljs-comment">// 翻转</span><br><span class="hljs-built_in">reverse</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">reverse</span>(a, a + a.<span class="hljs-built_in">size</span>());<br><br><span class="hljs-comment">// 去重</span><br><span class="hljs-built_in">unique</span>(a, a + a.<span class="hljs-built_in">size</span>());<span class="hljs-comment">// 返回去重后最后一个元素的地址</span><br><span class="hljs-keyword">int</span> m = <span class="hljs-built_in">unique</span>(a, a + a.<span class="hljs-built_in">size</span>()) - a;  <span class="hljs-comment">// 去重后数组的长度</span><br>a.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>()), a.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 真删除重复元素</span><br>    <br><span class="hljs-comment">// 打乱</span><br><span class="hljs-built_in">random_shuffle</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br><br><span class="hljs-comment">// 排序</span><br><span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<span class="hljs-comment">// 升序</span><br><span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), greater&lt;<span class="hljs-keyword">int</span>&gt;());  <span class="hljs-comment">// 降序</span><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<span class="hljs-keyword">return</span> a - b;&#125;<span class="hljs-comment">// 自定义比较方法</span><br><span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), cmp);    <span class="hljs-comment">// 自定义排序</span><br></code></pre></td></tr></table></figure><h6 id="欧几里得算法（最大公约数）"><a href="#欧几里得算法（最大公约数）" class="headerlink" title="欧几里得算法（最大公约数）"></a>欧几里得算法（最大公约数）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> b ? <span class="hljs-built_in">gcd</span>(b, a % b) : a;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="判断质数"><a href="#判断质数" class="headerlink" title="判断质数"></a>判断质数</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br><br>    <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i ; i++)&#123;<br>        <span class="hljs-keyword">if</span>(x % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-keyword">int</span> x;<br>        cin&gt;&gt;x;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">is_prime</span>(x)) cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) x /= i, s ++ ;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;<br>        &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="870-约数个数"><a href="#870-约数个数" class="headerlink" title="870.约数个数"></a>870.约数个数</h6><blockquote><p>其中用到了分解质因数，和一些公式</p><p>如果 N = p1^c1 <em> p2^c2 </em> … <em>pk^ck<br>约数个数： (c1 + 1) </em> (c2 + 1) <em> … </em> (ck + 1)<br>约数之和： (p1^0 + p1^1 + … + p1^c1) <em> … </em> (pk^0 + pk^1 + … + pk^ck)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin&gt;&gt;n;<br>    unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; primes;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> x;<br>        cin&gt;&gt;x;<br>        <span class="hljs-comment">//分解质因数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i&lt;=x / i; i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(x % i == <span class="hljs-number">0</span>)<br>            &#123;<br>                x /= i;<br>                primes[i]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">1</span>) primes[x]++;<br>    &#125;<br><br>    LL res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>( <span class="hljs-keyword">auto</span> prime : primes) res= res *(prime.second + <span class="hljs-number">1</span>) % mod;<br><br>    cout&lt;&lt;res&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="871-约数之和"><a href="#871-约数之和" class="headerlink" title="871.约数之和"></a>871.约数之和</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin&gt;&gt;n;<br>    unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; primes;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> x;<br>        cin&gt;&gt;x;<br>        <span class="hljs-comment">//分解质因数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i&lt;=x / i; i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(x % i == <span class="hljs-number">0</span>)<br>            &#123;<br>                x /= i;<br>                primes[i]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">1</span>) primes[x]++;<br>    &#125;<br><br>    LL res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>( <span class="hljs-keyword">auto</span> prime : primes) <br>    &#123;<br>        <span class="hljs-keyword">int</span> p = prime.first, a = prime.second; <span class="hljs-comment">//p是底数 a是指数</span><br>        LL t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(a--) t = (p * t + <span class="hljs-number">1</span>)%mod;  <span class="hljs-comment">//妙蛙 在求这个式子，求到a次方  p1^0 + p1^1 + ... + p1^c1</span><br>        res = res * t %mod;<br>    &#125;<br><br>    cout&lt;&lt;res&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h5><h6 id="3669-淘金（dp）"><a href="#3669-淘金（dp）" class="headerlink" title="3669.淘金（dp）"></a>3669.淘金（dp）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><span class="hljs-comment">//是dp...</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">210</span>;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> g[N][N];<br><span class="hljs-keyword">int</span> dp[N][N]; <span class="hljs-comment">//dp[i][j] = max(dp[i][j-1],dp[i][j-2] + g[i][j])  </span><br>            <span class="hljs-comment">//要么选这个格子=去掉上一个格子不选+这格金子；要么不选与上一格保持一致</span><br>            <span class="hljs-comment">//表示在第i行，从1-j挖到的最大金子数 </span><br><span class="hljs-keyword">int</span> result[N];  <span class="hljs-comment">//result[i] 表示 1-i行最大金子数；要么选这行，上一行不选+这行金子，要么不选与上一行保持一致</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> g);<br>        <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> dp);<br>        <span class="hljs-built_in">memset</span>(result,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> result);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)&#123;<br>                cin&gt;&gt;g[i][j];<br>            &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">1</span>; j &lt;= m; j++)&#123;<br>                <span class="hljs-keyword">if</span>(j == <span class="hljs-number">1</span>) dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j],g[i][j]);<br>                <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j<span class="hljs-number">-1</span>],dp[i][j<span class="hljs-number">-2</span>] + g[i][j]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>( i == <span class="hljs-number">1</span> ) result[i] = dp[i][m];<br>            result[i] = <span class="hljs-built_in">max</span>(result[i<span class="hljs-number">-1</span>],result[i<span class="hljs-number">-2</span>] + dp[i][m]);<br>        &#125;<br><br>        cout&lt;&lt;result[n]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h5><h6 id="847-图中点的层次-bfs"><a href="#847-图中点的层次-bfs" class="headerlink" title="847. 图中点的层次(bfs)"></a>847. 图中点的层次(bfs)</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><span class="hljs-comment">//bfs</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">int</span> h[N],e[N],ne[N],idx;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> dist[N];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b;<br>    ne[idx] = h[a];<br>    h[a] = idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    idx = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;<span class="hljs-keyword">int</span>&gt; Q;<br>    dist[u] = <span class="hljs-number">0</span>;<br>    Q.<span class="hljs-built_in">push</span>(u);<br><br>    <span class="hljs-keyword">while</span>(Q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">int</span> t = Q.<span class="hljs-built_in">front</span>();<br>        Q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = h[t]; i!=<span class="hljs-number">-1</span>; i=ne[i])<br>        &#123;<br>            <span class="hljs-keyword">int</span> k = e[i];<br>            <span class="hljs-keyword">if</span>(dist[k] == <span class="hljs-number">-1</span>)  <span class="hljs-comment">//直接用距离判断这个点是否来过即可，不需要另开st[N]</span><br>            &#123;<br>                dist[k] = dist[t] + <span class="hljs-number">1</span>;<br>                Q.<span class="hljs-built_in">push</span>(k);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-keyword">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-built_in">add</span>(a,b);<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-built_in">bfs</span>(<span class="hljs-number">1</span>)&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="1101-献给阿尔吉侬的花束-bfs"><a href="#1101-献给阿尔吉侬的花束-bfs" class="headerlink" title="1101. 献给阿尔吉侬的花束 (bfs)"></a>1101. 献给阿尔吉侬的花束 (bfs)</h6><blockquote><p>BFS :</p><p>1.判重数组st[],入队时判重</p><p>2.初始化队列</p><p>3.当队列不空时，取队头，扩展队（将新节点插到队尾）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> y second</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; PII;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">210</span>;<br><br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">char</span> g[N][N];<br><span class="hljs-keyword">int</span> dist[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(PII start,PII end)</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;PII&gt; q;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    dist[start.x][start.y]=<span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push</span>(start);<br>    <br>    <span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<span class="hljs-comment">//记录方向偏移</span><br>    <br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        PII t=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br> <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> x=t.x+dx[i],y=t.y+dy[i];<br>            <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>||x&gt;=n||y&lt;<span class="hljs-number">0</span>||y&gt;=m) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//出界</span><br>            <span class="hljs-keyword">if</span>(g[x][y]==<span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//障碍物</span><br>            <span class="hljs-keyword">if</span>(dist[x][y]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//之前走过</span><br>            <br>            dist[x][y]=dist[t.x][t.y]+<span class="hljs-number">1</span>;<br>            <br>            <span class="hljs-keyword">if</span>(end==<span class="hljs-built_in">make_pair</span>(x,y)) <span class="hljs-keyword">return</span> dist[x][y];<br>            <br>            q.<span class="hljs-built_in">push</span>(&#123;x,y&#125;);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> T;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;T);<br>    <br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;   <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,g[i]);<br>        <br>        PII start,end;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)<br>            <span class="hljs-keyword">if</span>(g[i][j]==<span class="hljs-string">&#x27;S&#x27;</span>) start=&#123;i,j&#125;;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(g[i][j]==<span class="hljs-string">&#x27;E&#x27;</span>) end=&#123;i,j&#125;;<br>            <br>        <span class="hljs-keyword">int</span> distance=<span class="hljs-built_in">bfs</span>(start,end);<br>        <span class="hljs-keyword">if</span>(distance==<span class="hljs-number">-1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;oop!&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,distance);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="845-八数码（bfs）"><a href="#845-八数码（bfs）" class="headerlink" title="845.八数码（bfs）"></a>845.八数码（bfs）</h6><blockquote><p>844.八数码</p><p>求最小变换步数——BFS</p><p>BFS : 1.队列(怎么把状态放队列) 2.dist数组 </p><p>八数码：1.用字符串表示状态“1234X5678” 2.状态转移 恢复，移动，转换</p><p>int k = t.find(‘x’); //得到x在字符串中的下标 string.find方法的使用</p><p>注意：二维坐标和一维坐标的转换！！！秒哇    </p><p>int x = k / 3, y = k % 3; //转换为二维数组的下标（从1开始 ）</p><p>swap(t[k],t[a * 3 + b]); //交换</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,dy[<span class="hljs-number">4</span>] =&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(string start)</span></span><br><span class="hljs-function"></span>&#123;<br>    string end = <span class="hljs-string">&quot;12345678x&quot;</span>;<br>    queue&lt;string&gt; Q;<br>    unordered_map&lt;string,<span class="hljs-keyword">int</span>&gt; dist;<br>    Q.<span class="hljs-built_in">push</span>(start);<br>    dist[start] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//经典bfs</span><br>    <span class="hljs-keyword">while</span>(Q.<span class="hljs-built_in">size</span>())&#123;<br>        string t = Q.<span class="hljs-built_in">front</span>();<br>        Q.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">int</span> distance = dist[t];<br>        <span class="hljs-keyword">if</span>(t == end) <span class="hljs-keyword">return</span> distance;<br><br>        <span class="hljs-comment">//状态转移</span><br>        <span class="hljs-keyword">int</span> k = t.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;x&#x27;</span>); <span class="hljs-comment">//得到x在字符串中的下标</span><br>        <span class="hljs-keyword">int</span> x = k / <span class="hljs-number">3</span>, y = k % <span class="hljs-number">3</span>; <span class="hljs-comment">//转换为二维数组的下标（从1开始 ）</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span> ;i++)&#123;<br>            <span class="hljs-keyword">int</span> a = x + dx[i],b = y + dy[i];<br>            <span class="hljs-keyword">if</span>( a&gt;=<span class="hljs-number">0</span> &amp;&amp; b&gt;=<span class="hljs-number">0</span> &amp;&amp; a&lt;<span class="hljs-number">3</span> &amp;&amp; b&lt;<span class="hljs-number">3</span>)<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(t[k],t[a * <span class="hljs-number">3</span> + b]); <span class="hljs-comment">//交换</span><br>                <span class="hljs-keyword">if</span>(!dist.<span class="hljs-built_in">count</span>(t)) <span class="hljs-comment">//如果是个新状态</span><br>                &#123;<br>                    dist[t] = distance + <span class="hljs-number">1</span>;<br>                    Q.<span class="hljs-built_in">push</span>(t);<br>                &#125;<br>                <span class="hljs-built_in">swap</span>(t[k],t[a * <span class="hljs-number">3</span> + b]); <span class="hljs-comment">//交换</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string start;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)&#123;<br>        <span class="hljs-keyword">char</span> c;<br>        cin&gt;&gt;c;<br>        start+=c;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-built_in">bfs</span>(start)&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="844-走迷宫-bfs"><a href="#844-走迷宫-bfs" class="headerlink" title="844.走迷宫(bfs)"></a>844.走迷宫(bfs)</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; PII;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> g[N][N];<br><span class="hljs-keyword">int</span> dist[N][N];<br><span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    queue&lt;PII&gt; Q;<br>    dist[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    Q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;);<br>    <span class="hljs-keyword">while</span>(Q.<span class="hljs-built_in">size</span>())&#123;<br>        PII t = Q.<span class="hljs-built_in">front</span>();<br>        Q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; <span class="hljs-number">4</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> x =t.first + dx[i],y = t.second+ dy[i];<br>            <span class="hljs-keyword">if</span>(g[x][y] == <span class="hljs-number">1</span> || dist[x][y] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>( x&lt;<span class="hljs-number">1</span> || x&gt;n || y&lt;<span class="hljs-number">1</span> || y&gt;m) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//如果不出界并且没走过并且可以走，就往前走一步</span><br>            dist[x][y] = dist[t.first][t.second] + <span class="hljs-number">1</span>;<br>            Q.<span class="hljs-built_in">push</span>(&#123;x,y&#125;);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dist[n][m];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span> ; j&lt;=m; j++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;g[i][j]);<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-built_in">bfs</span>();<br>    cout&lt;&lt;res&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="844-走迷宫-bfs-手写队列版"><a href="#844-走迷宫-bfs-手写队列版" class="headerlink" title="844.走迷宫(bfs,手写队列版)"></a>844.走迷宫(bfs,手写队列版)</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; PII;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">110</span>;<br><br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> g[N][N];  <span class="hljs-comment">//存地图</span><br><span class="hljs-keyword">int</span> d[N][N];  <span class="hljs-comment">//存每一个点到起点的距离</span><br>PII q[N*N];   <span class="hljs-comment">//手写队列</span><br><span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-keyword">int</span> hh=<span class="hljs-number">0</span>,tt=<span class="hljs-number">0</span>;  <span class="hljs-comment">//队列的头尾指针</span><br>    q[<span class="hljs-number">0</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">//初始化队列</span><br>    <br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">-1</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(d));  <span class="hljs-comment">//初始化所有距离为-1</span><br>    d[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span>(hh&lt;=tt)  <span class="hljs-comment">//当队列不为空</span><br>    &#123;<br>        <span class="hljs-comment">//取对头</span><br>        PII t=q[hh++];  <span class="hljs-comment">//并且hh++后相当于删掉了这个元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> x=t.first + dx[i],y=t.second + dy[i];<br>            <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span> &amp;&amp; x&lt;n &amp;&amp; y&gt;=<span class="hljs-number">0</span> &amp;&amp; y&lt;m &amp;&amp; g[x][y]==<span class="hljs-number">0</span> &amp;&amp; d[x][y]==<span class="hljs-number">-1</span>)  <span class="hljs-comment">//不出界且可以走且是第一次走到</span><br>            &#123;<br>                d[x][y]= d[t.first][t.second]+<span class="hljs-number">1</span>;<br>                q[++tt ]=&#123;x,y&#125;;  <span class="hljs-comment">//将当前节点加入队列</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> d[n<span class="hljs-number">-1</span>][m<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)<br>            cin&gt;&gt;g[i][j];<br>    cout&lt;&lt;<span class="hljs-built_in">bfs</span>()&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="24-机器人的运动范围-bfs"><a href="#24-机器人的运动范围-bfs" class="headerlink" title="24.机器人的运动范围(bfs)"></a>24.机器人的运动范围(bfs)</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getnum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(x)&#123;<br>            res += x%<span class="hljs-number">10</span>;<br>            x /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(y)&#123;<br>            res += y%<span class="hljs-number">10</span>;<br>            y /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span>  res;<br>    &#125;<br><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> threshold, <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols)</span></span><br><span class="hljs-function">    </span>&#123;<br>   <br>        <span class="hljs-keyword">if</span> (!rows || !cols) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,dy[<span class="hljs-number">4</span>] =&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br>        queue&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; Q;<br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-built_in">st</span>(rows, vector&lt;<span class="hljs-keyword">bool</span>&gt;(cols, <span class="hljs-literal">false</span>));<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        Q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;);<br>      <br>        <span class="hljs-keyword">while</span>(Q.<span class="hljs-built_in">size</span>())<br>        &#123;  <br>            <span class="hljs-keyword">auto</span> t = Q.<span class="hljs-built_in">front</span>();<br>            Q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(st[t.first][t.second] || <span class="hljs-built_in">getnum</span>(t.first,t.second) &gt;threshold ) <span class="hljs-keyword">continue</span>; <br>            st[t.first][t.second] = <span class="hljs-literal">true</span>;<br>            cnt ++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123;<br>                <span class="hljs-keyword">int</span> x = t.first + dx[i],y = t.second + dy[i];<br>                <span class="hljs-keyword">if</span>(  x&lt;<span class="hljs-number">0</span> || x&gt;=rows || y&lt;<span class="hljs-number">0</span> || y&gt;=cols) <span class="hljs-keyword">continue</span>;<br>                Q.<span class="hljs-built_in">push</span>(&#123;x,y&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h6 id="43-层序遍历"><a href="#43-层序遍历" class="headerlink" title="43.层序遍历"></a>43.层序遍历</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">printFromTopToBottom</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <br>        queue&lt; TreeNode*&gt; Q;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> res;<br>        <br>        Q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(Q.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">auto</span> t = Q.<span class="hljs-built_in">front</span>();<br>            Q.<span class="hljs-built_in">pop</span>();<br>           res.<span class="hljs-built_in">push_back</span>(t-&gt;val);<br>           <span class="hljs-keyword">if</span>(t-&gt;left)  Q.<span class="hljs-built_in">push</span>(t-&gt;left);<br>           <span class="hljs-keyword">if</span>(t-&gt;right) Q.<span class="hljs-built_in">push</span>(t-&gt;right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h5><blockquote><p>for (int i = 0, j = 0; i &lt; n; i ++ )<br>{<br>   while (j &lt; i &amp;&amp; check(i, j)) j ++ ;</p><p> // 具体问题的逻辑</p><p>}<br>常见问题分类：<br>   (1) 对于一个序列，用两个指针维护一段区间<br>   (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</p><p>最核心用法——优化 O（n2）变 O（n） 最后 i = j跳过这个区间</p><p>暴力是用两重循环</p><p>最简单例子：输入一个字符串，每个单词由空格隔开，输出每个单词（占一行）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">&gt;<span class="hljs-keyword">char</span> str[<span class="hljs-number">100</span>];<br>&gt;<span class="hljs-built_in">get</span>(str);<br>&gt;<span class="hljs-keyword">int</span> n = <span class="hljs-built_in">strlen</span>(str);<br>&gt;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; str[i]; i++)<br>&gt;&#123;<br><span class="hljs-keyword">int</span> j = i;<br><span class="hljs-keyword">while</span>( j&lt;n &amp;&amp; str[j]!=<span class="hljs-string">&#x27; &#x27;</span>) j++; <span class="hljs-comment">//j一开始指向最初的i的位置，符合则往下走，跳出时指向符合的下一个位置</span><br><span class="hljs-comment">//具体问题逻辑</span><br><span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> k =i; k&lt;j; k++) cout&lt;&lt;str[k]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>i = j; <span class="hljs-comment">//i指向j,就是那个空格，下次i++,跳过整个区间</span><br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote><h6 id="799-最长连续不重复子序列"><a href="#799-最长连续不重复子序列" class="headerlink" title="\799. 最长连续不重复子序列"></a>\799. 最长连续不重复子序列</h6><blockquote><p> 暴力O(n^2 )</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++) <span class="hljs-comment">//先枚举终点</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++)<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(j,i)) res = <span class="hljs-built_in">max</span>(res,i-j+<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>双指针O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>; i&lt;n; i++)<br>&#123;<br><span class="hljs-keyword">while</span>(j&lt;=i &amp;&amp; <span class="hljs-built_in">check</span>(j,i)) j++;<br>res = <span class="hljs-built_in">max</span>(res,i-j+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> q[N], s[N];<br><span class="hljs-comment">//y总🐂哇</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;q[i]);<br><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        s[q[i]] ++ ; <span class="hljs-comment">//记录新加进来的元素是否构成重复</span><br>        <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; s[q[i]] &gt; <span class="hljs-number">1</span>) s[q[j ++ ]] -- ; <span class="hljs-comment">//检测到i,j之间有重复，则j往右走，试图消去重复</span><br>        res = <span class="hljs-built_in">max</span>(res, i - j + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    cout &lt;&lt; res &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="3801-最佳连续子数组"><a href="#3801-最佳连续子数组" class="headerlink" title="\3801. 最佳连续子数组"></a>\3801. 最佳连续子数组</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">int</span> v[N];<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-comment">//最大平均数，就是最大值</span><br><span class="hljs-comment">//找最大长度就是看有多少个连续的最大值，，好家伙</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> t;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>        <span class="hljs-keyword">int</span> mx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;v[i]);<br>            mx = <span class="hljs-built_in">max</span>(v[i],mx);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;=n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(v[i] == mx)<br>            &#123;<br>                <span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; <span class="hljs-comment">//双指针</span><br>                <span class="hljs-keyword">while</span>(j&lt;=n &amp;&amp; v[j] == mx ) j++;<br>                res = <span class="hljs-built_in">max</span>(res, j-i);<br>                i = j - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,res);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h5><blockquote><p>值域比较大0-10^9, 个数比较少10^5</p><p>映射到从0开始的自然数</p><ol><li>a[]中可能重复元素 （去重）</li><li>如何计算x离散化后的值</li></ol><p><img src="/images/noteofc++.assets/image-20210815142603327.png" alt="image-20210815142603327"></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-keyword">int</span>&gt; alls; <span class="hljs-comment">// 存储所有待离散化的值</span><br><span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 将所有值排序</span><br>alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()), alls.<span class="hljs-built_in">end</span>());   <span class="hljs-comment">// 去掉重复元素</span><br><br><span class="hljs-comment">// 二分求出x对应的离散化的值</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> <span class="hljs-comment">// 找到第一个大于等于x的位置</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = alls.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (alls[mid] &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>; <span class="hljs-comment">// 映射到1, 2, ...n</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="数组模拟链表"><a href="#数组模拟链表" class="headerlink" title="数组模拟链表"></a>数组模拟链表</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> val;<br>Node *next;<br>&#125;<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>()非常慢<br>一般不采用动态链表的方式<br><br><span class="hljs-number">1.</span>用数组模拟单链表（邻接表，n个链表，最主要的应用是存储树和图）<br>    head-&gt;空<br>    head-&gt;@-&gt;@-&gt;@-&gt;@-&gt;空<br>    head-&gt;<span class="hljs-number">0</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">-1</span>(对应上面的编号)<br>    head-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">7</span>-&gt;<span class="hljs-number">9</span>-&gt;<span class="hljs-number">-1</span>(对应上面的value)<br><br>    每个点都有数值+指针<br>    用数组模拟：<br>    <span class="hljs-keyword">int</span> e[N];  <span class="hljs-comment">//表示节点i的值</span><br>    <span class="hljs-keyword">int</span> ne[N]；  <span class="hljs-comment">//表示节点i的next指针</span><br>    <span class="hljs-keyword">int</span> head;  <span class="hljs-comment">//表示头结点的下标</span><br><span class="hljs-keyword">int</span> idx;  <span class="hljs-comment">//表示当前已经用到的点</span><br>    二者通过下标来关联,空节点下标为<span class="hljs-number">-1</span><br>    e[<span class="hljs-number">0</span>]=<span class="hljs-number">3</span>(value为<span class="hljs-number">3</span>)<br>    ne[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>(<span class="hljs-number">0</span>号点下一个点是<span class="hljs-number">1</span>，故ne[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>)<br>    <br>    e[<span class="hljs-number">1</span>]=<span class="hljs-number">5</span>(value为<span class="hljs-number">5</span>)<br>    ne[<span class="hljs-number">1</span>]=<span class="hljs-number">2</span>(<span class="hljs-number">1</span>号点下一个点是<span class="hljs-number">2</span>)<br>        <br>    e[<span class="hljs-number">3</span>]=<span class="hljs-number">9</span>(value为<span class="hljs-number">9</span>)<br>    ne[<span class="hljs-number">3</span>]=<span class="hljs-number">-1</span>(<span class="hljs-number">3</span>号点下一个为空，用<span class="hljs-number">-1</span>表示)<br>    <br>    关于idx,是一直往后+的保证下一个操作是数组中没有使用的值，至于在插到头结点的函数里面，新增的值的确在数组上排在之前值的后面，但是指向的确实第一个，因为此时头结点指向它，一切从它开始<br>    <span class="hljs-keyword">void</span> <span class="hljs-built_in">init</span>()<br>    &#123;<br>        head=<span class="hljs-number">-1</span>;<br>        idx=<span class="hljs-number">0</span>;  <span class="hljs-comment">//可以从0号点开始分配 </span><br>    &#125;<br><br>    <span class="hljs-comment">//将x插到头结点 </span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_to_head</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        e[idx]=x,ne[idx]=head,head=idx,idx++;<br>    &#125; <br><br>    <span class="hljs-comment">//将x插入到下标为k的点的后面</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> k)</span>  </span><br><span class="hljs-function">    </span>&#123;<br>        e[idx]=x;<br>        ne[idx]=ne[k];<br>        ne[k]=idx;<br>        idx++;<br>    &#125; <br><br>    <span class="hljs-comment">//删除k号点后面的点删掉 </span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ne[k]=ne[ne[k]];<br>    &#125;<br><span class="hljs-number">2.</span>用数组模拟双链表(用来优化问题)<br></code></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">求树中长度最长的路径==树的直径<br>1.任取一点x，求其他点到x的距离存入dist<span class="hljs-comment">[i]</span><br>2.找到距离x最远的点y,重复1，存入dist<span class="hljs-comment">[i]</span><br>3.2中dist<span class="hljs-comment">[i]</span>最大值<br>（求两遍最长路）<br></code></pre></td></tr></table></figure><h6 id="图的存储方式"><a href="#图的存储方式" class="headerlink" title="图的存储方式"></a>图的存储方式</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>用邻接矩阵(适合稠密)<br><span class="hljs-number">2.</span>邻接表(用vector)/单链表<br>存某个点可以到达哪个店、点<br>每个点存一个vector<br><br>h[<span class="hljs-number">1</span>]:(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>),(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>)<br>h[<span class="hljs-number">2</span>]:(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>),(<span class="hljs-number">5</span>,<span class="hljs-number">4</span>)<br>h[<span class="hljs-number">3</span>]:(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>...<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><br><span class="hljs-keyword">int</span> id,w;<br>&#125;;<br><br>vector&lt;Edge&gt; h[N];<br><span class="hljs-keyword">int</span> dist[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> father,<span class="hljs-keyword">int</span> distance)</span></span><br><span class="hljs-function"></span>&#123;<br>dist[u]=distance;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> node :h[u])<br>&#123;<br><span class="hljs-keyword">if</span>(node.id!=father)<br>&#123;<br><span class="hljs-built_in">dfs</span>(node.id,u,distance+node.w);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)<br>&#123;<br><span class="hljs-keyword">int</span> a,b,c;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);<br>h[a].<span class="hljs-built_in">push_back</span>(&#123;b,c&#125;);<br>h[b].<span class="hljs-built_in">push_back</span>(&#123;a,c&#125;);<br> &#125; <br> <br> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);  <span class="hljs-comment">//求其他点到该点的距离 </span><br> <br> <span class="hljs-keyword">int</span> u=<span class="hljs-number">1</span>;<br> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;=n;i++)<br> &#123;<br> <span class="hljs-keyword">if</span>(dist[i]&gt;dist[u]) u=i;<br> &#125;<br> <br>    <span class="hljs-built_in">dfs</span>(u,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br> <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;=n;i++)<br> &#123;<br> <span class="hljs-keyword">if</span>(dist[i]&gt;dist[u]) u=i;<br> &#125;<br> <br> <span class="hljs-keyword">int</span> s=dist[u];<br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,<span class="hljs-number">10</span>*s+s*(s+<span class="hljs-number">1ll</span>)/<span class="hljs-number">2</span>);<br> <br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-comment">//Y用数组模拟链表</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>, M = <span class="hljs-number">200010</span>;<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> h[N], e[M], w[M], ne[M], idx;<br><span class="hljs-keyword">int</span> dist[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> father, <span class="hljs-keyword">int</span> distance)</span></span><br><span class="hljs-function"></span>&#123;<br>    dist[u] = distance;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[u]; ~i; i = ne[i])<br>    &#123;<br>        <span class="hljs-keyword">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (j != father)<br>            <span class="hljs-built_in">dfs</span>(j, u, distance + w[i]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">int</span> a, b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        <span class="hljs-built_in">add</span>(a, b, c), <span class="hljs-built_in">add</span>(b, a, c);<br>    &#125;<br><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">int</span> u = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">if</span> (dist[u] &lt; dist[i])<br>            u = i;<br><br>    <span class="hljs-built_in">dfs</span>(u, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">if</span> (dist[u] &lt; dist[i])<br>            u = i;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, dist[u] * <span class="hljs-number">10</span> + (dist[u] + <span class="hljs-number">1ll</span>) * dist[u] / <span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>作者：yxcc<br>链接：https:<span class="hljs-comment">//www.acwing.com/activity/content/code/content/178927/</span><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h6 id="图的层序遍历"><a href="#图的层序遍历" class="headerlink" title="图的层序遍历"></a>图的层序遍历</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs c++">数组模拟<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">101000</span>; <br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> e[N],ne[N],h[N],idx;<br><span class="hljs-keyword">bool</span> st[N];<br><span class="hljs-keyword">int</span> dist[N];  <span class="hljs-comment">//dist[i]表示i点到1点的距离</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>e[idx]=b,ne[idx]=h[a],h[a]=idx,idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>queue&lt;<span class="hljs-keyword">int</span>&gt; Q;<br>st[u]=<span class="hljs-literal">true</span>;<br>dist[u]=<span class="hljs-number">0</span>;<br>Q.<span class="hljs-built_in">push</span>(u);<br><br><br><span class="hljs-keyword">while</span>(Q.<span class="hljs-built_in">size</span>())<br>&#123;<br><span class="hljs-keyword">int</span>  t=Q.<span class="hljs-built_in">front</span>();<br>Q.<span class="hljs-built_in">pop</span>();<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[t]; i!=<span class="hljs-number">-1</span> ; i=ne[i] )<br>&#123;<br><br> <span class="hljs-comment">//   cout&lt;&lt;&quot;h[&quot;&lt;&lt;t&lt;&lt;&quot;]&quot;&lt;&lt;&quot;:&quot;&lt;&lt;h[t][i]&lt;&lt;endl;</span><br>    <span class="hljs-keyword">int</span> k=e[i];<br>    <span class="hljs-keyword">if</span>(!st[k]) <br>    &#123;<br>        st[k]=<span class="hljs-literal">true</span>;<br>        dist[k]=dist[t]+<span class="hljs-number">1</span>;    <br>    Q.<span class="hljs-built_in">push</span>(k); <br>    &#125;<br><br>&#125;<br><br>&#125;<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><br><span class="hljs-built_in">init</span>();<br><span class="hljs-keyword">while</span>(m--)<br>&#123;<br><span class="hljs-keyword">int</span> a,b;<br>cin&gt;&gt;a&gt;&gt;b;<br><span class="hljs-built_in">add</span>(a,b);<br>&#125;<br><br><span class="hljs-built_in">bfs</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">//for(int i=1;i&lt;=n;i++)</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//    cout&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;dist[i]&lt;&lt;endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-keyword">if</span>(dist[n]==<span class="hljs-number">0</span>) cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br><span class="hljs-keyword">else</span>cout&lt;&lt;dist[n]&lt;&lt;endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br><br>vector存<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">111000</span>; <br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> res;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; h[N];<br><span class="hljs-keyword">bool</span> st[N];<br><span class="hljs-keyword">int</span> dist[N];  <span class="hljs-comment">//dist[i]表示i点到1点的距离</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>queue&lt;<span class="hljs-keyword">int</span>&gt; Q;<br>st[u]=<span class="hljs-literal">true</span>;<br>dist[u]=<span class="hljs-number">0</span>;<br>Q.<span class="hljs-built_in">push</span>(u);<br><br><br><span class="hljs-keyword">while</span>(Q.<span class="hljs-built_in">size</span>())<br>&#123;<br><span class="hljs-keyword">int</span>  t=Q.<span class="hljs-built_in">front</span>();<br>Q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;h[t].<span class="hljs-built_in">size</span>();i++)<br>&#123;<br> <span class="hljs-comment">//   cout&lt;&lt;&quot;h[&quot;&lt;&lt;t&lt;&lt;&quot;]&quot;&lt;&lt;&quot;:&quot;&lt;&lt;h[t][i]&lt;&lt;endl;</span><br>    <span class="hljs-keyword">int</span> k=h[t][i];<br>    <span class="hljs-keyword">if</span>(!st[k]) <br>    &#123;<br>        st[k]=<span class="hljs-literal">true</span>;<br>        dist[k]=dist[t]+<span class="hljs-number">1</span>;    <br>    Q.<span class="hljs-built_in">push</span>(k); <br>    &#125;<br><br>&#125;<br><br>&#125;<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><br><span class="hljs-keyword">while</span>(m--)<br>&#123;<br><span class="hljs-keyword">int</span> a,b;<br>cin&gt;&gt;a&gt;&gt;b;<br>h[a].<span class="hljs-built_in">push_back</span>(b);<br><span class="hljs-comment">//h[b].push_back(a);</span><br>&#125;<br><br><span class="hljs-built_in">bfs</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">//for(int i=1;i&lt;=n;i++)</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//    cout&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;dist[i]&lt;&lt;endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-keyword">if</span>(dist[n]==<span class="hljs-number">0</span>) cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br><span class="hljs-keyword">else</span><br>cout&lt;&lt;dist[n]&lt;&lt;endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125; <br></code></pre></td></tr></table></figure><h6 id="Dij"><a href="#Dij" class="headerlink" title="Dij"></a>Dij</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">600</span>;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> g[N][N];<br><span class="hljs-keyword">int</span> dist[N];<br><span class="hljs-keyword">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123; <br>        <span class="hljs-comment">//找不在s中，且distt最小的点？？</span><br>        <span class="hljs-keyword">int</span> t=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t==<span class="hljs-number">-1</span> || dist[t]&gt;dist[j]))<br>                t=j;<br>        st[t]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(t==n) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>            dist[j]=<span class="hljs-built_in">min</span>(dist[j],dist[t]+g[t][j]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(dist[n]==<span class="hljs-number">0x3f3f3f3f</span> ) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>    <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> g);<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> x,y,z;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);<br>        g[x][y]=<span class="hljs-built_in">min</span>(g[x][y],z);<br>    &#125;<br>    <br>    cout&lt;&lt;<span class="hljs-built_in">dijkstra</span>()&lt;&lt;endl;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h6 id="3653-好坑的电子地图（Dij自定义起终点）"><a href="#3653-好坑的电子地图（Dij自定义起终点）" class="headerlink" title="3653. 好坑的电子地图（Dij自定义起终点）"></a>3653. 好坑的电子地图（Dij自定义起终点）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1010</span>,INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">int</span> n,m,S,T,A;<br><span class="hljs-keyword">int</span> g[N][N];<br><span class="hljs-keyword">int</span> dist[N];  <span class="hljs-comment">//存所有点到s点的距离</span><br><span class="hljs-keyword">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>( i==j ) g[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> g[i][j] = INF;<br>        &#125;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    <span class="hljs-built_in">memset</span>(st,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> st);  <span class="hljs-comment">//别忘了重新初始化！！！</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dij</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    dist[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">//遍历所有邻接点，找到不在集合st中且距离 起点s最小的点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;= n; i++ )<br>            <span class="hljs-keyword">if</span>(!st[i] &amp;&amp; (t==<span class="hljs-number">-1</span> || dist[t]&gt;dist[i])) t = i;<br>        st[t] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>( t == T ) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//将t加入集合并用它更新其他所有点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;= n; i++ )<br>            dist[i] = <span class="hljs-built_in">min</span>(dist[i],dist[t] + g[t][i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dist[T];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;m&gt;&gt;S&gt;&gt;T&gt;&gt;A)<br>    &#123;<br>        <span class="hljs-built_in">init</span>();<br>        <span class="hljs-keyword">while</span>(m--)<br>        &#123;<br>            <span class="hljs-keyword">int</span> a,b,c;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);<br>            <span class="hljs-keyword">int</span> gap1 = b%<span class="hljs-number">2</span>? <span class="hljs-number">1</span>:<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">int</span> gap2 = a%<span class="hljs-number">2</span>? <span class="hljs-number">1</span>:<span class="hljs-number">2</span>;<br>            g[a][b] = <span class="hljs-built_in">min</span>(g[a][b],c+gap2);<br>            g[b][a] = <span class="hljs-built_in">min</span>(g[b][a],c+gap1);<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> time = <span class="hljs-built_in">dij</span>(S);<br>        <span class="hljs-keyword">if</span>(time &lt;= A ) cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;time&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;KENG&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="有权图最短路堆优化版本"><a href="#有权图最短路堆优化版本" class="headerlink" title="有权图最短路堆优化版本"></a>有权图最短路堆优化版本</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; PII;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">150010</span>;<br><span class="hljs-keyword">int</span> h[N],e[N],ne[N],w[N],idx;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> dist[N];  <span class="hljs-comment">//dist[i]表示i点到1号点的距离</span><br><span class="hljs-keyword">bool</span> st[N];  <span class="hljs-comment">//表示每个点的最短距离是否已经确定</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>&#123;<br>    <br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    dist[u]=<span class="hljs-number">0</span>;<br>    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;<br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<br>   <br>    <span class="hljs-keyword">while</span>(heap.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t=heap.<span class="hljs-built_in">top</span>();  <span class="hljs-comment">//为收录的dist最小的</span><br>        heap.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-keyword">int</span> ver=t.second,distance=t.first;  <span class="hljs-comment">//t点到1号点的距离</span><br>        <span class="hljs-keyword">if</span>(st[ver]) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">//如果访问过了</span><br>        st[ver] = <span class="hljs-literal">true</span>;<br>         <br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[ver]; i!=<span class="hljs-number">-1</span>; i=ne[i])  <span class="hljs-comment">//对ver的每个邻接点</span><br>        &#123;<br>            <span class="hljs-keyword">int</span> j=e[i];<br>            <span class="hljs-keyword">if</span>(dist[j]&gt;distance+w[i])<br>            &#123;    <br>               <span class="hljs-comment">// exit(0);</span><br>                dist[j]=distance+w[i];<br>                heap.<span class="hljs-built_in">push</span>(&#123;dist[j],j&#125;);  <span class="hljs-comment">//存入堆的原因是每次弹出总是最小的dist</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> a,b,c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);<br>        <span class="hljs-built_in">add</span>(a,b,c);<br>    &#125;<br>    <br>    <span class="hljs-built_in">dijkstra</span>(<span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">if</span>(dist[n]==<span class="hljs-number">0x3f3f3f3f</span>) cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br>     <span class="hljs-keyword">else</span>  cout&lt;&lt;dist[n]&lt;&lt;endl;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h6 id="多源有权最短路Floyd"><a href="#多源有权最短路Floyd" class="headerlink" title="多源有权最短路Floyd"></a>多源有权最短路Floyd</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">1e9</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">205</span>;<br><span class="hljs-keyword">int</span> n,m,k,x,y,z;<br><span class="hljs-keyword">int</span> dp[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>            &#123;<br>                dp[i][j]=<span class="hljs-built_in">min</span>(dp[i][j],dp[i][k]+dp[k][j]);<br>            &#125;<br>    <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i==j) dp[i][j]=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> dp[i][j]=INF;<br>        &#125;<br>        <br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br>        dp[x][y]=<span class="hljs-built_in">min</span>(dp[x][y],z);<br>    &#125;<br>    <br>    <span class="hljs-built_in">floyd</span>();<br>    <br>    <span class="hljs-keyword">while</span>(k--)<br>    &#123;<br>        cin&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-keyword">if</span>(dp[x][y]&gt;INF/<span class="hljs-number">2</span>) cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;dp[x][y]&lt;&lt;endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h6 id="最小生成树，村村通问题prim"><a href="#最小生成树，村村通问题prim" class="headerlink" title="最小生成树，村村通问题prim"></a>最小生成树，村村通问题prim</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//prim求最小生成树</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">0.让一颗小树慢慢长大？？？？</span><br><span class="hljs-comment">1.从某个顶点出发，找其邻接的最小dist，将它加入集合</span><br><span class="hljs-comment">2.在集合中找所有邻接的最小dist，将其加入集合</span><br><span class="hljs-comment">3.直到所有点被加入集合，且过程中不能形成回路 </span><br><span class="hljs-comment">4.注意每次加入点的时候只需要判断这个点是否在S集合中，在其中则不加入，间接判断了回路的存在</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span> <br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>; <br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">510</span>;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> g[N][N];<span class="hljs-comment">//用邻接矩阵存储所有的边 </span><br><span class="hljs-keyword">int</span> dist[N];  <span class="hljs-comment">//存储其他点到当前最小生成树的距离 </span><br><span class="hljs-keyword">bool</span> st[N];  <span class="hljs-comment">//存储某个点是否在生成树中 </span><br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br><span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br><span class="hljs-keyword">int</span> t=<span class="hljs-number">-1</span>;  <span class="hljs-comment">//S 外离S最近的点 </span><br><br><span class="hljs-comment">//找出与最小生成树连接的最短距离的点 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>&#123;<br><span class="hljs-comment">//如果不在集合中,并且dist小于原dist (或者t==-1)</span><br><span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t==<span class="hljs-number">-1</span> || dist[t]&gt;dist[j]))<br>t=j;<br>&#125;<br><br><span class="hljs-comment">//i用于集合为空时的特判</span><br><span class="hljs-keyword">if</span>(i&amp;&amp;dist[t]==INF) <span class="hljs-keyword">return</span> INF;  <span class="hljs-comment">//判断连通性,如果找遍了所有的点都跟集合S距离为INF，说明不连通</span><br><br>    <span class="hljs-keyword">if</span>(i)res+=dist[t];<br>st[t]=<span class="hljs-literal">true</span>;  <span class="hljs-comment">//将该点插入到集合S </span><br><br><span class="hljs-comment">//更新集合S外的点到S的距离 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++) dist[j]=<span class="hljs-built_in">min</span>(dist[j],g[t][j]); <br>&#125;<br><br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i ==j) g[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> g[i][j] = INF;<br>        &#125;<br><br><span class="hljs-keyword">while</span>(m--)<br>&#123;<br><span class="hljs-keyword">int</span> a,b,c;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);<br>g[a][b]=g[b][a]=<span class="hljs-built_in">min</span>(g[a][b],c);<br>&#125;<br><br><span class="hljs-keyword">int</span> res=<span class="hljs-built_in">prim</span>();<br><span class="hljs-keyword">if</span>(res==INF) cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">else</span> cout&lt;&lt;res&lt;&lt;endl;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="并查集（朴素）"><a href="#并查集（朴素）" class="headerlink" title="并查集（朴素）"></a>并查集（朴素）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">100100</span>;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> p[N];<br><br><span class="hljs-comment">//find用于查找祖宗节点 </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//只有祖宗节点的p[x]值等于它自己p[x]=x </span><br><span class="hljs-keyword">if</span>(p[x]!=x) p[x]=<span class="hljs-built_in">find</span>(p[x]);<br><br><span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unio</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1,<span class="hljs-keyword">int</span> x2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> r1,r2;<br>r1=<span class="hljs-built_in">find</span>(x1);<br>r2=<span class="hljs-built_in">find</span>(x2);<br><span class="hljs-keyword">if</span>(r1!=r2) p[r1]=r2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) p[i]=i;<br><span class="hljs-keyword">while</span>(m--)<br>&#123;<br><span class="hljs-keyword">char</span> op[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">int</span> a,b;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d%d&quot;</span>,op,&amp;a,&amp;b);<br><span class="hljs-comment">//cout&lt;&lt;*op&lt;&lt;a&lt;&lt;b&lt;&lt;endl;</span><br><span class="hljs-keyword">if</span>(*op==<span class="hljs-string">&#x27;M&#x27;</span>) <span class="hljs-built_in">unio</span>(a,b);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(a)==<span class="hljs-built_in">find</span>(b)) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="并查集维护size"><a href="#并查集维护size" class="headerlink" title="并查集维护size"></a>并查集维护size</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">100100</span>;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> p[N],cap[N];<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x]!=x) p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unio</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(a)!=<span class="hljs-built_in">find</span>(b))<br>    &#123;    <br>        cap[<span class="hljs-built_in">find</span>(b)]+=cap[<span class="hljs-built_in">find</span>(a)];<br>        p[<span class="hljs-built_in">find</span>(a)]=<span class="hljs-built_in">find</span>(b);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        p[i]=i;<br>        cap[i]=<span class="hljs-number">1</span>;<br>    &#125;<br><br>        <br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        string str;<br>        <span class="hljs-keyword">int</span> a,b;<br>        cin&gt;&gt;str;<br>        <span class="hljs-keyword">if</span>(str==<span class="hljs-string">&quot;Q2&quot;</span>)<br>        &#123;<br>            cin&gt;&gt;a;<br>            cout&lt;&lt;cap[<span class="hljs-built_in">find</span>(a)]&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str==<span class="hljs-string">&quot;Q1&quot;</span>)<br>        &#123;<br>            cin&gt;&gt;a&gt;&gt;b;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(a)==<span class="hljs-built_in">find</span>(b))    cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">else</span>     cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str==<span class="hljs-string">&quot;C&quot;</span>)&#123;<br>            cin&gt;&gt;a&gt;&gt;b;<br>            <span class="hljs-built_in">unio</span>(a,b);<br>        &#125;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h6><blockquote><p>算法求最小生成树（用并查集维护连通性）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N =<span class="hljs-number">1e5</span> +<span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M=<span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">int</span> n,m;<br><br><span class="hljs-keyword">int</span> p[N];  <span class="hljs-comment">//并查集的父节点数组</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> a,b,w;<br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> Edge &amp;W) <span class="hljs-keyword">const</span><br>&#123;<br><span class="hljs-keyword">return</span> w&lt;W.w;  <span class="hljs-comment">//从小到大排序 </span><br>&#125;<br> &#125;edges[M];<br> <br> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"> </span>&#123;<br> <span class="hljs-keyword">if</span>(p[x]!=x)<br> p[x]=<span class="hljs-built_in">find</span>(p[x]);<br> <br> <span class="hljs-keyword">return</span> p[x];<br> &#125;<br> <br><br> <br> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br> <span class="hljs-built_in">sort</span>(edges,edges+m);<br> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n; i++) p[i]=i; <span class="hljs-comment">//初始化并查集，判断两个点是不是属于一个集合</span><br> <br> <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>;<br> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span> ;i&lt;m; i++)<br> &#123;<br><span class="hljs-keyword">int</span> a=edges[i].a,b=edges[i].b,w=edges[i].w; <span class="hljs-comment">//取出边最小的那个</span><br><br> <span class="hljs-comment">//如果两个点同属于一个集合，则这个边的加入将会产生回路，不可以加入</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(a)!=<span class="hljs-built_in">find</span>(b))<br>&#123;<br>p[a]=<span class="hljs-built_in">find</span>(b);<br>res+=w;<br>cnt++;<br> &#125; <br>&#125; <br><br><span class="hljs-keyword">if</span>(cnt &lt; n<span class="hljs-number">-1</span> ) <span class="hljs-keyword">return</span> INF;<br><span class="hljs-keyword">return</span> res;<br> &#125;<br> <br> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br> cin&gt;&gt;n&gt;&gt;m;<br> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br> &#123;<br> <span class="hljs-keyword">int</span> u,v,w;<br> <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);<br> <br> edges[i]=&#123;u,v,w&#125;;<br>&#125;<br> <br> <span class="hljs-keyword">int</span> res=<span class="hljs-built_in">kruskal</span>();<br> <br> <span class="hljs-keyword">if</span>(res==INF) cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>&lt;&lt;endl;<br> <span class="hljs-keyword">else</span> cout&lt;&lt;res&lt;&lt;endl;<br> <br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br> <br><br></code></pre></td></tr></table></figure><h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h5><blockquote><p>1.插入一个数</p><p>2.求集合最小值</p><p>3.删除最小值</p><p>4.删除任意一个元素</p><p>5.修改任意一个元素</p><p><strong>堆的存储————用一维数组来存</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br>建堆超级简单啊啊啊啊，直接放好之后调整，从最后一个非叶子节点开始<br><span class="hljs-built_in">O</span>(n)建堆<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n / <span class="hljs-number">2</span>; i; i -- ) <span class="hljs-built_in">down</span>(i);<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//每次down的时候实际上是看当前u是不是三个数中的最小值</span><br>    <span class="hljs-keyword">int</span> t=u;  <span class="hljs-comment">//用t 表示当前三个数中的最小值节点编号</span><br>    <span class="hljs-keyword">if</span>(u*<span class="hljs-number">2</span> &lt;= len &amp;&amp; h[u*<span class="hljs-number">2</span>] &lt;h[t]) t=u*<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(u*<span class="hljs-number">2</span>+<span class="hljs-number">1</span> &lt;= len &amp;&amp; h[u*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]&lt;h[t]) t=u*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(u!=t)<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(h[u],h[t]);<br>        <span class="hljs-built_in">down</span>(t);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">whiel</span>( u / <span class="hljs-number">2</span> &amp;&amp; h[u / <span class="hljs-number">2</span>] &gt; h[u])<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(h[u / <span class="hljs-number">2</span>],h[u]);<br>        u /= <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="838-堆排序"><a href="#838-堆排序" class="headerlink" title="\838. 堆排序"></a>\838. 堆排序</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> h[N];<br><span class="hljs-keyword">int</span> len;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//每次down的时候实际上是看当前u是不是三个数中的最小值</span><br>    <span class="hljs-keyword">int</span> t=u;  <span class="hljs-comment">//用t 表示当前三个数中的最小值节点编号</span><br>    <span class="hljs-keyword">if</span>(u*<span class="hljs-number">2</span> &lt;= len &amp;&amp; h[u*<span class="hljs-number">2</span>] &lt;h[t]) t=u*<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(u*<span class="hljs-number">2</span>+<span class="hljs-number">1</span> &lt;= len &amp;&amp; h[u*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]&lt;h[t]) t=u*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(u!=t)<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(h[u],h[t]);<br>        <span class="hljs-built_in">down</span>(t);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)     <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;h[i]);<br>    len=n;<br>    <span class="hljs-comment">//从倒数第二层开始往上down,O(n)建堆</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n/<span class="hljs-number">2</span>; i ;i--)    <span class="hljs-built_in">down</span>(i);<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,h[<span class="hljs-number">1</span>]);<br>        h[<span class="hljs-number">1</span>]=h[len];<br>        len--;<br>        <span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h5><blockquote><p><code>数论 + 组合计数 + 高斯消元 + 简单博弈论</code></p></blockquote><h6 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h6><blockquote><p><code>求解多元线性方程组</code></p><p>初等行列变换（不影响解）：</p><pre><code class="hljs"> 1. 某行 * 某个非零的数 2. 交换某两行 3. 把某行的若干倍加到另一行</code></pre><p>把矩阵变成上三角的形式</p><p>完美阶梯型——唯一解</p><p>不完美阶梯——0 = 非零 无解</p><p>不完美阶梯——0 = 0 无穷多个解（有的式子可以被消掉）</p><p>高斯消元算法步骤：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs llvm">枚举每一列<span class="hljs-keyword">c</span> (第一轮迭代结束后第一行固定，下面从下面的开始操作)<br><span class="hljs-number">1</span>.当前这列绝对值最大的一行<br><span class="hljs-number">2</span>.将这一行换到最上面<br><span class="hljs-number">3</span>.将该行第一个数变成<span class="hljs-number">1</span><br><span class="hljs-number">4</span>.将下面所有行的第<span class="hljs-keyword">c</span>列消成<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></blockquote><h6 id="求组合数"><a href="#求组合数" class="headerlink" title="求组合数"></a>求组合数</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2010</span>,mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">int</span> c[N][N];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;N; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j&lt;=i; j++)<br>        <span class="hljs-keyword">if</span>(!j) c[i][j] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> c[i][j] = (c[i<span class="hljs-number">-1</span>][j] + c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%mod;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        cout&lt;&lt;c[a][b]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h6><h6 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h6><blockquote><p>nim游戏</p><p>先手必胜 ： 我操作完可以到达一个先手必败状态</p><p>先手必败： 我不管怎么操作，下一个永远是先手必胜状态</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>        res ^=x;  <span class="hljs-comment">//所有石子堆异或为0则先手必败，否则先手必胜</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(res) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ICG函数</p></blockquote><h5 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h5><h6 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h6><blockquote><p>每件物品要么用1次，要么用0次</p><p>总体积小于V，求选出来的最大价值</p></blockquote><h6 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h6><blockquote><p>每件物品有无限个</p></blockquote><h6 id="多重-背包"><a href="#多重-背包" class="headerlink" title="多重 背包"></a>多重 背包</h6><blockquote><p>每个物体的个数有限制</p></blockquote><h6 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h6><blockquote><p>每一组里面最多选一个物体</p></blockquote><h5 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h5><h6 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h6><h6 id="905-区间选点"><a href="#905-区间选点" class="headerlink" title="\905. 区间选点"></a>\905. 区间选点</h6><blockquote><p>1.将每个区间按照右端点从小到大<strong>排序</strong></p><p>2.从前往后依次枚举每个区间</p><ul><li>如果当前区间已经包含点 ，pass</li><li>否则选择右端点（当前最好的选择）</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; PII;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2</span> * <span class="hljs-number">100100</span>,INF = <span class="hljs-number">0x3f3f3f3f</span>;<br>vector&lt;PII&gt; box;<br><span class="hljs-keyword">int</span> n;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> cur = INF;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i&lt;n; i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> a,b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);<br>        box.<span class="hljs-built_in">push_back</span>(&#123;b,a&#125;);<br>    &#125;<br><br>    <span class="hljs-built_in">sort</span>(box.<span class="hljs-built_in">begin</span>(),box.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(cur &lt;= box[i].first &amp;&amp; cur &gt;= box[i].second)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            cur = box[i].first;<br>            cnt++;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;cnt&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="908-最大不相交区间数量"><a href="#908-最大不相交区间数量" class="headerlink" title="\908. 最大不相交区间数量"></a>\908. 最大不相交区间数量</h6><blockquote><p>类似活动时间安排，尽量安排最多的活动</p><p>1.将每个区间右端点从小到大排序 （右端点小，说明结束时间早）</p><p>2.从前往后依次枚举每个区间</p><ul><li>如果当前区间已经包含点 ，pass</li><li>否则选择右端点（当前最好的选择）</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//代码同上一题，一模一样</span><br></code></pre></td></tr></table></figure><h6 id="906-区间分组"><a href="#906-区间分组" class="headerlink" title="\906. 区间分组"></a>\906. 区间分组</h6><blockquote><p>1.按照左端点从小到大排序</p><p>2.从前往后处理每一个区间</p><p>​    a.判断是否能将其放到某组中 L[i] &gt; Max_r（看某组右端点和当前左端点是否有交集）</p><ul><li><p>不存在这样的组，开一个新的组，放入当前区间</p></li><li><p>存在这样的组，将其放入，更新当前组 Max_r</p><p><img src="/images/noteofc++.assets/image-20210826142833153.png" alt="image-20210826142833153" style="zoom:50%;"></p></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>负数补码表示范围以及规格化数</title>
    <link href="/2020/03/07/negative-complement/"/>
    <url>/2020/03/07/negative-complement/</url>
    
    <content type="html"><![CDATA[<p><em>以小数为例</em></p><h2 id="原码形式下"><a href="#原码形式下" class="headerlink" title="原码形式下"></a>原码形式下</h2><ol><li>想象出一个数轴<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck">--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">0</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span>&gt;<br></code></pre></td></tr></table></figure></li><li>将0用原码表示,设机器字长为5，一位符号位,放在数轴上<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck">--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">1</span><span class="hljs-string">.</span><span class="hljs-comment">0000</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">0</span><span class="hljs-string">.</span><span class="hljs-comment">0000</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span>&gt;<br></code></pre></td></tr></table></figure></li><li>不难想象从+0向正半轴的表示范围是0.0000 ~ 0.1111即0~ $1-2^{-4}$</li></ol><ul><li>从-0往负半轴也要有这么大的表示范围,即-（$1-2^{-4}$）~ 0</li></ul><ol><li>故原码小数的表示范围为-（$1-2^{-4}$）~$1-2^{-4}$,但此时<strong>注意</strong>负0和正0之间有“一个单位的空间”，此单位长度为0.0001，即$2^{-4}$（机器无法表示所有连续的小数，故其储存的仍旧是离散的，根据位数的不同，其精确度不一样）</li></ol><h2 id="补码形式下"><a href="#补码形式下" class="headerlink" title="补码形式下"></a>补码形式下</h2><ol><li>+0和-0合二为一，那整个数轴就多出一个单位，那这个单位用来干什么呢？</li><li>这个多出来的单位长度为负半轴扩展了表示范围<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.<span class="hljs-number">0000</span>--.....---<span class="hljs-number">1</span>.<span class="hljs-number">0001</span>---<span class="hljs-number">0</span>.<span class="hljs-number">0000</span>---<span class="hljs-number">0</span>.<span class="hljs-number">0001</span>----&gt;<br></code></pre></td></tr></table></figure></li><li>原本用来表示-0的1.0000被拿到负半轴最左端，它表示什么数呢？</li><li>|-（1-2^-4^）|+|-2^-4^|=1  ,1.0000用来表示-1，负半轴可以延伸到整整1的位置，故补码形式下表示范围是  -1 ~ 1-2^-4^<br>由此不难得到其他形式的取值范围</li></ol><div class="table-container"><table><thead><tr><th>定点机</th><th>小数定点机</th><th>整数定点机</th></tr></thead><tbody><tr><td>原码</td><td>1.1111~0.1111</td><td>1,1111~0,1111</td></tr><tr><td>补码</td><td>1.0000~0.1111</td><td>1,0000~0,1111</td></tr><tr><td>反码</td><td>1.1111~0.1111</td><td>1,1111~0,1111</td></tr></tbody></table></div><p><img src="https://img-blog.csdnimg.cn/20200307204041926.png" alt="在这里插入图片描述"></p><h2 id="补码规格化下的负数取值范围"><a href="#补码规格化下的负数取值范围" class="headerlink" title="补码规格化下的负数取值范围"></a>补码规格化下的负数取值范围</h2><blockquote><p>规格化：规格化又叫做<strong>规格化数</strong>是一种表示浮点数的规格化的表示方法，还可以通过<strong>修改阶码</strong>并同时<strong>移动尾数</strong>的方法使其满足这种规范。</p><p><em>什么意思呢？</em><br>就是通过移动尾数，修改阶码，把尾数移动，要想保证真值不变，必定增减阶码，那么把尾数弄成什么样子呢？<br>解释如下：<br>对于<a href="https://baike.baidu.com/item/%E8%A7%84%E6%A0%BC%E5%8C%96%E6%B5%AE%E7%82%B9%E6%95%B0/4044919">规格化浮点数</a>小数点后第一个值是固定的（正数：1，负数：<a href="https://baike.baidu.com/item/%E5%8E%9F%E7%A0%81/1097586">原码</a>1，<a href="https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81/6854613">补码</a>0），所以该位往往缺省，称为隐藏位。<br>规格化要求尾数：<br>1/R&lt;=|M|&lt;1<br>R=2时： 1/2&lt;=|M|&lt;1 即1/2&lt;=|M|&lt;1<br>将一个浮点数转换为规格化的过程，称为浮点数规格化。</p><p>就是说正数要变成0.1XXXXX，负数原码要变成1.1XXXXX，补码就是1.0XXXXXX<br>问题又来了？<br>补码规格化后负数的取值范围是怎么样，为什么非得1.0XXXXX的形式？不能1.1XXXXX? <em>后文解答</em></p></blockquote><p>现在从<strong>最大负数</strong>开始找起</p><p><a href="https://blog.csdn.net/cj1064789374/article/details/93746574">参考</a></p><ol><li>如果不考虑规格化，最大负数必定为-0.0001，原码1.0001，补码1.1111，显然不符合1.0XXXX的形式</li><li>根据1/2&lt;=|M|&lt;1,不难理解正数要为0.1XXXX的格式，小数点后一位为1，转化为十进制的1/2.</li><li>现在来探索规格化负数补码的范围</li></ol><ul><li>继续往后取，最大负数取-0.0010，原码1.0010，补码1.1110，仍旧不符合1.0XXXXX形式</li><li>取-0.0011，原码1.0011，补码1.1101，不符合</li></ul><ol><li>思考：如果使补码形式为1.0XXXX，那么原码形式为如果为1.0XXXX取反+1后仍为1.0XXX的只有1.0000，显然为0不为负数，所以原码应该为1.1XXXX形式</li></ol><ul><li>取-0.1000，原码1.1000，补码1.1000，这时刚好为-1/2，符合<strong>尾数规格化</strong>的范围，但补码形式不符合</li><li>取-0.1001，原码1.1001，补码1.0111，==符合==，这是负数补码规格化的最大值，形式为1.01111…..11111</li></ul><ol><li>思考：规格化的目的说明如下<blockquote><p>为了提高精度需要使尾数的<a href="https://baike.baidu.com/item/%E6%9C%89%E6%95%88%E4%BD%8D%E6%95%B0/415981">有效位数</a>尽可能占满可用的位数。这种措施称为浮点数的规格化。</p></blockquote></li></ol><ul><li>为什么尾数范围规定在1/2&lt;=|M|&lt;1的范围就可以使有效位数尽可能的占满可用的位数呢？</li><li>这种移动尾数，增减阶码的操作是为了满足上述目的？</li></ul><ol><li>再思考：小数点不动，将尾数左移，每左移一位，阶码减一，保持真值不变，左移到什么程度，就不能再移动? 不能再移动表示-&gt;如果再移动就要<strong>损失</strong>有效数字，故遇到1时规格化停止，原码形式为0.1XXXX，所以1/2&lt;=|尾数|.</li></ol><p>结论：负数补码规格化最大负数形式为1.0111…..111,原码为1.1000….001,最小负数自然是1.0000000….00(-1)<br>故范围为：-1~ -（1/2+2^-n^）</p><p><strong>最后一问</strong>：当取-0.1000时，原码1.1000，补码1.1000，这时刚好为-1/2，符合<strong>尾数规格化</strong>的范围，为什么不从这里开始取值呢？<br>答：为了机器判断方便，往往不把-1/2列入规格化的数，因此，机器只要判断运算结果的尾数最高位（数符）与尾数次高位（第一有效位）是否相同，便可以判断是否是规格化的数。</p>]]></content>
    
    
    <categories>
      
      <category>补码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
