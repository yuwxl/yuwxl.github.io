

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/dog.jpg">
  <link rel="icon" href="/img/dog.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="nayun">
  <meta name="keywords" content="">
  
    <meta name="description" content="cryptographic protocolsPreliminariesA group G is a cyclic group if it can be generated by a single element g (the group generator), namely G &#x3D;&lt; g &gt;.  当一个群G中的所有元素都可以通过重复对某个元素g进行群运算得到时，我们称G是由g生成的。">
<meta property="og:type" content="article">
<meta property="og:title" content="Cryptography">
<meta property="og:url" content="https://yuwxl.github.io/2023/03/14/Cryptography/index.html">
<meta property="og:site_name" content="yu&#39;s blog">
<meta property="og:description" content="cryptographic protocolsPreliminariesA group G is a cyclic group if it can be generated by a single element g (the group generator), namely G &#x3D;&lt; g &gt;.  当一个群G中的所有元素都可以通过重复对某个元素g进行群运算得到时，我们称G是由g生成的。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuwxl.github.io/2023/03/14/images/Cryptography/image-20230507111506472.png">
<meta property="og:image" content="https://yuwxl.github.io/2023/03/14/images/Cryptography/image-20230507125310389.png">
<meta property="og:image" content="https://yuwxl.github.io/images/Cryptography/image-20231109202858735.png">
<meta property="og:image" content="https://yuwxl.github.io/images/Cryptography/image-20231109202936051.png">
<meta property="og:image" content="https://yuwxl.github.io/images/Cryptography/image-20231111105036212.png">
<meta property="og:image" content="https://yuwxl.github.io/images/Cryptography/image-20231111110137884.png">
<meta property="og:image" content="https://yuwxl.github.io/images/Cryptography/image-20231112110854242.png">
<meta property="og:image" content="https://yuwxl.github.io/images/Cryptography/image-20231112110626157.png">
<meta property="og:image" content="https://yuwxl.github.io/images/Cryptography/image-20231112110547213.png">
<meta property="og:image" content="https://yuwxl.github.io/images/Cryptography/image-20231111100152482.png">
<meta property="og:image" content="https://yuwxl.github.io/images/Cryptography/image-20231111100649682.png">
<meta property="og:image" content="https://yuwxl.github.io/images/Cryptography/image-20231110211712499.png">
<meta property="og:image" content="https://yuwxl.github.io/images/Cryptography/image-20231110211735496.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/2547408/202308/2547408-20230818102825517-280815931.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/2547408/202308/2547408-20230818103455967-1838916731.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/2547408/202308/2547408-20230818103656679-912503038.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/2547408/202308/2547408-20230818103732632-1509753267.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/45f71b9c6a5f4ff2b629297e9b05283d.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/2547408/202308/2547408-20230818103848381-1492257467.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/2547408/202308/2547408-20230818110103354-1839546010.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/1f67205bb0c348d1be43dda19c561c25.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/e63da54cb5c94c2fb7b57d4f54695a2d.png">
<meta property="og:image" content="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220513151425557-1186812877.png">
<meta property="og:image" content="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220514161329118-179092651.png">
<meta property="og:image" content="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220514162841123-1240011961.png">
<meta property="og:image" content="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220515125648885-1832649954.png">
<meta property="og:image" content="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220515125632396-194368939.png">
<meta property="og:image" content="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220516145308412-1148001009.png">
<meta property="og:image" content="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220517145446612-124220213.png">
<meta property="og:image" content="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220517145454808-1367273401.png">
<meta property="og:image" content="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220518114312292-2088865640.png">
<meta property="og:image" content="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220520143501420-324864716.png">
<meta property="og:image" content="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220520143629734-632760535.png">
<meta property="article:published_time" content="2023-03-14T02:07:28.000Z">
<meta property="article:modified_time" content="2023-11-12T08:23:16.000Z">
<meta property="article:author" content="nayun">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://yuwxl.github.io/2023/03/14/images/Cryptography/image-20230507111506472.png">
  
  
  
  <title>Cryptography - yu&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yuwxl.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>nana</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/tina.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Cryptography"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-03-14 10:07" pubdate>
          2023年3月14日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          26k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          219 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Cryptography</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="cryptographic-protocols"><a href="#cryptographic-protocols" class="headerlink" title="cryptographic protocols"></a>cryptographic protocols</h1><h2 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h2><p><strong>A group G is a cyclic group if it can be generated by a single element g (the group generator), namely G =&lt; g &gt;.</strong></p>
<blockquote>
<p>当一个群G中的所有元素都可以通过重复对某个元素g进行群运算得到时，我们称G是由g生成的。这个元素g被称为群G的生成元（或称为群元素），并且这个群G被称为由g生成的循环群。也就是说，如果一个群G中所有的元素都可以写成g的幂的形式，那么G就是一个循环群。</p>
<p>一个循环群可以看作是在群运算下对某个元素进行重复变换得到的所有元素的集合。在几何上，循环群可以被看作是一个圆周上的所有点的集合，其中群运算是围绕圆周的旋转操作。</p>
<p>因此，循环群的几何意义是描述了在某个对象（如圆周）上进行的所有可能的对称变换，这些变换可以通过对某个特定的变换进行重复得到。</p>
</blockquote>
<p><strong>Let <script type="math/tex">G1, G2 \    and\     Gτ</script>be three cyclic groups with prime order p. A map e :<script type="math/tex">G1 × G2 → Gτ</script> is a bilinear map if it provides:</strong></p>
<ol>
<li><strong>Bilinearity.<script type="math/tex">∀g1 ∈ G1, g2 ∈ G2 \  and\   α, β ∈ Zp, e(g^α_1 , g^β_2 ) = e(g^β_1 , g^α_2 )= e(g1, g2)^{αβ};</script></strong></li>
<li><strong>Non-degeneracy. <script type="math/tex">∀g1 ∈ G1 \    and\     g2 ∈ G2, e(g1, g2) \neq 1_τ</script> where $1_τ$ is the identity element in Gτ ;</strong></li>
<li><strong>Computability. <script type="math/tex">∀g1 ∈ G1 \    and\      g2 ∈ G2</script>, there exists an efficient algorithm to compute e(g1, g2).</strong></li>
</ol>
<blockquote>
<p>这段文字描述了一个双线性映射（bilinear map），它将两个群（G1和G2）的元素映射到另一个群（Gτ）的元素，这个映射满足以下三个条件：</p>
<ol>
<li>双线性性：对于任意的g1∈G1，g2∈G2和α，β∈Zp，映射$e(g^α_1 , g^β_2 ) = e(g^β_1 , g^α_2 )= e(g1, g2)^{αβ}$，其中gα1表示G1中元素g1的α次方，gβ2表示G2中元素g2的β次方，e是映射函数。</li>
<li>非退化性：对于任意的g1∈G1和g2∈G2，映射e(g1,g2)不等于Gτ中的单位元素1τ。</li>
<li>可计算性：对于任意的g1∈G1和g2∈G2，存在一种有效的算法可以计算e(g1,g2)。</li>
</ol>
<p>在椭圆曲线密码学中，双线性映射可以用于实现各种安全协议和算法，例如身份验证、加密和签名等。由于在椭</p>
<p>圆曲线密码学中使用的双线性映射的阶数为一个非常大的素数，因此它们在密码学中被认为是极难被暴力破解的。</p>
</blockquote>
<p><strong>Let $BG(1^ℓ) → (e, p, G_1, G_2, G_τ )$ be a bilinear group generator.</strong></p>
<blockquote>
<p>$BG(1^ℓ) → (e, p, G_1, G_2, G_τ )$  是一个生成器，它接受一个输入参数 1ℓ，生成一个五元组 (e, p, G1, G2, Gτ )，其中：</p>
<ul>
<li>e : G1 × G2 → Gτ 是一个双线性映射，将 G1 和 G2 中的元素映射到 Gτ 中；</li>
<li>p 是一个素数，是 G1、G2 和 Gτ 的阶数；</li>
<li>G1、G2 和 Gτ 是三个循环群，都是阶数为 p 的素数阶循环群。</li>
</ul>
<p>换句话说，BG(1ℓ) 是一个算法，它根据输入参数 1ℓ 来生成一个椭圆曲线密码学中使用的双线性群。这个群包含三个循环群 G1、G2 和 Gτ，它们的阶数都是一个素数 p。同时，群上还定义了一个双线性映射 e，用来将 G1 和 G2 中的元素映射到 Gτ 中。这个群的生成是基于离散对数难题的，因此在合适的参数下可以提供强大的安全性。</p>
</blockquote>
<p>Boneh and Boyen [6] proposed a short signature scheme on bilinear groups.</p>
<ul>
<li>Setup. Runs $BG(1^ℓ) → (e, p, G_1, G_2, G_τ )$. Let$\   g_1 ∈ G1, g_2 ∈ G2$.</li>
<li>KeyGen. Select $α \stackrel R{\leftarrow} Zp$, and compute $h = g^α_2$ .</li>
<li><p>Sign. To generate a signature on a message x with $x \neq −α,compute \  A = g_1^\frac 1{α+x}$ .</p>
</li>
<li><p>Verify. Check $e(A, hg^x_2) ?= e(g_1, g_2)$.<br>Let $t \stackrel R{\leftarrow} Zp\  $and$ A′ = A^t$, we have</p>
<p><img src="../images/Cryptography/image-20230507111506472.png" srcset="/img/loading.gif" lazyload alt="image-20230507111506472"></p>
<blockquote>
<p>这段式子是Boneh和Boyen在其短签名方案中签名部分的推导，描述了一个基于双线性映射群的短签名方案，其中包括了系统参数生成、密钥生成、签名、验证等步骤。</p>
<p>首先是系统参数的生成，通过运行BG(1ℓ)算法，生成一个双线性映射群(e, p, G1, G2, Gτ)，其中e是双线性映射，p是素数阶，G1、G2和Gτ是三个循环群。</p>
<p>接着是密钥的生成。选择一个随机数α∈Zp作为私钥，计算h=gα2作为公钥。</p>
<p>然后是签名的过程。假设要对消息x进行签名，其中x≠−α。计算A=g1α+x1作为签名。</p>
<p>最后是验证的过程。检查e(A, hgx2)是否等于e(g1, g2)。如果相等，则该签名有效。</p>
<p>在签名算法中，设 $x$ 为要签名的消息，$t$ 为质数 $p$ 的一个随机数，$A’ = A^t$。则有：见上图</p>
<p>其中，第二步到第三步的变化利用了 $g_1$ 和 $g_2$ 的离散对数难题，第四步到第五步的变化利用了双线性映射的性质 $e(g^a_1, g^b_2) = e(g_1, g_2)^{ab}$。因为 $A = g_1^{\alpha+x}$ 和 $h = g_2^{\alpha}$，</p>
<p>最后，签名算法的输出为 $(A’, x, t)$。</p>
</blockquote>
</li>
</ul>
<h2 id="Zero-knowledge-proof"><a href="#Zero-knowledge-proof" class="headerlink" title="Zero-knowledge proof"></a>Zero-knowledge proof</h2><p>(强推)github资源：<a target="_blank" rel="noopener" href="https://github.com/sec-bit/learning-zkp/blob/master/zkp-resource-list.md">https://github.com/sec-bit/learning-zkp/blob/master/zkp-resource-list.md</a></p>
<p>（强推）<a target="_blank" rel="noopener" href="https://secbit.io/blog/2019/08/06/understand-zero-knowledge-proof-by-simulator/">从「模拟」理解零知识证明：平行宇宙与时光倒流</a></p>
<blockquote>
<p> <a target="_blank" rel="noopener" href="https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649">https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649</a> ,</p>
<p> <a target="_blank" rel="noopener" href="https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627">https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627</a> , </p>
<p><a target="_blank" rel="noopener" href="https://medium.com/@VitalikButerin/zk-snarks-under-the-hood-b33151a013f6">https://medium.com/@VitalikButerin/zk-snarks-under-the-hood-b33151a013f6</a> </p>
<p><a target="_blank" rel="noopener" href="https://snowolf0620.xyz/index.php/zkp/435.html">https://snowolf0620.xyz/index.php/zkp/435.html</a></p>
</blockquote>
<p>在密码学中，零知识证明（ZKP）或零知识协议是一种方法，通过这种方法，一方（证明者）可以向另一方（验证者）证明给定的陈述是真的，而证明者除了陈述确实是真之外，避免传递任何附加信息。</p>
<p>有两种类型的ZKP协议：1.交互式ZKP；2.非交互式ZKP。</p>
<p>交互式ZKP协议需要证明者P和验证器V之间的交互。广为人知的协议是∑协议。</p>
<blockquote>
<p>交互式零知识证明协议要求证明者P和验证者V之间进行交互。其中，一个著名的协议是Σ协议。在Σ协议中，证明者首先向验证者发送一个随机数，然后验证者向证明者发送一个随机数，并要求证明者进行计算。证明者再次向验证者发送一个响应，验证者通过计算来验证证明者的响应是否正确。如果验证成功，则认为证明者已经成功地证明了其声称的声明，而且验证者不会学习到任何关于证明者的额外信息。</p>
</blockquote>
<p><img src="../images/Cryptography/image-20230507125310389.png" srcset="/img/loading.gif" lazyload alt="image-20230507125310389" style="zoom: 67%;"></p>
<blockquote>
<p>这段代码和方案是一个基于离散对数的交互式零知识证明协议，其中P（证明者）和V（验证者）需要进行交互才能完成证明。</p>
<p>在这个方案中，P选择一个随机数t，计算T=gt，并从Zp中选择一个随机数c。然后，P将T和c发送给V。V随机选择一个值s并将其发送给P。接着，P根据s计算出自己的证明：将s带入方程s=t−cx，并计算出α=t−cx，β=c和γ=−x。然后，P将证明发送给V。</p>
<p>V接收到证明后，首先检查T是否等于gsYc，如果不相等则证明失败。然后，V将α、β和γ发送给P，让P计算˜T=˜gβ˜hγ，并检查˜T是否等于T。如果相等，则证明通过。</p>
<p>这个协议被称为Σ协议，可以用于保护交易和身份验证等领域。</p>
</blockquote>
<h2 id="Group-signature"><a href="#Group-signature" class="headerlink" title="Group signature"></a>Group signature</h2><h2 id="Ring-signature"><a href="#Ring-signature" class="headerlink" title="Ring signature"></a>Ring signature</h2><h2 id="Anonymous-credential"><a href="#Anonymous-credential" class="headerlink" title="Anonymous credential"></a>Anonymous credential</h2><h2 id="Oblivious-transfer"><a href="#Oblivious-transfer" class="headerlink" title="Oblivious transfer"></a>Oblivious transfer</h2><h2 id="椭圆曲线密码学"><a href="#椭圆曲线密码学" class="headerlink" title="椭圆曲线密码学"></a>椭圆曲线密码学</h2><p><a target="_blank" rel="noopener" href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">椭圆曲线密码学：简单介绍</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/36326221">翻译</a></p>
<p><a target="_blank" rel="noopener" href="https://vitalik.ca/general/2017/01/14/exploring_ecp.html">探索椭圆曲线配对</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/">椭圆曲线密码学（相对容易理解）入门</a></p>
<p>首先，什么是椭圆曲线？<a href="https://link.zhihu.com/?target=http%3A//mathworld.wolfram.com/">Wolfram MathWorld</a> 给出了非常精准的定义：<strong>一条椭圆曲线就是一组被 $ y^2 = x^3 + ax + b$ 定义的且满足$4a^3 + 27b^2 \ne 0$的点集。</strong> 这个限定条件是为了保证曲线不包含奇点(singularities). $ y^2 = x^3 + ax + b$ 这个方程称为椭圆曲线的维尔斯特拉斯标准形式（<em>Weierstrass normal form</em>）。</p>
<p>另外，我们还需要一个无穷处的点（point at infinity/ideal point）作为曲线的一部分，从现在开始，我们将用 0 这个符号表示无穷处的点。如果我们将无穷处的点也考虑进来的话，那么椭圆曲线的表达式精炼为：</p>
<script type="math/tex; mode=display">
\left\{ (x, y) \in \mathbb{R}^2\ |\ y^2 = x^3 + ax + b,\ 4 a^3 + 27 b^2 \ne 0 \right\}\ \cup\ \left\{ 0 \right\}</script><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stan">\displaystyle <span class="hljs-built_in">e</span>(\<span class="hljs-built_in">pi</span>,[s-z]_2) = <span class="hljs-built_in">e</span>(C-[y]_1, H)<br></code></pre></td></tr></table></figure>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h2 id="什么是群"><a href="#什么是群" class="headerlink" title="什么是群?"></a>什么是群?</h2><p>在抽象代数中，一个群指的是一个集合和一个二元运算，满足以下四个性质：</p>
<ol>
<li>封闭性：对于群中的任意两个元素进行二元运算后，结果仍然属于该群。</li>
<li>结合律：群中的二元运算满足结合律，即对于群中的任意三个元素a、b、c，(a•b)•c = a•(b•c)。</li>
<li>单位元素：存在一个称为单位元素的元素e，对于群中的任意元素a，a•e = e•a = a。</li>
<li>逆元素：对于群中的任意元素a，存在一个元素b，使得a•b = b•a = e，其中e为群的单位元素。这个元素b称为a的逆元素。</li>
</ol>
<p>群的一个重要特征是它的阶（order），即群中元素的个数。另外，群也可以是交换的（满足交换律）或者非交换的。群在密码学中有着重要的应用，比如在公钥密码学中，很多加密算法都是基于群上的运算实现的。</p>
<h2 id="区块链相关密码学"><a href="#区块链相关密码学" class="headerlink" title="区块链相关密码学"></a>区块链相关密码学</h2><p><a target="_blank" rel="noopener" href="https://yeasy.gitbook.io/blockchain_guide/05_crypto/bloom_filter">https://yeasy.gitbook.io/blockchain_guide/05_crypto/bloom_filter</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/sobolevn/awesome-cryptography">https://github.com/sobolevn/awesome-cryptography</a></p>
<h2 id="Schnorr签名与Sigma-Protocol实现的零知识证明"><a href="#Schnorr签名与Sigma-Protocol实现的零知识证明" class="headerlink" title="Schnorr签名与Sigma Protocol实现的零知识证明"></a>Schnorr签名与Sigma Protocol实现的零知识证明</h2><p><a target="_blank" rel="noopener" href="https://github.com/AlexiaChen/AlexiaChen.github.io/issues/123">https://github.com/AlexiaChen/AlexiaChen.github.io/issues/123</a></p>
<p><a target="_blank" rel="noopener" href="https://medium.com/@loveshharchandani/zero-knowledge-proofs-with-sigma-protocols-91e94858a1fb">https://medium.com/@loveshharchandani/zero-knowledge-proofs-with-sigma-protocols-91e94858a1fb</a></p>
<h2 id="环签名"><a href="#环签名" class="headerlink" title="环签名"></a>环签名</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/110023850">https://zhuanlan.zhihu.com/p/110023850</a></p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p><a target="_blank" rel="noopener" href="https://github.com/sobolevn/awesome-cryptography">https://github.com/sobolevn/awesome-cryptography</a></p>
<h2 id="Random-Oracle"><a href="#Random-Oracle" class="headerlink" title="Random Oracle"></a>Random Oracle</h2><blockquote>
<p>In <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cryptography">cryptography</a>, a <strong>random oracle</strong> is an <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Oracle_machine">oracle</a> (a theoretical <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Black_box_(systems">black box</a>)) that responds to every <em>unique query</em> with a (truly) <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Random">random</a> response chosen <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Uniform_distribution_(discrete">uniformly</a>) from its output domain. If a query is repeated, it responds the same way every time that query is submitted.</p>
</blockquote>
<p>理想化的hash</p>
<h2 id="ElGamal加密算法"><a href="#ElGamal加密算法" class="headerlink" title="ElGamal加密算法"></a>ElGamal加密算法</h2><p><img src="/images/Cryptography/image-20231109202858735.png" srcset="/img/loading.gif" lazyload alt="image-20231109202858735"></p>
<p><img src="/images/Cryptography/image-20231109202936051.png" srcset="/img/loading.gif" lazyload alt="image-20231109202936051"></p>
<h2 id="UC-框架"><a href="#UC-框架" class="headerlink" title="UC 框架"></a>UC 框架</h2><blockquote>
<p>直观来讲，在理想的世界（ideal world）中，有理想函数和模拟器，分别对应现实世界中的协议和敌手。模拟器不但要模拟敌手，还要模拟parties，来和环境交互。在理想函数中，我们定义了哪些数据是可以泄露给模拟器的，根据环境所给的input， 模拟器根据泄露的数据模拟相应的操作，生成相应的output给环境。如果环境无法区分跟它交互的是现实中parties还是理想世界中的模拟器，那么，我们说现实世界的协议实现了该理想函数。</p>
<p>现实世界包含：$协议\pi、敌手\mathcal{A}$<br>理想世界包含：理想函数F 、模拟器S</p>
<p>环境Z可以向理想世界、现实世界的各方提供输入，读取所有输出，可以和敌手进行任意的通信</p>
<p>我们说协议π 是安全的：环境无法分辨与它交互的是现实世界还是理想世界</p>
</blockquote>
<p><img src="/images/Cryptography/image-20231111105036212.png" srcset="/img/loading.gif" lazyload alt="image-20231111105036212"></p>
<p><img src="/images/Cryptography/image-20231111110137884.png" srcset="/img/loading.gif" lazyload alt="image-20231111110137884"></p>
<p><img src="/images/Cryptography/image-20231112110854242.png" srcset="/img/loading.gif" lazyload alt="image-20231112110854242"></p>
<blockquote>
<p><img src="/images/Cryptography/image-20231112110626157.png" srcset="/img/loading.gif" lazyload alt="image-20231112110626157"></p>
<p><img src="/images/Cryptography/image-20231112110547213.png" srcset="/img/loading.gif" lazyload alt="image-20231112110547213"></p>
<p> A 是现实环境下的敌手。构造一个理 想环境下的敌手 S，使得对于任意的环境 Z 只能以可忽略的概率区分现实环境(协议 BCOM π 及敌手A交互的环境，记为 REAL)与理想环境(理想函数F com及敌手 S 交互的环境，记为 IDEAL)。</p>
<p>下面构造理想环境下的敌手 S： 任何来自环境Z 的输入都转发给 A，A 的任何输出都被看作是 S的输出。敌手 S 的具体操作如下</p>
<p><a target="_blank" rel="noopener" href="https://kns.cnki.net/kcms2/article/abstract?v=JxCH2R2OgomioSRQOTz1jzxy8r7cbl6vjFskFZfGTrP1WauGX7VmU5kqs04k-0MoJ4u26c3QWQgb2hGI-wUZ6sBPpiv-2ofbqRW04rlmgna8IsEtyK0pxL0-_tgskTWqjNDeRkoUUTI=&amp;uniplatform=NZKPT&amp;language=CHS">通用可组合公平安全多方计算协议</a></p>
<p>[1]雷飞宇. UC安全多方计算模型及其典型应用研究[D].上海交通大学,2007.</p>
<p>理想模型描述协议执行的理想情况， 协议在此模型下可以得到无条件的安全性。</p>
<p>在现实模型中的协议参与者交互计算执行协议， 而在理想模型中协议参与者将协议输入交于一个不可破可信第三方Ideal Functionality F计算， 然后F根据自己的程序计算， 将结果返回给协议参与者， 所谓的Ideal Functionality  就是扮演一个不可破可信第三方的角色， 它能完成协议所执行的功能 。</p>
<p><strong>如何利用仿真建立起现实模型和理想模型之间的桥梁， 将现实模型的安全规约到理想模型的安全?</strong>  </p>
<p>如果攻击者攻击现实模型下的一个协议$\pi$， 不比攻击理想模型下的一个$Ideal Functionality F$获得更大的影响或者更多的信息， 那么$\pi$至少和F一样安全。 </p>
<p>形式化地表述为： 如果任何现实模型攻击者A都存在一个理想模型攻击者S（ 仿真器）， 对于任何输入， 在现实模型下运行包含A的协议$\pi$的全局输出， 它和在理想模型下运行包含S的F的全局输出是不可区分的， 那么$\pi$至少和F一样安全。</p>
<p><img src="/images/Cryptography/image-20231111100152482.png" srcset="/img/loading.gif" lazyload alt="image-20231111100152482"></p>
<p><img src="/images/Cryptography/image-20231111100649682.png" srcset="/img/loading.gif" lazyload alt="image-20231111100649682"></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/pam-sh/p/16383012.html#uc%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E6%9E%84%E9%80%A0">https://www.cnblogs.com/pam-sh/p/16383012.html#uc%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E6%9E%84%E9%80%A0</a></p>
<p><a target="_blank" rel="noopener" href="https://kns.cnki.net/kcms2/article/abstract?v=JxCH2R2OgoloHSqqEYy9bTyJlN1XoLNDe1itvVvbhpvz5L2cDPtT8Ord8yyHuS80YlrYQmx9JxuHQfUDdMXFH3M_G8ao2gQfOwcWu3neWabO2IkutG0SSj4aqHA9s8xmuq2uf1BEp_C2dQaTvv2ssw==&amp;uniplatform=NZKPT&amp;language=CHS">格上不经意传输协议的分析与设计</a></p>
<p><img src="/images/Cryptography/image-20231110211712499.png" srcset="/img/loading.gif" lazyload alt="image-20231110211712499"></p>
<p><img src="/images/Cryptography/image-20231110211735496.png" srcset="/img/loading.gif" lazyload alt="image-20231110211735496"></p>
<h1 id="强推-密码学之可证明安全初探"><a href="#强推-密码学之可证明安全初探" class="headerlink" title="(强推)密码学之可证明安全初探"></a>(强推)<a target="_blank" rel="noopener" href="https://www.cnblogs.com/max1z/p/17637151.html">密码学之可证明安全初探</a></h1><p>本文将简要介绍现代密码学中的一项关键技术: <strong>安全性证明</strong>. 任何一个现代密码算法或协议都需要先经过完整的安全性证明, 才能去讨论其理论和应用价值. 如果一个密码方案无法做到可证明安全, 那么它声称的各种能力都将只是空中楼阁.</p>
<p>然而, 刚开始阅读现代密码学论文的时候, 很容易被其中占据了大量篇幅的安全性证明章节给吓住. 因此本文将简单地对这一主题进行介绍, 在保持简明的同时尽可能体现其核心逻辑. 在阅读本文前, 具备以下背景知识可极大提升阅读体验:</p>
<ul>
<li>现代密码学是一门什么样的学科 ?</li>
<li>如何理解 P� 问题, NP�� 问题 ?</li>
<li>现代密码学中的<a target="_blank" rel="noopener" href="https://www.cnblogs.com/max1z/p/15992505.html">安全模型</a>一般有哪些 ?</li>
</ul>
<h1 id="安全性”证明”"><a href="#安全性”证明”" class="headerlink" title="安全性”证明”?"></a>安全性”证明”?</h1><p>与从小到大学习的各种数学证明类似, 在密码学的安全性证明中, 也需要明确证明的<strong>命题</strong>, 以及命题中的<strong>假设</strong>和待证明<strong>结论</strong>. 然而, 证明一个数学定律这件事是明确的, 比如我们都学习过的各种平面几何定理的证明, 就是要寻求不同线段, 角度, 图形之间的位置或数量规律. 可是我们该怎么用数学的语言 <strong>“证明”</strong> 一个方案的安全性呢? 也就是说, 一个方案安全与否, 如何用 <strong>形式化的数学语言</strong> 来证明呢 ?</p>
<p>在现代密码学发展早期, 人们”证明”方案的安全性就是去寻找<strong>是否存在有效的攻击</strong>, 如果暂时找不到, 就认为这个方案是安全的. 显然, 在这种方式下, 密码学很难被认为是一门严肃的学科. 直到上世纪80年代-90年代, Goldwasser与Bellare才先后提出了密码学的可证明安全理论模型, 这也才让安全性证明具有了与一般数学证明相同的形式和框架. 那在安全性证明中, 假设、待证明结论以及用到的证明技术分别又是什么或代表什么意义呢 ？</p>
<p><img src="https://img2023.cnblogs.com/blog/2547408/202308/2547408-20230818102825517-280815931.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="安全假设"><a href="#安全假设" class="headerlink" title="安全假设"></a>安全假设</h2><p>在理论计算机领域, 我们可以用<strong><em>P\</em> 问题</strong> , <strong><em>NP\</em> 问题</strong>和 <strong><em>NP-Hard\</em> 问题</strong>来描述所处理问题的求解”难度”. 以密码学中的单向函数 (One-Way Function) 为例, 有如下观察来帮助大家理解密码学与 P� <em>vs.</em> NP��之间的联系:</p>
<ul>
<li>单向函数的正向计算就是一个<em>P</em> 问题, 即可以在多项式时间内 (快速) 求解;</li>
<li>单向函数逆的求解好像是一个 <em>NP</em> 问题, 即直接求逆似乎是比较复杂的, 但可以在多项式时间内 (快速) 验证;</li>
</ul>
<p>了解密码学的读者可能知道, 单向函数是几乎所有密码方案和理论的基础. 因此在密码学中, 对于那些具有多项式资源的敌手, 安全假设往往是从那些 <strong>可能是</strong> NP 或 NP-Complete 的问题里来构造. 因为这些问题有计算复杂性理论作为支撑, 且能依赖 P� <em>vs.</em> NP�� 这一数学与计算机界都有研究共识的基础假设.</p>
<blockquote>
<p>📢 可以看到, 目前整个密码学界研究的前提是 P≠NP�≠�� 这一关键假设, 可如果 P=NP�=��了怎么办, 即所有NP问题, P问题和NP-Complete问题都是一样的. 注意到, P=NP�=��只是说明存在一种算法能快速求解原来的NP问题, 但这并不代表着我们就知道这种算法是什么, 因此即使P=NP�=��了, 留给密码学家们依然还有一定的余地.<br>📢 此处我们暂不考虑无条件安全性 (unconditional security)</p>
</blockquote>
<h2 id="待证明结论"><a href="#待证明结论" class="headerlink" title="待证明结论"></a>待证明结论</h2><p>对于要证明的”安全性”, 一个朴素的理解就是敌手无法成功攻击嘛, 加密算法的安全性就是敌手恢复不出明文消息或密钥, 签名算法的安全性就是敌手伪造不出签名. 那我们该怎么刻画”无法攻击成功”, “恢复不出”, “伪造不出”这些词语的本质内涵呢 ?</p>
<p>实际上, 如果用密码学的语义描述出来, 其实就是 不可区分性 (Indistinguishability), 不可伪造性 (Unforgeability) 等定义, 而基于这些定义所构建的各种<a target="_blank" rel="noopener" href="https://www.cnblogs.com/max1z/p/15992505.html">安全模型</a>如 IND-CPA, EUF-CMA就可以作为一个命题最终要证明的结论.</p>
<p>因此, 对于常见的密码学安全命题, 证明的目标就是说明这个算法 <strong>在一定安全假设下符合某个安全模型的要求</strong> . 而在概率多项式时间 (PPT) 敌手的条件下, 这种”要求”一般是以敌手成功的概率上界的形式给出的.</p>
<h1 id="常见的安全假设与结论"><a href="#常见的安全假设与结论" class="headerlink" title="常见的安全假设与结论"></a>常见的安全假设与结论</h1><p>下面我们介绍几个常见的密码学安全证明命题来感觉一下密码学中的可证明安全画风:</p>
<ul>
<li>如果DDH问题是困难的 (安全假设) ⇒⇒ ElGamal算法是IND-CPA安全的 (待证明结论)</li>
<li>如果CDH问题是困难的 ∪∪ 所用哈希函数 H� 是一个Random Oracle (安全假设) ⇒⇒ DHIES 算法是IND-CPA安全的 (待证明结论)</li>
<li>如果DL问题是困难的 (安全假设) ⇒⇒ Schnorr 身份证明协议是UI-PA 安全的; (待证明结论)</li>
<li>如果 Schnorr 身份证明协议是UI-PA 安全的 ∪∪ 所用哈希函数 H� 是一个Random Oracle (安全假设) ⇒⇒ Schnorr 签名算法是EUF-CMA安全的; (待证明结论)</li>
<li>如果 Decisional LEW问题是困难的 (安全假设) ⇒⇒ Dual Regev 算法 (single bit) 是 IND-CPA 安全的 (待证明结论)</li>
</ul>
<p>到现在, 相信读者对整个密码学安全性证明在直观上有了一定的理解, 那么万事具备, 只欠东风. 下面我们就正式开始介绍安全性证明中间的这最重要的一环: 证明技术.</p>
<h1 id="安全性证明的一般技术——归约"><a href="#安全性证明的一般技术——归约" class="headerlink" title="安全性证明的一般技术——归约"></a>安全性证明的一般技术——归约</h1><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>其实, 如果你知道了 <strong>证明逆否命题等价于证明原命题</strong> 这个数学公理, 那么恭喜你已经学会了安全性证明! 当然, 这需要用大量的时间在密码学的语义框架下去内化这一理解, 才能写出自己的证明. 以上一小节的第一个命题为例:</p>
<blockquote>
<p>🔸 DDH问题是困难的 ⇒⇒ ElGamal算法是IND-CPA安全的</p>
</blockquote>
<p>这一命题的逆否命题相信大家都可以很容易地写出:</p>
<blockquote>
<p>🔸 ElGamal算法不是IND-CPA安全的 ⇒⇒ DDH问题可以被攻破</p>
</blockquote>
<p>在密码学的框架下, 上面这个逆否命题实际上表达了这样的一个含义:</p>
<blockquote>
<p>🔸 如果存在一个PPT敌手在 CPA 模型下攻破了ElGamal算法的不可区分性, 那么敌手也就能解决DDH问题</p>
</blockquote>
<p>有了这一观察, 我们该如何证明呢 ? 谜底就在谜面上, 即我们假设真的存在这么一个敌手 A�, 它只要 CPA 模型下接受到了合适的输入, A� 就能返回它对ElGamal加密不可区分游戏的结果; 那么我们可以根据 A� 构造另外一个敌手 B�, B� 的目标是解决 DDH 问题, 在B�被给予了DDH问题的输入后, 我们设法将B� 的难题<strong>嵌入</strong>到 A� 的输入中, 并将 A� 当作是一个子程序 (subroutine) 来调用. 此时, 只要 A� 顺利地解决了ElGamal的不可区分性问题, B� 根据 A� 的输出就能顺利解决自己的DDH问题.</p>
<p>上面这一大段话可以总结为: 将 ElGamal算法的IND-CPA安全性 <strong>归约</strong> (Reduce) 到 DDH问题的困难性上. 示意图如下图所示:</p>
<p><img src="https://img2023.cnblogs.com/blog/2547408/202308/2547408-20230818103455967-1838916731.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<hr>
<h2 id="步骤分解"><a href="#步骤分解" class="headerlink" title="步骤分解"></a>步骤分解</h2><p>可能上面那段话看起来有些云里雾里的, 下面我们就将其按步骤分解一下.</p>
<h3 id="Step-1-我真的有一头牛"><a href="#Step-1-我真的有一头牛" class="headerlink" title="Step 1: 我真的有一头牛"></a>Step 1: 我真的有一头牛</h3><p>证明的整体策略是去证明原命题的逆否命题, 因此原来的目标就成了现在的条件 (反了一下), 所以既然原命题的目标是要证明某个算法是安全的, 那么在逆否命题中就认为攻破这个算法的敌手是存在的.</p>
<p>唯一的要求是, 这个敌手要切实符合之前的假设, 即只有在正确的安全模型下交互才能攻破这个算法, 那这里<strong>正确</strong>的安全模型该如何理解呢 ? 以<a target="_blank" rel="noopener" href="https://www.cnblogs.com/max1z/p/15992505.html">IND-CPA</a>为例:</p>
<ul>
<li>敌手能力: 在IND-CPA模型中, 敌手可被允许提交明文 m� 并获得密文 c�, 即CPA. 这是应当给予敌手的能力;</li>
<li>交互方式: 在IND-CPA模型中, 敌手与其挑战者先经过 q� 次提交 m� 获得 c� 的查询交互过程, 之后敌手提交 (m0,m1)(�0,�1), 挑战者返回 c∗�∗, 敌手输出猜测结果. 整个过程应当由 q� 次查询, 1次敌手提交, 1次挑战者输出这些交互组成, 最终敌手可输出攻击结果;</li>
<li>输出结果: 在IND-CPA模型中, 敌手在给予上述能力, 经过上述交互后, 会输出一个结果比特 b∈{0,1}�∈{0,1}, 来指代密文c∗�∗对应的是哪个明文.</li>
</ul>
<p><img src="https://img2023.cnblogs.com/blog/2547408/202308/2547408-20230818103656679-912503038.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>因此, 在上面那一段话里, 所谓的构造一个IND-CPA的敌手 A� , 就是要全方位地模拟出这样一个IND-CPA的环境, 为这个环境中的A� 赋予其恰当的能力, 配合其交互, 最终接收它的输出结果. 按照预期, 如果 A� 能解决这个问题, 那么应该就能通过某种方法解决原命题中的困难问题.</p>
<hr>
<h3 id="Step-2-究竟要解决什么问题"><a href="#Step-2-究竟要解决什么问题" class="headerlink" title="Step 2: 究竟要解决什么问题 ?"></a>Step 2: 究竟要解决什么问题 ?</h3><p>在确认我们真的有一头牛之后, 下面先来看看最终的目标是什么, 对于上面的例子而言也就是去解决DDH问题. 说白了, 我们的目标就是根据已有的敌手 A� 去<strong>构造</strong>出另外一个敌手B�, 并且让它能解决DDH问题.</p>
<blockquote>
<p>📢 DDH问题: 挑战者给定敌手gx,gy,Tb��,��,��, 其中b∈{0,1}�∈{0,1}, T0�0为群上的随机元素, T1=gxy�1=���, 敌手输出b∗=b�∗=�则问题解决.</p>
</blockquote>
<p>这时你也许发现了, 这个Step 2和刚才的Step 1好像挺类似? 没错, Step 1是我们<strong>已经</strong>构造出的敌手, 而Step 2是我们<strong>想要</strong>构造出的敌手. 不论我们是已经构造还是想要构造, 都要给予两个敌手正确的环境, 也就是所谓的敌手能力、交互方式与输出结果. 类似的有:</p>
<ul>
<li>敌手能力: 在DDH问题中, 敌手可被允许尝试多次问题求解, 即多次接受挑战者的输入.</li>
<li>交互方式: 在DDH问题中, 挑战者首先固定b∈{0,1}�∈{0,1}, 之后 (可多次) 生成元组gx,gy,Tb��,��,��给敌手,</li>
<li>输出结果: 在DDH问题中, 敌手在给予上述能力, 经过上述交互后, 输出一个结果比特 b∗�∗. 若b∗�∗与最开始挑战者选定的b�相等, 那么敌手成功.</li>
</ul>
<p><img src="https://img2023.cnblogs.com/blog/2547408/202308/2547408-20230818103732632-1509753267.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>目前, 我们已经定义好了已经有的敌手A�, 以及要构造的敌手B�, 那下面就来到最关键的一步, 即如何将两个敌手联系起来, 构建它们之间的逻辑关系, 来让我们要证的那个逆否命题成立.</p>
<hr>
<h3 id="Step-3-搭建彼此间的桥梁"><a href="#Step-3-搭建彼此间的桥梁" class="headerlink" title="Step 3: 搭建彼此间的桥梁"></a>Step 3: 搭建彼此间的桥梁</h3><p>要实现这一步, 就需要从算法本身的运算结构出发, 尝试将B�要解决的任务嵌入A�的输入中. ElGamal公钥加密算法的完整过程如下图所示:</p>
<p><img src="https://img-blog.csdnimg.cn/45f71b9c6a5f4ff2b629297e9b05283d.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>目前我们知道:</p>
<ul>
<li>对于敌手 B�, 它的输入为 (gx,gy,Tb)(��,��,��), 它的目标是区分 Tb�� 是 gxy��� 还是 群上的一个随机元素;</li>
<li>对于敌手 A�, 它的输入为 (c∗)(�∗), 即ElGamal的挑战密文, 它的能力是区分 c∗�∗ 是 m0�0 还是 m1�1 对应的密文.</li>
</ul>
<p>乍一看可以发现, B� 自己的那一组DDH输入与ElGamal 算法中 公钥, 密文等元素在计算方式上有着高度的 <strong>相似之处</strong>, 因此, 这里就是 B� 进行问题嵌入的切入点. 注意, 敌手 A� 在 IND-CPA 交互中刚开始的几次密文查询可以直接由敌手B� 使用公钥 gx�� 完成, 因此让我们把目光聚焦到B�收到A�发来的(m0,m1)(�0,�1)这一特殊时刻, 因为这里就是我们真正要实现归约的地方, 接下来B�会这样做:</p>
<ol>
<li>选择一个bit b′∈{0,1}�′∈{0,1}以挑选 mb′��′, 并将自己收到的挑战元素 Tb�� 乘以 mb′��′ 得到 Tb⋅mb′��⋅��′;</li>
<li>B� 令 Elgamal密文 c2=Tb⋅mb′�2=��⋅��′ 并发送 (c1,c2)(�1,�2) 给 A� 作为挑战密文 c∗�∗;</li>
<li>如果A�能以超过1212的概率成功输出一个bit b′�′ 等于 B� 自己选择的b′�′, 那么B�就认为Tb=gxy��=���, 否则 B� 认为 Tb�� 只是群上的一个随机元素.</li>
</ol>
<p>为什么可以这样做呢 ? 假如给 B� 的就是 T=gxy�=���, 那么 B� 为 A� 构造的Elgamal环境就跟真实的Elgamal算法完全相同, 即此时敌手 A� 处于<strong>正确的环境中</strong>, 那么 A� 就当然可以发挥它的能力, 为我们输出一个正确的比特. 反之, 如果 B� 的输入T� 是一个随机挑选的元素, 那么经过乘法后, c2�2 的分布也将是随机分布. 此时, 将不满足 A� 对环境的要求, 因此 A� 也就无法以压倒性概率输出正确的比特 b′�′ 了.</p>
<p><img src="https://img2023.cnblogs.com/blog/2547408/202308/2547408-20230818103848381-1492257467.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<blockquote>
<p>❓ 这里读者也许会有疑问: 明明Elgamal算法里的 y� 也是随机选取的, 那为啥 A� 也能正确输出呢 ?<br>我们这里并不真的关心 y� 以及 gy��的分布, 而是关注 B� 所构造的Elgamal算法的输出密文, 究竟是否按照真实的Elgamal加密算法计算得到. A� 的能力就是在计算过程出了偏差时, <strong>敏感</strong>地作出反应, 即只有严格按照Elgamal算法输出的密文, 它才能以压倒性地成功概率输出结果. 至于 A� 的这种”火眼金睛”是怎么来的, 我们就不用管了, 因为这本身就是假设的一部分.</p>
</blockquote>
<p>进一步地, 我们甚至可以计算 B� 成功的概率. 下面分情况讨论:</p>
<ul>
<li>当 b=0�=0 即 Tb=T0=gxy��=�0=��� 时, A� 能成功恢复, 即此时 A� 输出正确的概率 Pr[A=b′]=12+λPr[�=�′]=12+�, 其中λ� 为一个不可忽略的概率;</li>
<li>当 b=1�=1 即 Tb�� 为一群上的随机元素时, A� 不能成功恢复, 即此时 Pr[A=b′]=12Pr[�=�′]=12.</li>
</ul>
<p>那么敌手 B� 的优势有:</p>
<p>AdvDDHB=|Pr[B=b]−12|=|12Pr[B=1|b=1]+12Pr[B=0|b=0]−12|=|12Pr[B=1|b=1]+12(1−Pr[B=1|b=0])−12|=12|Pr[B=1|b=0]−Pr[B=1|b=1]|=12|(1−Pr[A=b′])−12|=12λAdv����=|Pr[�=�]−12|=|12Pr[�=1|�=1]+12Pr[�=0|�=0]−12|=|12Pr[�=1|�=1]+12(1−Pr[�=1|�=0])−12|=12|Pr[�=1|�=0]−Pr[�=1|�=1]|=12|(1−Pr[�=�′])−12|=12�</p>
<p>可以看到, 如果 A� 的优势是不可忽略的, 那么敌手 B� 的优势也是不可忽略的, 并且上界为12λ12�, 即 A� 优势的一半.</p>
<p>通过观察算法与安全假设之间的共通之处, 找到相同的运算结构, 就可以思考如何将已知敌手的能力运用于解决目标敌手的问题, 从而能将所谓的困难问题或安全假设<strong>嵌入</strong>到已知敌手的求解过程中, 进而成功搭建两个敌手之间的桥梁.</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>目前为止, 证明一个密码学安全命题的基本范式想必读者已经了解了. 整体的思路就是, 在假设成立的前提下, 通过某种方法, 将要证的敌手目标转 (shuǎi) 移 (guō) 给假设成立的敌手. 这里面最困难, 也是最精妙的地方就在于如何去转移. 这就需要对要证算法的运算结构以及假设的本质有足够的理解.</p>
<p>==而像上面举例的这种归约方法, 在计算复杂性上属于Cook Reduction, 归约的结果说明”至少一样难”. 对应到例子中就是只要构造出破解Elgamal的算法, 就可以构造出破解DDH问题的算法, 即前者至少和后者一样难.==</p>
<h1 id="一个算法安全性证明的示例"><a href="#一个算法安全性证明的示例" class="headerlink" title="一个算法安全性证明的示例"></a>一个算法安全性证明的示例</h1><p>下面我们再用一个关于构造算法的安全性证明示例巩固下上面的流程, 给出要证明的安全性命题如下:</p>
<blockquote>
<p>🔸 要证: 在哈希函数H是抗碰撞的前提下, 令 S=(KGen,Sign,Vrfy)�=(����,����,����) 为一EUF-CMA安全的签名算法, 那么基于 S� 构造的另一签名方案 S′=(KGen′,Sign′,Vrfy′)�′=(����′,����′,����′) 也是EUF-CMA安全的**, 其中二者有关系 Sign′(m)=Sign(H(m))����′(�)=����(�(�)).</p>
</blockquote>
<p>这里没用另外一个具体的算法而是用抽象的方案, 这样更能加深对证明内涵的理解, 而不拘泥于算法形式. 那么按照之前的步骤, 在证明开始前先看看逆否命题长什么样:</p>
<blockquote>
<p>🔸 即证: 在哈希函数H是抗碰撞的前提下, 如果签名方案 S′�′ 不是EUF-CMA安全的, 那么 S� 也不是EUF-CMA的.</p>
</blockquote>
<h2 id="构造敌手A"><a href="#构造敌手A" class="headerlink" title="构造敌手A"></a>构造敌手A</h2><p>对于Step 1, 我们构造一个能攻破 S′�′ 签名方案 EUF-CMA 安全性的敌手A�, 示意图如下所示:</p>
<p><img src="https://img2023.cnblogs.com/blog/2547408/202308/2547408-20230818110103354-1839546010.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>该敌手的能力可以归结为以下几点:</p>
<ul>
<li>向实现了 S′�′ 的签名oracle提交消息 m�, 并获得对应的签名 σ�</li>
<li>在重复该过程 q� 次后, 该敌手 A� 能输出一个 (m∗,σ∗)(�∗,�∗), 且 Vrfy(m∗,σ∗)=1����(�∗,�∗)=1, 而且 m∗�∗ 从未被 A� 提交过.</li>
</ul>
<p>这样就构造好了我们假设存在的敌手了. 因为我们这里不涉及任何具体的算法描述, 所以上述能力描述其实适用于绝大多数签名算法. 那么, 对于 B�, 它的能力描述也是类似的.</p>
<h2 id="构造敌手B"><a href="#构造敌手B" class="headerlink" title="构造敌手B"></a>构造敌手B</h2><p>对于Step 2, 我们构造一个目标是攻破 S� 签名方案 EUF-CMA 安全性的敌手 B�, 与敌手 A� 类似, 其示意图如下所示.</p>
<p><img src="https://img-blog.csdnimg.cn/1f67205bb0c348d1be43dda19c561c25.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>而该敌手的能力可以归结为:</p>
<ul>
<li>向实现了 S� 的签名oracle提交消息 m�, 并获得对应的签名 σ�</li>
<li>在重复该过程 q� 次后, 该敌手 B� 能输出一个 (m∗,σ∗)(�∗,�∗), 且 Vrfy(m∗,σ∗)=1����(�∗,�∗)=1, 而且 m∗�∗ 从未被 B� 提交过.</li>
</ul>
<h2 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h2><p>对于Step 3, 由于我们假设了敌手 A� 能攻破方案 S′�′, 因此 B� 可将 A� 作为<strong>子程序</strong>调用, 来为 A� 模拟方案 S′�′:</p>
<ul>
<li>A� 面对着 B� 为它模拟出的方案 S′�′ 的交互环境; 因此 A� 提交 m� 给模拟出的签名oracle Sign′����′;</li>
<li>B� 收到 m� 后, 使用哈希函数 H� 计算 hm=H(m)ℎ�=�(�), 并提交 hmℎ� 给它自己挑战者提供的 S� 的签名oracle Sign����;</li>
<li>当B�的挑战者返回签名后的消息 σ�后, 敌手B�毫无保留地<strong>直接</strong>将σ�传给敌手A�, 来作为其以为的方案S′�′对应的签名.</li>
</ul>
<p>因为 σ=Sign(H(m))=Sign′(m)�=����(�(�))=����′(�), 所以敌手 B� 为敌手 A� 营造出的方案 S′�′ 的Oracle与真实的 S′�′ 是相同的. 也就是对于每次返回的签名 σ�, A� 都有 Vrfy′(m,σ)=1����′(�,�)=1 !</p>
<p>上述步骤重复若干次 (比如 q� 次) 后, 根据假设, A� 应该能正确输出一对 (m∗,σ∗)(�∗,�∗) 使得 Vrfy(m∗,σ∗)=1����(�∗,�∗)=1. 那么, B� 在捕捉到该输出后, 直接计算 hm∗=H(m∗)ℎ�∗=�(�∗), 并输出 (hm∗,σ∗)(ℎ�∗,�∗). (这里的 σ∗�∗ 就是 A� 的输出). 根据 S′�′ 与 S� 二者之间的关系, 同样也有 Vrfy(hm∗,σ∗)=1����(ℎ�∗,�∗)=1. 最终, B� 根据 A� 的能力成功地伪造了方案 S� 的签名, 也就是成功地将方案 S′�′ 的安全性归约到了 S� 的安全性上!</p>
<blockquote>
<p>🔑 为了突出重点, 上述步骤没有包含 S� 与 S′�′ 公私钥的生成与分配, 实际上模拟 S′�′ 的签名私钥可由B任意选取, S� 的私钥则由B的挑战者选取.</p>
</blockquote>
<p>至此, 相信你已经基本明白密码学可证明安全中的归约技术是怎么一回事了. 尽管在现有密码学研究中可证明安全理论也在日益发展, 但其核心思想都逃不过归约这种基础的证明范式. 究其根源, 也在于密码学里的安全性证明本就是建立在开头提到的 NP≠P��≠� 问题上, 证明时也只能基于单个假设来证明具体的安全能力.</p>
<h1 id="基于模拟的安全性证明"><a href="#基于模拟的安全性证明" class="headerlink" title="基于模拟的安全性证明"></a>基于模拟的安全性证明</h1><p>目前, 我们给出的例子都是在讲解如何证明一个密码算法的安全性, 可问题来了, 密码学方案里并非只有密码算法, 还有各种巧妙有趣的密码协议 (Protocol), 比如零知识证明 (Zero Knowledge Proof), 秘密共享 (Secret Sharing), 安全多方计算 (Multi-Party Computation) 等. 那这些方案的安全性该如何证明呢 ?</p>
<p>协议的安全性证明一般是基于模拟 (Simulation) 的思想, 而模拟这一词在上面其实已经出现过了. 在上面的例子中, 敌手 B� 为敌手 A� 所创造出的方案 S′�′ 交互环境, 实际上就是 B� 为 A� <strong>模拟</strong>出来的.</p>
<p><img src="https://img-blog.csdnimg.cn/e63da54cb5c94c2fb7b57d4f54695a2d.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>这也就是说, 敌手 A� 此时并不是在现实世界 (real world) 中与方案 S′�′ 交互, 而是在 B� 为其打造的一个理想世界 (ideal world) 中. 通过恰当的手段, B� 就能将这一理想世界变得对 A� 而言无法与现实世界区分. 在密码协议中也是如此, 下面通过一个小例子来进一步解释模拟这个概念.</p>
<h2 id="一个小例子"><a href="#一个小例子" class="headerlink" title="一个小例子"></a>一个小例子</h2><p>我们还是使用熟悉的密码算法来介绍, 来现有一对称加密方案 π=(G,E,D)�=(�,�,�), 其中 G(1n)�(1�) 是密钥生成算法, E,D�,� 分别是加解密算法. 我们以下定理为基础, 介绍模拟是怎么一回事.</p>
<hr>
<p>如果对于任意PPT敌手 A�, 都存在另外一个PPT敌手 A′�′, 如果下式成立的话, 则称方案 π� 是语义安全的:</p>
<p>Pr[A(1n,Ek(⋅),h(1n))=f(1n)]&lt;Pr[A′(1n,h(1n))=f(1n)]+ϵ(n)Pr[�(1�,��(⋅),ℎ(1�))=�(1�)]&lt;Pr[�′(1�,ℎ(1�))=�(1�)]+�(�)</p>
<p>其中,</p>
<ul>
<li>Ek(⋅)��(⋅) 表示使用加密算法 E� 与密钥 k� 得到的一真实密文</li>
<li>h(1n)ℎ(1�) 表示泄露给外界的加密明文的冗余信息, 比如这条明文被发了几次, 从哪里发送的等等. 注意冗余信息hℎ并不包含明文本身的内容.</li>
<li>f(1n)�(1�) 表示关于明文的某个函数, 比如通过f�就能知道任意明文第几位是0还是1, 第一字节的汉明重量等等. f�表示了能从明文中获取的除了冗余信息与明文长度之外的其他任意信息.</li>
</ul>
<hr>
<p>这个定理也就是说, 如果一个加密方案是语义安全的, 那么这里的敌手 A� 无法比 A′�′ 获取更多的信息, 即密文不会泄露关于明文的其他任何信息. 那么, 我们该如何通过模拟的手段证明一个加密方案 π� 是满足这个定理的呢 ?</p>
<p>实际上, 这里两个敌手的设定已经暗含了模拟的思想. 下面我们直接给出基于模拟的证明思路. 令一 Simulator (模拟器) A′�′ 收到安全参数 1n1� 后, 按步骤运行以下算法</p>
<ul>
<li>A′�′ 运行密钥生成算法 G� 获得密钥 k�;</li>
<li>A′�′ 计算 c=Ek(0n)�=��(0�), 即明文 0n0� 对应的密文</li>
<li>A′�′ 将 A� 作为子程序调用, 即运行 A(1n,c,h(1n))�(1�,�,ℎ(1�))</li>
</ul>
<p>诶这个结构我们是不是刚在上一节的归约那里见过 ? 没错, 只不过这里我们并不强调二者间的归约关系, 而是侧重模拟器 A′�′ 是否能为 A� 完美模拟出一个算法环境. 这里答案当然是不能的. 因为 A′�′ 返回的并不是真实明文对应的密文嘛, 而是始终都返回 0n0� 对应的密文.</p>
<p><strong>因此, 如果 A� 有能力区分输出 “garbage text” (即 Ek(0n)��(0�) ) 与真实密文, 那也就说明 A� 并不会在给予 c� 时输出 f(1n)�(1�) (因为并不是完美地模拟); 而如果 A� 无法区分, 那么它输出 f(1n)�(1�) 的概率应该在跟给予 c� 或 Ek(⋅)��(⋅) 时是一样的. 依据这种概率上的差异, Simulator 通过观察在模拟出的方案执行过程中的敌手输出, 就能得出方案安全性假设的结论, 最终完成证明.</strong></p>
<p>而最后证明的那一步其实也是采取了归约的思路, 但这里是在<strong>模拟</strong>的设定下进行了归约. 也就是说, 基于模拟的证明需要小心仔细地设计如何构造一个<strong>模拟的环境</strong>, 而归约只是证明过程最后的临门一脚. 设计整个模拟的环境才是基于模拟的安全性证明中最重要的地方.</p>
<blockquote>
<p>😳 这一节只是简单介绍模拟的思想, 并没有结合具体的密码协议介绍模拟技术, 因为这需要引入新的敌手模型 (诚实, 半诚实, 恶意) 与 协议类型 (两方/多方下的不经意传输, 承诺, 零知识证明等). 有兴趣的读者可以阅读 Lindell 关于模拟技术的<a target="_blank" rel="noopener" href="https://eprint.iacr.org/2016/046">Tutorial</a></p>
</blockquote>
<h3 id="安全性证明技术分类"><a href="#安全性证明技术分类" class="headerlink" title="安全性证明技术分类"></a>安全性证明技术分类</h3><p>至此我们初步介绍了基于归约和基于模拟的安全证明技术的原理. 在整个密码学安全证明领域, 其实还有不少技术, 下面进行简单总结:</p>
<ul>
<li>归约 (Reduction) 证明</li>
<li>模拟 (Simulation) 证明</li>
<li>基于若干交互游戏的证明 (Game-based Proof)</li>
<li>通用可组合证明 (Universally Composable, UC)</li>
<li>H�-coefficient 技术 (区分随机变量)</li>
<li>χ2�2 技术 (信息论不可区分性)</li>
</ul>
<p>这里罗列的这些技术之间在证明逻辑上互有交叉重叠, 例如UC证明其实就相当于传统模拟证明的升级版. 而我们最需要理解和掌握的就是前面两种最基本的证明技术, 在学习了相关数学工具和抽象方法后, 其他证明技术也能很快理解.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文初步介绍了密码学中的可证明安全技术, 阐述了安全性证明的基本逻辑, 并针对基于归约和基于模拟的证明技术给出了三个示例. 本文仅仅是可证明安全这一话题的初步介绍, 作为一个有严肃数学理论和计算复杂性理论支撑的细分领域, 如果需要真正掌握并运用这些证明技术, 依然需要从各种经典与前沿论文出发, 不断学习和推演.</p>
<h2 id="安全模型"><a href="#安全模型" class="headerlink" title="安全模型"></a>安全模型</h2><blockquote>
<p>转载自：</p>
<p>本文作者：Max1z</p>
<p>本文链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/max1z/p/15992505.html">https://www.cnblogs.com/max1z/p/15992505.html</a></p>
<p>版权声明：本作品采用知识共享署名-非商业性使用-禁止演绎 2.5 中国大陆<a target="_blank" rel="noopener" href="https://www.cnblogs.com/max1z/p/15992505.html">许可协议</a>进行许可。</p>
</blockquote>
<h1 id="密码学之安全模型总结"><a href="#密码学之安全模型总结" class="headerlink" title="密码学之安全模型总结"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/max1z/p/15992505.html">密码学之安全模型总结</a></h1><p>本文将系统性地总结密码学中常见的安全模型定义。在阅读本文前，可以了解如下预备知识：</p>
<ul>
<li>现代密码学是一门怎样的学科？</li>
<li>数据的机密性、完整性与实体的抗否性是什么意思？</li>
<li>完美安全和语义安全的含义是什么？</li>
</ul>
<p>数据的<strong>机密性</strong>、<strong>完整性</strong>和实体的<strong>抗否性</strong>是一个信息安全系统所要保障的主要目标，也是一个密码算法所应满足的基本指标。而在现代密码学与可证明安全的语义下，机密性等含义有着更加严格和完善的定义。</p>
<p>例如，如果描述一个加密算法实现了数据机密性，那么就需要证明这个算法输出的密文与那些随机字符串看起来是不可区分的, 由此敌手就不能从密文中获得任何有关明文和密钥的信息。本文就将围绕着安全系统的这几个主要目标，总结下密码学标准定义中的若干安全模型。</p>
<h1 id="不可区分性"><a href="#不可区分性" class="headerlink" title="不可区分性"></a>不可区分性</h1><p>纵观整个安全性定义的发展，数据机密性是人们一直以来的核心诉求。从香农的完美安全（Perfect Secrecy）到语义安全（Semantic Security），人们都希望一个加密算法的输出应足够随机，以使得其不会泄露关于明文和密钥的任何信息。</p>
<p>为了规范这些“感觉”，前人提出了“<strong>不可区分性</strong>” （Indistinguishibilty， IND）这一概念来描述算法的机密性。然而，一个算法达成不可区分性时所处于的<strong>安全模型</strong>可能是不同的。因此，我们在讨论一个加密算法的<strong>不可区分性强度</strong>时<strong>，</strong>需要明确其面对的安全模型。下面我们就介绍几种在加密算法中常见的IND安全模型。</p>
<blockquote>
<p>注意📌：在密码理论领域的论文中，安全模型通常对应的是Game、Experiment、Image、Procedure等概念。为与论文的表述保持一致，本文会使用Game这个词来指代安全模型。</p>
</blockquote>
<h2 id="IND-CPA"><a href="#IND-CPA" class="headerlink" title="IND-CPA"></a>IND-CPA</h2><p>不多废话，下图就是IND-CPA的示意图。</p>
<p><img src="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220513151425557-1186812877.png" srcset="/img/loading.gif" lazyload alt="img">IND为不可区分，而CPA的含义是Chosen Plaintext Attack。那么IND-CPA所表示的含义为，在敌手能<strong>自行选择明文，并查询对应密文</strong>这一模型中，我们的加密算法是否还能实现密文不可区分。在这一Game中，敌手可以查询任意一条明文消息对应的密文， 这需要我们开放自己算法的加密功能给敌手，即敌手拥有“access to the encryption oracle”的能力。</p>
<p>而结合到上图，IND-CPA这一Game的步骤如下：</p>
<ol>
<li>Game中拥有一具有多项式资源的<strong>敌手A�</strong> 和一个能自由调用加密算法oracle E� 的<strong>挑战者C�</strong>。</li>
<li>C� 随机选取K$←{0,1}n�←${0,1}�，作为加密算法的密钥</li>
<li>A� 向 C� 提交明文 m�, C� 计算 m� 对应的密文 c�</li>
<li>重复步骤 3 q� 次 (即敌手查询 q� 次不同消息的密文)</li>
<li>A� 提交明文 m0�0 与 m1�1 给 C�</li>
<li>C� 以抛硬币（flip a coin）的形式随机选择一个比特 b$←{0,1}�←${0,1}, C� 加密返回挑战密文 cb��</li>
<li>敌手根据 cb�� 输出自己的猜测比特 b∗�∗ (即敌手猜测 C� 是加密的 m0�0 还是 m1�1 )</li>
</ol>
<p>可以看出，IND-CPA实际上是想表达“如果密文足够随机的话，密文是不会泄露任何关于明文信息”这一深层含义。对于IND-CPA的敌手 A�，要赢得这个Game的概率为：</p>
<p>Pr[A wins]=Pr[b∗=b]=12+AdvIND−CPAE(A)Pr[� wins]=Pr[�∗=�]=12+Adv�IND−CPA(�)</p>
<p>其中，我们将 AdvIND−CPAE(A)Adv�IND−CPA(�) 称作 A� 面对 E� 时在IND-CPA Game中获胜的优势。一个安全的加密算法至少要能达到IND-CPA的安全性。而在这个模型中，我们只关心了算法的加密功能和密文本身的随机性，而实际中的敌手也有可能访问解密算法来实现一些攻击。因此，我们需要一种更强的安全模型来<strong>保护我们的解密算法和密文</strong>。</p>
<h2 id="IND-CCA"><a href="#IND-CCA" class="headerlink" title="IND-CCA"></a>IND-CCA</h2><p>与CPA类似，CCA的含义为Chosen Ciphertext Attack，即选择密文攻击。那么在IND-CCA模型中，敌手的能力将是允许访问解密算法的Oracle D�，即敌手可以自行构造密文并提交给 C�，C� 执行解密算法返回解密结果。而最终敌手的目标与IND-CPA还是相同的，即攻破加密的<strong>不可区分性</strong>，其示意图如下所示</p>
<p><img src="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220514161329118-179092651.png" srcset="/img/loading.gif" lazyload alt="img">综上，IND-CCA这一Game的步骤如下</p>
<ol>
<li>Game中拥有一具有多项式资源的<strong>敌手A�</strong> 和一个能自由调用加解密oracle E,D�,� 的<strong>挑战者C�</strong>。</li>
<li>C� 随机选取K$←{0,1}n�←${0,1}�，作为加解密算法的密钥</li>
<li>A�向 C� 提交任意明文 m�, C� 计算对应的密文 c�</li>
<li>A� 向 C� 提交任意密文 c�, C� 计算对应的明文 m�</li>
<li>重复步骤3 q� 次, 步骤4 q′�′ 次 (即敌手查询 q� 次不同消息的密文, 查询q′�′ 次不同密文的解密结果)</li>
<li>A� 提交明文 m0�0 与 m1�1 给 C�</li>
<li>C� 以抛硬币（flip a coin）的形式随机选择一个比特 b$←{0,1}�←${0,1}, C� 加密返回挑战密文 cb��</li>
<li>A� 根据 cb�� 输出自己的猜测比特 b∗�∗ (即敌手猜测 C� 是加密的 m0�0 还是 m1�1 )</li>
</ol>
<p>在此模型中，由于敌手没有密钥, 因此它很难生成合法的密文。因此，A�每次提交的密文大概率会解密出一些无意义的结果，但开放解密Oracle的目的在于，让敌手能在拥有并篡改密文的条件下，依然做到对算法明文的保护。因为一个加密算法如果仅能支持CPA安全性，那么中间人敌手可能会<strong>截获密文</strong>并对其进行针对性的<strong>篡改</strong>，从而使这种篡改也被施加到了<strong>解密后的明文</strong>中，进而敌手能通过篡改后的明文来攻破加密的不可区分性。</p>
<p>因此，我们希望一个算法还能实现对其输出密文的保护，使得敌手无法通过修改密文来观测解密算法的行为，IND-CCA就是由这一需求应运而生的。类似地，IND-CCA中敌手的优势可写作：</p>
<p>Pr[A wins]=Pr[b∗=b]=12+AdvIND−CCAE,D(A)Pr[� wins]=Pr[�∗=�]=12+Adv�,�IND−CCA(�)</p>
<h2 id="IND-CCA2"><a href="#IND-CCA2" class="headerlink" title="IND-CCA2"></a>IND-CCA2</h2><p>与上面的IND-CCA相比，IND-CCA2只多了一个步骤，如下所示。</p>
<p><img src="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220514162841123-1240011961.png" srcset="/img/loading.gif" lazyload alt="img">其步骤总结如下：</p>
<ol>
<li>Game中拥有一具有多项式资源的<strong>敌手A�</strong> 和一个能自由调用加解密oracle E,D�,� 的<strong>挑战者C�</strong>。</li>
<li>C� 随机选取K$←{0,1}n�←${0,1}�，作为加解密算法的密钥</li>
<li>A�向 C� 提交任意明文 m�, C� 计算对应的密文 c�</li>
<li>A� 向 C� 提交任意密文 c�, C� 计算对应的明文 m�</li>
<li>重复步骤3 q� 次, 步骤4 q′�′ 次 (即敌手查询 q� 次不同消息的密文, 查询q′�′ 次不同密文的解密结果)</li>
<li>A� 提交明文 m0�0 与 m1�1 给 C�</li>
<li>C� 以抛硬币（flip a coin）的形式随机选择一个比特 b$←{0,1}�←${0,1}, C� 加密返回挑战密文 cb��</li>
<li><strong>A� 在收到挑战密文 cb�� 后, 还可以向 C� 提交若干次解密查询</strong></li>
<li>A�自己的猜测比特 b∗�∗ (即敌手猜测 C� 是加密的 m0�0 还是 m1�1 )</li>
</ol>
<p>可以看到在第8步时， CCA2允许敌手在提交了自己的挑战明文后，依然能进行若干次解密查询。与CCA（或说CCA1）相比，CCA2令敌手通过最开始的若干次解密查询进行学习与观察后，即使收到了挑战密文 cb��，还能继续进行学习。</p>
<p>这个能力让敌手可根据 cb�� 继续去构造和猜测，而且CCA2中 C� 提供的 Oracle 相当于<strong>永久开放</strong>给敌手[1]，而CCA1在敌手最初查询后 Oracle 就不允许再访问了，因此CCA2这一定义是比CCA1更强的安全模型。</p>
<blockquote>
<p>小结📝：目前我们已介绍了三种安全模型IND-CPA、IND-CCA、IND-CCA2，这其中的敌手目的都是为了区分  mb�� 对应的密文。三者的安全要求逐渐提高，IND-CCA2也是目前标准定义下对安全性要求最高的模型，当前学术界一般认为一个新的公钥加密算法都应达到IND-CCA2的要求。</p>
</blockquote>
<h2 id="LOR-CPA"><a href="#LOR-CPA" class="headerlink" title="LOR-CPA"></a>LOR-CPA</h2><p>与IND-CPA相比，我们首先可以看到这个安全性定义的目标发生了变换，即从IND（不可区分性）变成了LOR（Left Or Right, 即左或右），但本质依旧不变。这一Game的具体示意图如下所示。</p>
<p><img src="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220515125648885-1832649954.png" srcset="/img/loading.gif" lazyload alt="img">可以看到，在LOR-CPA中，那个随机的bit b� 一开始就选择好了，即  C� 每次加密的其实都是左边或右边的明文。基本步骤如下所示:</p>
<ol>
<li>Game中拥有一具有多项式资源的<strong>敌手A�</strong> 和一个能自由调用加密算法oracle E� 的<strong>挑战者C�</strong>。</li>
<li>C� 随机选取K$←{0,1}n�←${0,1}�，作为加密算法的密钥</li>
<li>A� 提交明文 m0�0 与 m1�1 给 C�</li>
<li>C� 以抛硬币（flip a coin）的形式随机选择一个比特 b$←{0,1}�←${0,1} ,计算 mb�� 对应的密文 cb��</li>
<li>重复步骤 3 q� 次 (即敌手和挑战者实现 q� 次对左边或右边消息的加密)</li>
<li>敌手输出自己的猜测比特 b∗�∗</li>
</ol>
<p>在这一安全模型中，敌手的目标是猜测C�加密的是左右哪边的明文。因此，与IND-CPA相比，LOR-CPA这个Game本身其实是相当于IND-CPA的最后敌手应答挑战密文的那一次query。诚然在LOR-CPA中，敌手其实也可以重复多次进行 m0�0 与 m1�1 的查询，但那一随机bit始终是固定的。</p>
<p>而在安全强度方面，LOR-CPA比IND-CPA是要稍弱一些的[2]，因为LOR-CPA并不包含有若干次的任意明文的询问学习过程，虽然它不像IND-CPA那般成为了衡量加密算法安全性的“至上公理”[3]，但还是值得我们去记住和分析的。</p>
<h2 id="ROR-CPA"><a href="#ROR-CPA" class="headerlink" title="ROR-CPA"></a>ROR-CPA</h2><p>此处的ROR意为Real or Random， 该Game的示意图如下所示。</p>
<p><img src="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220515125632396-194368939.png" srcset="/img/loading.gif" lazyload alt="img">在ROR-CPA中，挑战者要么加密敌手所提供的输入，或者加密一个和敌手输入等长的随机字符串。而敌手的目标是决定C�加密的是真正的明文输入 (Real)， 还是一个随机的输入（random），这一Game的基本步骤如下所示：</p>
<ol>
<li>Game中拥有一具有多项式资源的<strong>敌手A�</strong> 和一个能自由调用加密算法oracle E� 的<strong>挑战者C�</strong>。</li>
<li>C� 随机选取K$←{0,1}n�←${0,1}�，作为加密算法的密钥</li>
<li>A� 向 C� 提交明文 m�</li>
<li>C� 以抛硬币（flip a coin）的形式随机选择一个比特 b$←{0,1}�←${0,1}, 令 mb=m��=� (b=0�=0) 或 mb$←{0,1}n��←${0,1}� (b=1�=1);</li>
<li>C� 计算并返回 mb�� 对应的密文 cb��</li>
<li>重复步骤 3-5 q� 次 (即敌手和挑战者实现 q� 次对左边或右边消息的加密)</li>
<li>敌手输出自己的猜测比特 b∗�∗</li>
</ol>
<p>ROR-CPA在安全性强度上是与LOR-CPA等价的。在介绍完ROR-CPA后，我们在<strong>不可区分性</strong>这一小节中的经典安全定义都总结完了，下面将会给大家介绍两个出现在很多实际Cyber Attack中的安全定义。</p>
<h2 id="Known-Plaintext-Attack"><a href="#Known-Plaintext-Attack" class="headerlink" title="Known Plaintext Attack"></a>Known Plaintext Attack</h2><p>本文一上来就为大家介绍了IND-CPA这个经典模型，而很多教材会先为读者介绍两个模型，即 Known Plaintext Attack 与 Ciphertext Only Attack。而在理解了IND-CPA及上述安全模型后，这两个安全定义就非常好理解了。</p>
<p>KPA的中文是”已知明文攻击”, 但其真正含义是敌手在可以获取一个加密算法的<strong>明文及对应密文</strong>之后，试图还原该算法的密钥。因此，KPA的安全定义更适用于一些主动的半侵入式攻击，即攻击者能实际获取并<strong>运行承载有这个密码算法的设备</strong>，比如智能卡，密码芯片等。</p>
<p>这样一来，敌手的目标就是希望通过不断调用这个设备里的密码算法，从而获取非常多的算法明密文对，进而尝试还原设备中的密钥，达到攻破甚至复制这一设备的最终目标。KPA这个安全定义常见于密码算法的能量侧信道分析中。</p>
<h2 id="Ciphertext-Only-Attack"><a href="#Ciphertext-Only-Attack" class="headerlink" title="Ciphertext Only Attack"></a>Ciphertext Only Attack</h2><p>同理，COA就表示唯密文攻击，即敌手仅能以中间人的状态截获一些算法的密文，他无法调用这个算法，即仅能通过眼前拿到的这一堆密文中，尝试得到与明文或者密钥有关的信息。</p>
<p>可以看到，唯密文攻击是几个定义中敌手能力最弱的了，敌手无法自行构造与选择要加密或解密的明密文，也无法自由地调用这个算法。KPA与COA这两种有些另类的安全模型通常会出现在一些系统安全的问题中，如一些网络攻击，物理攻击等。在密码理论领域中，前文介绍的几类模型是更为常用的。 </p>
<h1 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h1><h2 id="INT-CTXT"><a href="#INT-CTXT" class="headerlink" title="INT-CTXT"></a>INT-CTXT</h2><p>谈到数据完整性，我们主要考虑的是消息（明文， PlainText）完整性或算法输出（密文，CiphtText）的完整性。因此，INT（Integrity）可以理解为，敌手无法伪造一段<strong>密文</strong>或某段合法密文对应的<strong>明文</strong>，使其在接收方看来是由发送方生成且传输过程中未受到任何篡改的。</p>
<p>因此，INT-CTXT这一Game的主要步骤为：</p>
<ol>
<li>Game中拥有一具有多项式资源的<strong>敌手 A�</strong> 和一个能自由调用加密算法oracle E� 的<strong>挑战者C�</strong>。</li>
<li>C� 随机选取K$←{0,1}n�←${0,1}�，作为加密算法的密钥</li>
<li>A� 向 C� 提交明文 m�, C� 计算 m� 对应的密文 c�</li>
<li>重复步骤 3 q� 次 (即敌手查询 q� 次不同消息的密文)</li>
<li>A� 提交一密文 c∗�∗ 给 C�</li>
<li>C� 对  c∗�∗ 执行解密操作, 返回解密后的消息 m∗�∗;</li>
</ol>
<p>其示意图如下图所示:</p>
<p><img src="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220516145308412-1148001009.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>这一安全模型中，敌手可以多次访问加密Oracle，而最终进行挑战时，需提交一个密文 c∗�∗, 其目的是使 c∗�∗ 能正常通过解密算法得到一个明文 m∗�∗。如果 m∗�∗ 非空 （即真的完成了解密过程）且 c∗�∗ 没有在查询阶段出现过，那么就称 A� 赢得这个Game。此时大家就会想到，岂不是任何一个对称加解密算法都做不到INT-CTXT吗？</p>
<p>没错，一个<strong>不加任何防护</strong>的对称密码算法，如AES，就是不能做到INT-CTXT安全性，因为任何人可以随便拿一条数据输入到解密算法里，只要数据的格式是正确的，虽然解密输出的内容可能是一些杂乱的无意义字符，但依然是有效的明文。</p>
<p>因此，如果要达到INT-CTXT安全性，就必须对原有算法<strong>输出的密文加以防护</strong>，例如增加一消息认证算法（MAC）等。看到这里，可能很多读者会联想这一安全性与上文中IND-CCA的联系。其实，当一个算法同时具备IND-CPA与INT-CTXT安全性时，该算法就有潜力是IND-CCA安全的；这一结论通常被用于<strong>认证加密算法</strong>的安全性证明中。</p>
<h2 id="INT-PTXT"><a href="#INT-PTXT" class="headerlink" title="INT-PTXT"></a>INT-PTXT</h2><p>与密文完整性相对应，PTXT指的是明文的完整性，而这一Game的步骤与INT-CTXT完全相同。唯一的区别在于，INT-PTXT中的敌手 A� 获胜的条件是：解密后的 m∗�∗ 非空且 m∗�∗ 没有在之前的查询过程中提交过。注意INT-CTXT要求的则是 c∗�∗ 没有出现过。</p>
<p>通常, INT-CTXT中这一安全性是稍强于INT-PTXT的，即对于一个方案而言，如果是INT-CTXT安全的，那么也一定是INT-PTXT安全的。这也不难理解，因为在解密算法为<strong>确定的</strong>、<strong>无碰撞</strong>的条件下，如果一个明文 m∗�∗ 没有提交过，那么加密后的密文必然也没有出现过；否则如果密文 c∗�∗ 出现过的话，由加解密置换的唯一性可知  c∗�∗ 对应的明文必然也出现过。因此一般情况下，我们希望能够证明某个算法是INT-CTXT安全的。</p>
<blockquote>
<p>💡 在数据完整性中，有些读者可能会想到密码学哈希函数的三个安全性质: 单向性、弱碰撞性、强碰撞性；而本文主要聚焦一个密码算法数据完整性的通用模型，哈希函数可以作为一种实现上述数据完整性的工具。 </p>
</blockquote>
<h1 id="抗否性与身份认证"><a href="#抗否性与身份认证" class="headerlink" title="抗否性与身份认证"></a>抗否性与身份认证</h1><p>介绍完了数据完整性后，我们该介绍最后一部分常见的安全需求与安全模型了，即抗否性（Non-repudiation），或称抗抵赖性。这一需求是指某一方计算出的数据是与它身份绑定的，没有其他人能像这一方本人一样计算出一样的数据。因此，数字签名、身份认证等算法或协议需要对这一性质加以描述。下面将介绍几个最常见的安全模型。</p>
<h2 id="EUF-CMA"><a href="#EUF-CMA" class="headerlink" title="EUF-CMA"></a>EUF-CMA</h2><p>这一模型中的CMA指Chosen Message Attack，即选择消息攻击，本质上与CPA其实是一样的，只不过在数字签名等算法中，用消息一词要比明文更加贴切。CMA和CPA都是形容敌手能自由地向算法提交输入并获得的相应输出这一能力。</p>
<p>EUF则是指存在性不可伪造，即 Existential UnForgeability，指的是对于消息认证、数字签名等算法而言，当敌手通过查询获得了 q� 个签名后， 他无法再获得第 q+1�+1 个签名。这一Game的示意图如下所示。</p>
<p><img src="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220517145446612-124220213.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p> 可以看到，其基本形式依然和前文的模型保持相似，在查询阶段，敌手 A� 可不断与一实现了签名Oracle的 C� 交互，来获得所提交消息 m�的签名 σ�。在进行 q� 次交互后，敌手将输出一对 (m∗,σ∗)(�∗,�∗)。这一Game的主要步骤为：</p>
<ol>
<li>Game中拥有一具有多项式资源的<strong>敌手 A�</strong> 和一个能自由调用签名算法oracle E� 的<strong>挑战者C�</strong>。</li>
<li>C� 随机选取sk$←{0,1}n��←${0,1}�，作为签名算法的私钥</li>
<li>A� 向 C� 提交消息 m�, C� 得到 m� 对应的签名 σ�</li>
<li>重复步骤 3 q� 次 (即敌手查询 q� 次不同消息的签名)</li>
<li>A� 输出一对 (m∗,σ∗)(�∗,�∗);</li>
<li>C� 对  σ∗�∗ 进行验证，并返回验证结果;</li>
</ol>
<p>若最后敌手输出的 m∗�∗ 未曾被查询过，且 σ∗�∗ 能通过验证，就可认为敌手挑战成功。这一结果即为“<strong>签名的伪造</strong>”，此处敌手的优势可写为：</p>
<p>AdvEUF−CMAS(A)=Pr[A forges (m∗,σ∗)]Adv�EUF−CMA(�)=Pr[� forges (�∗,�∗)]</p>
<h2 id="SUF-CMA"><a href="#SUF-CMA" class="headerlink" title="SUF-CMA"></a>SUF-CMA</h2><p>在EUF-CMA中，E表示的是Existential，而此处的SUF的S则表示Strong，即强不可伪造性，这一Game的基本模型如下图所示。</p>
<p><img src="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220517145454808-1367273401.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>与EUF-CMA相比，SUF-CMA唯一的不同之处在于敌手最终输出伪造的签名对 (m∗,σ∗)(�∗,�∗) 时，不仅要求 m∗�∗ 是未曾查询过的，也要求签名 σ∗�∗ 是未曾出现过的。因此，EUF-CMA这一Game中的敌手只需要寻找到 m� 关于 σ� 的一个<strong>碰撞</strong>即可，而在SUF-CMA中，敌手的任务并不是要找碰撞，而是要从根本上伪造出一个签名消息对。</p>
<p>EUF-CMA中的敌手最差也可以使用<strong>生日攻击</strong>去暴力地寻找碰撞，而SUF-CMA中的敌手则是应真正生成去另外一对 (m∗,σ∗)(�∗,�∗)。因此，SUF-CMA是比EUF-CMA安全性更强的安全模型。这两个模型通常用于消息认证、数字签名算法的安全性定义上，以说明其签名的不可伪造性，从而使实体是不可抵赖。</p>
<h2 id="Impersonation"><a href="#Impersonation" class="headerlink" title="Impersonation"></a>Impersonation</h2><p>这一部分要说明的安全模型与本文前面所介绍的都有所不同，对于一个身份认证协议而言，impersonation表示敌手最终能假冒某个合法用户的身份通过认证。这一概念最开始是为了描述Fiat-Shamir Protocol 以及 Shnorr Identification Protocol的安全性。</p>
<p>然而，身份认证协议是多种多样的，这一安全模型也不像上面的 EUF-CMA 等具有统一的定义方式。不过，Impersonation的基本过程依然可以总结为“查询-挑战”两个阶段， 即敌手先根据协议开放的某个Oracle进行查询，之后生成认证数据“试图”通过协议的检查，完成身份的认证。</p>
<blockquote>
<p>小结📝: 到此为止，几个经典的安全模型均介绍完毕。下面本文将介绍量子计算机模型下的安全模型，与这些经典安全模型相比，它们的交互方式与计算方法均有所不同。 </p>
</blockquote>
<h1 id="量子安全模型"><a href="#量子安全模型" class="headerlink" title="量子安全模型"></a>量子安全模型</h1><h2 id="量子计算与量子查询"><a href="#量子计算与量子查询" class="headerlink" title="量子计算与量子查询"></a>量子计算与量子查询</h2><p>为介绍量子计算机下的安全模型， 需要了解下载量子计算机中的算法有何不同。而量子计算机离不开量子力学，我们最熟悉的关于量子力学的理论莫过于<strong>薛定谔的猫</strong>。量子的世界本质上是用态（ ψ� ）来描述的，例如，放着猫的盒子如果看作一个量子世界的话, 薛定谔的猫死了其实就是一个<strong>态</strong>（纯态），而薛定谔的猫既生又死也是一个态，只不过是一个<strong>叠加态</strong>（混态）。那么，量子计算机究竟强大在何处呢? </p>
<p>量子计算机与量子算法的基本操作对象是<strong>量子比特</strong>（qubit），而在量子世界中，一个量子比特可以既是0也是1，即处于0-1叠加态。这样一来，量子计算机中的一个8 qbit寄存器，在某一时刻可<strong>最多表示 2828 条数据</strong>！但经典计算机中的8 bit寄存器某一时刻只能存1个数据。因此，对8 qbit寄存器里的数据运算一次，能最多得到 2828种结果，这与经典计算机相比会是指数级别的算力提升。这也就是为什么密码学家们对于量子计算机的出现如此恐慌了。那么，我们的安全模型在量子计算下该如何表示呢？</p>
<p>首先，需要明确量子安全模型中<strong>敌我的能力与目标</strong>。在量子安全模型中, 敌手和挑战者是都具备量子计算能力的, 而挑战者中的密码算法已经被实现或抽象为了一个quantum accessable oracle。注意算法本身是可运行于经典计算机上的, 只不过为了方便，我们人为抽象它为一个量子oracle。此时这个算法在面对一个8 qbit的输入数据叠加态时，能直接对其操作并返回对应的输出数据叠加态。即，<strong>算法的功能不变，但支持了对叠加态量子数据的操作</strong>。</p>
<p>由此，在量子计算下，敌手 A� 发起的一次针对加密算法的量子查询可以表示如下[4]：∑m,cψm,c|m,c⟩⟶∑m,cψm,c|m,c⊕Enc(k,m)⟩∑�,���,�|�,�⟩⟶∑�,���,�|�,�⊕Enc⁡(�,�)⟩ 这个式子第一眼看上去可能完全不知道在做什么，不要急我们一一解释。式子中的左半边到右半边, 表示这一次量子查询前后敌手 A� 的<strong>状态变化。</strong>而式子左右两端的求和式, 分别表示<strong>两个量子叠加态</strong> (一个量子计算机的当前状态可用一个叠加态来表示)。因此，这个式子实际就表示一次<strong>敌手的量子计算机状态的转换</strong>。</p>
<p>而敌我双方量子计算机所执行的运算, 本质就是在读写两个量子寄存器中的数据: 一个输入明文量子寄存器 <strong>QM</strong> 和一个输出密文量子寄存器 <strong>QC</strong> 。对于敌手 A�, 他在查询时会往QM中”叠加”入大量的明文消息, QC则置空；对于挑战者 C�, 则会读取 QM 中传过来的明文叠加态, 进行加密算法的运算后, 得到密文的叠加态并写入 QC 中，返回给敌手。</p>
<p>那回归到式子本身, ∑m,cψm,c|m,c⟩∑�,���,�|�,�⟩其实就表示将若干个明文态叠加起来变成一个叠加态, 即查询前的量子寄存器的内容。∑m,cψm,c|m,c⊕Enc(k,m)⟩∑�,���,�|�,�⊕Enc⁡(�,�)⟩ 则表示挑战者计算后, 往QC中叠加了密文后的新叠加态。式子中的 ψ� 表示某个量子态的表征值。</p>
<p>因此, 量子查询用一句话概括就是: 对于QM, QC这两个量子寄存器而言, A� 往QM里叠加消息并提交给挑战者, C� 计算后往QC里叠加密文并返回给敌手。这一过程的示意图如下:</p>
<p><img src="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220518114312292-2088865640.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="IND-qCPA"><a href="#IND-qCPA" class="headerlink" title="IND-qCPA"></a>IND-qCPA</h2><p>那么在明确量子查询的含义后, IND-qCPA的过程其实就明了了. 这一Game的示意图如下所示:</p>
<p><img src="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220520143501420-324864716.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>可以看到, 在敌手的查询部分, 就是采用的我们上面介绍的量子查询; 然而, 在最终的挑战环节, 敌手和挑战者依然采用的是经典模型。这是因为如果敌手如果最终的挑战也是以量子寄存器的方式进行的话, Boneh等曾证明了敌手总能正确猜测出来那个bit b�。</p>
<p>因此, 我们不得不妥协一下, 让敌手可以执行量子查询, 但是<strong>不能执行量子挑战。</strong>除此以外, IND-CPA与IND-CCA是如何理解的, IND-qCPA与IND-qCCA 我们还可以怎么去理解。</p>
<h2 id="EUF-qCMA"><a href="#EUF-qCMA" class="headerlink" title="EUF-qCMA"></a>EUF-qCMA</h2><p> 而对于量子签名查询, 和加密类似, 核心的框架依然没变, 只是套用了量子查询这种形式下。这一Game的示意图如下所示:</p>
<p><img src="https://img2022.cnblogs.com/blog/2547408/202205/2547408-20220520143629734-632760535.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>同理, 签名方案下的量子状态转移式, 应该写作[5]: ∑m,σψm,σ|m,σ⟩⟶∑m,σψm,σ|m,σ⊕Sign(k,m)⟩∑�,���,�|�,�⟩⟶∑�,���,�|�,�⊕Sign⁡(�,�)⟩ 此处的签名挑战同样是在经典计算机而非量子计算机下执行的。</p>
<blockquote>
<p>可能很多读者此时心中有个疑问❓：量子查询与量子安全模型和经典模型似乎也没什么不同嘛！那为什么量子安全模型普遍认为是更强的安全性要求呢？</p>
<p>还记得本节开始时提到，一个量子寄存器中蕴含了指数量级的数据，但是攻击者在<strong>观测</strong>这个量子寄存器时，会发生<strong>叠加态的坍缩</strong>，即虽然有那么多数据，但攻击者每次依然只能获得一个值。</p>
<p>然而，他可以借助高效的<strong>量子搜索算法</strong>迅速地找到自己想要的那个值。Grover算法[6]、Shor算法、Simon算法、Deutsch–Jozsa 算法等就是能在量子叠加态数据中，以较低的复杂度进行查找的量子算法。量子安全模型中的敌手也可以使用这些算法，这就是让密码学家们一直担忧的达摩克利斯之剑。</p>
</blockquote>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>现代密码学中的主要安全模型与后量子安全模型已经全部介绍完了, 如果我们总结下规律可以发现, 这些安全模型的定义都遵从 <strong>安全目标</strong>-<strong>交互模型</strong> 这个规则, 例如IND-CPA中IND形容的是算法输出达到不可区分性, 而达到这一目标是在选择明文攻击 (CPA)这一交互模型下实现的。</p>
<p>因此, 只要你能严格的定义出某种交互模型以及对应的安全目标, 你就能提出属于你的安全模型。因此，其实还有很多学术界会用到的密码学安全模型本文是没有介绍的，但万变不离其宗，任何一个密码学安全模型都脱离不了所针对的算法功能及安全目标。</p>
<p>综上，本文一共介绍了14个现代密码学中的安全模型，了解它们的结构和原理可以为密码学中的安全性证明打下坚实的基础。最后，感谢你的阅读，以一句歌词作为结束。</p>
<p>“<em>毋忘你 精彩过别来无恙如游戏</em>，<em>我本人 明白什么都总有限期” —— 吴雨霏《我本人》</em></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>[1] <a target="_blank" rel="noopener" href="https://crypto.stackexchange.com/questions/99295/the-essential-differences-between-ind-cca1-and-ind-cca2">https://crypto.stackexchange.com/questions/99295/the-essential-differences-between-ind-cca1-and-ind-cca2</a><br>[2] <a target="_blank" rel="noopener" href="https://crypto.stackexchange.com/questions/33279/difference-left-or-right-cpa-security-ind-cpa-security">https://crypto.stackexchange.com/questions/33279/difference-left-or-right-cpa-security-ind-cpa-security</a><br>[3] <a target="_blank" rel="noopener" href="https://link.springer.com/content/pdf/10.1007/s00145-008-9026-x.pdf">https://link.springer.com/content/pdf/10.1007/s00145-008-9026-x.pdf</a><br>[4] <a target="_blank" rel="noopener" href="https://eprint.iacr.org/2012/606.pdf">https://eprint.iacr.org/2012/606.pdf</a><br>[5] <a target="_blank" rel="noopener" href="https://eprint.iacr.org/2013/088.pdf">https://eprint.iacr.org/2013/088.pdf</a><br>[6] <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Grover&#39;s_algorithm">https://en.wikipedia.org/wiki/Grover&#39;s_algorithm</a></p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Cryptography</div>
      <div>https://yuwxl.github.io/2023/03/14/Cryptography/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>nayun</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年3月14日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/03/15/POSE/" title="POSE">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">POSE</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/03/06/Self-Supervised-FL/" title="Self-Supervised_FL">
                        <span class="hidden-mobile">Self-Supervised_FL</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
